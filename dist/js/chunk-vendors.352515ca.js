"use strict";
(self["webpackChunkmy_vue_app"] = self["webpackChunkmy_vue_app"] || []).push([[504], {
    1656: function(t, e, n) {
        function i(t, e, n, i, r, a, o, s) {
            var c, l = "function" === typeof t ? t.options : t;
            if (e && (l.render = e,
            l.staticRenderFns = n,
            l._compiled = !0),
            i && (l.functional = !0),
            a && (l._scopeId = "data-v-" + a),
            o ? (c = function(t) {
                t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext,
                t || "undefined" === typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__),
                r && r.call(this, t),
                t && t._registeredComponents && t._registeredComponents.add(o)
            }
            ,
            l._ssrRegister = c) : r && (c = s ? function() {
                r.call(this, (l.functional ? this.parent : this).$root.$options.shadowRoot)
            }
            : r),
            c)
                if (l.functional) {
                    l._injectStyles = c;
                    var u = l.render;
                    l.render = function(t, e) {
                        return c.call(e),
                        u(t, e)
                    }
                } else {
                    var h = l.beforeCreate;
                    l.beforeCreate = h ? [].concat(h, c) : [c]
                }
            return {
                exports: t,
                options: l
            }
        }
        n.d(e, {
            A: function() {
                return i
            }
        })
    },
    1594: function(t, e, n) {
        n(4114);
        function i(t, e) {
            0
        }
        function r(t) {
            return Object.prototype.toString.call(t).indexOf("Error") > -1
        }
        function a(t, e) {
            return e instanceof t || e && (e.name === t.name || e._name === t._name)
        }
        function o(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }
        var s = {
            name: "RouterView",
            functional: !0,
            props: {
                name: {
                    type: String,
                    default: "default"
                }
            },
            render: function(t, e) {
                var n = e.props
                  , i = e.children
                  , r = e.parent
                  , a = e.data;
                a.routerView = !0;
                var s = r.$createElement
                  , l = n.name
                  , u = r.$route
                  , h = r._routerViewCache || (r._routerViewCache = {})
                  , d = 0
                  , p = !1;
                while (r && r._routerRoot !== r) {
                    var f = r.$vnode ? r.$vnode.data : {};
                    f.routerView && d++,
                    f.keepAlive && r._directInactive && r._inactive && (p = !0),
                    r = r.$parent
                }
                if (a.routerViewDepth = d,
                p) {
                    var m = h[l]
                      , g = m && m.component;
                    return g ? (m.configProps && c(g, a, m.route, m.configProps),
                    s(g, a, i)) : s()
                }
                var v = u.matched[d]
                  , _ = v && v.components[l];
                if (!v || !_)
                    return h[l] = null,
                    s();
                h[l] = {
                    component: _
                },
                a.registerRouteInstance = function(t, e) {
                    var n = v.instances[l];
                    (e && n !== t || !e && n === t) && (v.instances[l] = e)
                }
                ,
                (a.hook || (a.hook = {})).prepatch = function(t, e) {
                    v.instances[l] = e.componentInstance
                }
                ,
                a.hook.init = function(t) {
                    t.data.keepAlive && t.componentInstance && t.componentInstance !== v.instances[l] && (v.instances[l] = t.componentInstance)
                }
                ;
                var y = v.props && v.props[l];
                return y && (o(h[l], {
                    route: u,
                    configProps: y
                }),
                c(_, a, u, y)),
                s(_, a, i)
            }
        };
        function c(t, e, n, i) {
            var r = e.props = l(n, i);
            if (r) {
                r = e.props = o({}, r);
                var a = e.attrs = e.attrs || {};
                for (var s in r)
                    t.props && s in t.props || (a[s] = r[s],
                    delete r[s])
            }
        }
        function l(t, e) {
            switch (typeof e) {
            case "undefined":
                return;
            case "object":
                return e;
            case "function":
                return e(t);
            case "boolean":
                return e ? t.params : void 0;
            default:
                0
            }
        }
        var u = /[!'()*]/g
          , h = function(t) {
            return "%" + t.charCodeAt(0).toString(16)
        }
          , d = /%2C/g
          , p = function(t) {
            return encodeURIComponent(t).replace(u, h).replace(d, ",")
        }
          , f = decodeURIComponent;
        function m(t, e, n) {
            void 0 === e && (e = {});
            var i, r = n || g;
            try {
                i = r(t || "")
            } catch (o) {
                i = {}
            }
            for (var a in e)
                i[a] = e[a];
            return i
        }
        function g(t) {
            var e = {};
            return t = t.trim().replace(/^(\?|#|&)/, ""),
            t ? (t.split("&").forEach((function(t) {
                var n = t.replace(/\+/g, " ").split("=")
                  , i = f(n.shift())
                  , r = n.length > 0 ? f(n.join("=")) : null;
                void 0 === e[i] ? e[i] = r : Array.isArray(e[i]) ? e[i].push(r) : e[i] = [e[i], r]
            }
            )),
            e) : e
        }
        function v(t) {
            var e = t ? Object.keys(t).map((function(e) {
                var n = t[e];
                if (void 0 === n)
                    return "";
                if (null === n)
                    return p(e);
                if (Array.isArray(n)) {
                    var i = [];
                    return n.forEach((function(t) {
                        void 0 !== t && (null === t ? i.push(p(e)) : i.push(p(e) + "=" + p(t)))
                    }
                    )),
                    i.join("&")
                }
                return p(e) + "=" + p(n)
            }
            )).filter((function(t) {
                return t.length > 0
            }
            )).join("&") : null;
            return e ? "?" + e : ""
        }
        var _ = /\/?$/;
        function y(t, e, n, i) {
            var r = i && i.options.stringifyQuery
              , a = e.query || {};
            try {
                a = x(a)
            } catch (s) {}
            var o = {
                name: e.name || t && t.name,
                meta: t && t.meta || {},
                path: e.path || "/",
                hash: e.hash || "",
                query: a,
                params: e.params || {},
                fullPath: S(e, r),
                matched: t ? b(t) : []
            };
            return n && (o.redirectedFrom = S(n, r)),
            Object.freeze(o)
        }
        function x(t) {
            if (Array.isArray(t))
                return t.map(x);
            if (t && "object" === typeof t) {
                var e = {};
                for (var n in t)
                    e[n] = x(t[n]);
                return e
            }
            return t
        }
        var M = y(null, {
            path: "/"
        });
        function b(t) {
            var e = [];
            while (t)
                e.unshift(t),
                t = t.parent;
            return e
        }
        function S(t, e) {
            var n = t.path
              , i = t.query;
            void 0 === i && (i = {});
            var r = t.hash;
            void 0 === r && (r = "");
            var a = e || v;
            return (n || "/") + a(i) + r
        }
        function E(t, e) {
            return e === M ? t === e : !!e && (t.path && e.path ? t.path.replace(_, "") === e.path.replace(_, "") && t.hash === e.hash && T(t.query, e.query) : !(!t.name || !e.name) && (t.name === e.name && t.hash === e.hash && T(t.query, e.query) && T(t.params, e.params)))
        }
        function T(t, e) {
            if (void 0 === t && (t = {}),
            void 0 === e && (e = {}),
            !t || !e)
                return t === e;
            var n = Object.keys(t)
              , i = Object.keys(e);
            return n.length === i.length && n.every((function(n) {
                var i = t[n]
                  , r = e[n];
                return "object" === typeof i && "object" === typeof r ? T(i, r) : String(i) === String(r)
            }
            ))
        }
        function w(t, e) {
            return 0 === t.path.replace(_, "/").indexOf(e.path.replace(_, "/")) && (!e.hash || t.hash === e.hash) && A(t.query, e.query)
        }
        function A(t, e) {
            for (var n in e)
                if (!(n in t))
                    return !1;
            return !0
        }
        function R(t, e, n) {
            var i = t.charAt(0);
            if ("/" === i)
                return t;
            if ("?" === i || "#" === i)
                return e + t;
            var r = e.split("/");
            n && r[r.length - 1] || r.pop();
            for (var a = t.replace(/^\//, "").split("/"), o = 0; o < a.length; o++) {
                var s = a[o];
                ".." === s ? r.pop() : "." !== s && r.push(s)
            }
            return "" !== r[0] && r.unshift(""),
            r.join("/")
        }
        function C(t) {
            var e = ""
              , n = ""
              , i = t.indexOf("#");
            i >= 0 && (e = t.slice(i),
            t = t.slice(0, i));
            var r = t.indexOf("?");
            return r >= 0 && (n = t.slice(r + 1),
            t = t.slice(0, r)),
            {
                path: t,
                query: n,
                hash: e
            }
        }
        function P(t) {
            return t.replace(/\/\//g, "/")
        }
        var L = Array.isArray || function(t) {
            return "[object Array]" == Object.prototype.toString.call(t)
        }
          , I = Z
          , U = B
          , D = k
          , N = H
          , O = K
          , F = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");
        function B(t, e) {
            var n, i = [], r = 0, a = 0, o = "", s = e && e.delimiter || "/";
            while (null != (n = F.exec(t))) {
                var c = n[0]
                  , l = n[1]
                  , u = n.index;
                if (o += t.slice(a, u),
                a = u + c.length,
                l)
                    o += l[1];
                else {
                    var h = t[a]
                      , d = n[2]
                      , p = n[3]
                      , f = n[4]
                      , m = n[5]
                      , g = n[6]
                      , v = n[7];
                    o && (i.push(o),
                    o = "");
                    var _ = null != d && null != h && h !== d
                      , y = "+" === g || "*" === g
                      , x = "?" === g || "*" === g
                      , M = n[2] || s
                      , b = f || m;
                    i.push({
                        name: p || r++,
                        prefix: d || "",
                        delimiter: M,
                        optional: x,
                        repeat: y,
                        partial: _,
                        asterisk: !!v,
                        pattern: b ? j(b) : v ? ".*" : "[^" + G(M) + "]+?"
                    })
                }
            }
            return a < t.length && (o += t.substr(a)),
            o && i.push(o),
            i
        }
        function k(t, e) {
            return H(B(t, e), e)
        }
        function z(t) {
            return encodeURI(t).replace(/[\/?#]/g, (function(t) {
                return "%" + t.charCodeAt(0).toString(16).toUpperCase()
            }
            ))
        }
        function V(t) {
            return encodeURI(t).replace(/[?#]/g, (function(t) {
                return "%" + t.charCodeAt(0).toString(16).toUpperCase()
            }
            ))
        }
        function H(t, e) {
            for (var n = new Array(t.length), i = 0; i < t.length; i++)
                "object" === typeof t[i] && (n[i] = new RegExp("^(?:" + t[i].pattern + ")$",X(e)));
            return function(e, i) {
                for (var r = "", a = e || {}, o = i || {}, s = o.pretty ? z : encodeURIComponent, c = 0; c < t.length; c++) {
                    var l = t[c];
                    if ("string" !== typeof l) {
                        var u, h = a[l.name];
                        if (null == h) {
                            if (l.optional) {
                                l.partial && (r += l.prefix);
                                continue
                            }
                            throw new TypeError('Expected "' + l.name + '" to be defined')
                        }
                        if (L(h)) {
                            if (!l.repeat)
                                throw new TypeError('Expected "' + l.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
                            if (0 === h.length) {
                                if (l.optional)
                                    continue;
                                throw new TypeError('Expected "' + l.name + '" to not be empty')
                            }
                            for (var d = 0; d < h.length; d++) {
                                if (u = s(h[d]),
                                !n[c].test(u))
                                    throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '", but received `' + JSON.stringify(u) + "`");
                                r += (0 === d ? l.prefix : l.delimiter) + u
                            }
                        } else {
                            if (u = l.asterisk ? V(h) : s(h),
                            !n[c].test(u))
                                throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but received "' + u + '"');
                            r += l.prefix + u
                        }
                    } else
                        r += l
                }
                return r
            }
        }
        function G(t) {
            return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
        }
        function j(t) {
            return t.replace(/([=!:$\/()])/g, "\\$1")
        }
        function W(t, e) {
            return t.keys = e,
            t
        }
        function X(t) {
            return t && t.sensitive ? "" : "i"
        }
        function q(t, e) {
            var n = t.source.match(/\((?!\?)/g);
            if (n)
                for (var i = 0; i < n.length; i++)
                    e.push({
                        name: i,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        partial: !1,
                        asterisk: !1,
                        pattern: null
                    });
            return W(t, e)
        }
        function $(t, e, n) {
            for (var i = [], r = 0; r < t.length; r++)
                i.push(Z(t[r], e, n).source);
            var a = new RegExp("(?:" + i.join("|") + ")",X(n));
            return W(a, e)
        }
        function Y(t, e, n) {
            return K(B(t, n), e, n)
        }
        function K(t, e, n) {
            L(e) || (n = e || n,
            e = []),
            n = n || {};
            for (var i = n.strict, r = !1 !== n.end, a = "", o = 0; o < t.length; o++) {
                var s = t[o];
                if ("string" === typeof s)
                    a += G(s);
                else {
                    var c = G(s.prefix)
                      , l = "(?:" + s.pattern + ")";
                    e.push(s),
                    s.repeat && (l += "(?:" + c + l + ")*"),
                    l = s.optional ? s.partial ? c + "(" + l + ")?" : "(?:" + c + "(" + l + "))?" : c + "(" + l + ")",
                    a += l
                }
            }
            var u = G(n.delimiter || "/")
              , h = a.slice(-u.length) === u;
            return i || (a = (h ? a.slice(0, -u.length) : a) + "(?:" + u + "(?=$))?"),
            a += r ? "$" : i && h ? "" : "(?=" + u + "|$)",
            W(new RegExp("^" + a,X(n)), e)
        }
        function Z(t, e, n) {
            return L(e) || (n = e || n,
            e = []),
            n = n || {},
            t instanceof RegExp ? q(t, e) : L(t) ? $(t, e, n) : Y(t, e, n)
        }
        I.parse = U,
        I.compile = D,
        I.tokensToFunction = N,
        I.tokensToRegExp = O;
        var J = Object.create(null);
        function Q(t, e, n) {
            e = e || {};
            try {
                var i = J[t] || (J[t] = I.compile(t));
                return "string" === typeof e.pathMatch && (e[0] = e.pathMatch),
                i(e, {
                    pretty: !0
                })
            } catch (r) {
                return ""
            } finally {
                delete e[0]
            }
        }
        function tt(t, e, n, i) {
            var r = "string" === typeof t ? {
                path: t
            } : t;
            if (r._normalized)
                return r;
            if (r.name) {
                r = o({}, t);
                var a = r.params;
                return a && "object" === typeof a && (r.params = o({}, a)),
                r
            }
            if (!r.path && r.params && e) {
                r = o({}, r),
                r._normalized = !0;
                var s = o(o({}, e.params), r.params);
                if (e.name)
                    r.name = e.name,
                    r.params = s;
                else if (e.matched.length) {
                    var c = e.matched[e.matched.length - 1].path;
                    r.path = Q(c, s, "path " + e.path)
                } else
                    0;
                return r
            }
            var l = C(r.path || "")
              , u = e && e.path || "/"
              , h = l.path ? R(l.path, u, n || r.append) : u
              , d = m(l.query, r.query, i && i.options.parseQuery)
              , p = r.hash || l.hash;
            return p && "#" !== p.charAt(0) && (p = "#" + p),
            {
                _normalized: !0,
                path: h,
                query: d,
                hash: p
            }
        }
        var et, nt = [String, Object], it = [String, Array], rt = function() {}, at = {
            name: "RouterLink",
            props: {
                to: {
                    type: nt,
                    required: !0
                },
                tag: {
                    type: String,
                    default: "a"
                },
                exact: Boolean,
                append: Boolean,
                replace: Boolean,
                activeClass: String,
                exactActiveClass: String,
                ariaCurrentValue: {
                    type: String,
                    default: "page"
                },
                event: {
                    type: it,
                    default: "click"
                }
            },
            render: function(t) {
                var e = this
                  , n = this.$router
                  , i = this.$route
                  , r = n.resolve(this.to, i, this.append)
                  , a = r.location
                  , s = r.route
                  , c = r.href
                  , l = {}
                  , u = n.options.linkActiveClass
                  , h = n.options.linkExactActiveClass
                  , d = null == u ? "router-link-active" : u
                  , p = null == h ? "router-link-exact-active" : h
                  , f = null == this.activeClass ? d : this.activeClass
                  , m = null == this.exactActiveClass ? p : this.exactActiveClass
                  , g = s.redirectedFrom ? y(null, tt(s.redirectedFrom), null, n) : s;
                l[m] = E(i, g),
                l[f] = this.exact ? l[m] : w(i, g);
                var v = l[m] ? this.ariaCurrentValue : null
                  , _ = function(t) {
                    ot(t) && (e.replace ? n.replace(a, rt) : n.push(a, rt))
                }
                  , x = {
                    click: ot
                };
                Array.isArray(this.event) ? this.event.forEach((function(t) {
                    x[t] = _
                }
                )) : x[this.event] = _;
                var M = {
                    class: l
                }
                  , b = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
                    href: c,
                    route: s,
                    navigate: _,
                    isActive: l[f],
                    isExactActive: l[m]
                });
                if (b) {
                    if (1 === b.length)
                        return b[0];
                    if (b.length > 1 || !b.length)
                        return 0 === b.length ? t() : t("span", {}, b)
                }
                if ("a" === this.tag)
                    M.on = x,
                    M.attrs = {
                        href: c,
                        "aria-current": v
                    };
                else {
                    var S = st(this.$slots.default);
                    if (S) {
                        S.isStatic = !1;
                        var T = S.data = o({}, S.data);
                        for (var A in T.on = T.on || {},
                        T.on) {
                            var R = T.on[A];
                            A in x && (T.on[A] = Array.isArray(R) ? R : [R])
                        }
                        for (var C in x)
                            C in T.on ? T.on[C].push(x[C]) : T.on[C] = _;
                        var P = S.data.attrs = o({}, S.data.attrs);
                        P.href = c,
                        P["aria-current"] = v
                    } else
                        M.on = x
                }
                return t(this.tag, M, this.$slots.default)
            }
        };
        function ot(t) {
            if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && (void 0 === t.button || 0 === t.button)) {
                if (t.currentTarget && t.currentTarget.getAttribute) {
                    var e = t.currentTarget.getAttribute("target");
                    if (/\b_blank\b/i.test(e))
                        return
                }
                return t.preventDefault && t.preventDefault(),
                !0
            }
        }
        function st(t) {
            if (t)
                for (var e, n = 0; n < t.length; n++) {
                    if (e = t[n],
                    "a" === e.tag)
                        return e;
                    if (e.children && (e = st(e.children)))
                        return e
                }
        }
        function ct(t) {
            if (!ct.installed || et !== t) {
                ct.installed = !0,
                et = t;
                var e = function(t) {
                    return void 0 !== t
                }
                  , n = function(t, n) {
                    var i = t.$options._parentVnode;
                    e(i) && e(i = i.data) && e(i = i.registerRouteInstance) && i(t, n)
                };
                t.mixin({
                    beforeCreate: function() {
                        e(this.$options.router) ? (this._routerRoot = this,
                        this._router = this.$options.router,
                        this._router.init(this),
                        t.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this,
                        n(this, this)
                    },
                    destroyed: function() {
                        n(this)
                    }
                }),
                Object.defineProperty(t.prototype, "$router", {
                    get: function() {
                        return this._routerRoot._router
                    }
                }),
                Object.defineProperty(t.prototype, "$route", {
                    get: function() {
                        return this._routerRoot._route
                    }
                }),
                t.component("RouterView", s),
                t.component("RouterLink", at);
                var i = t.config.optionMergeStrategies;
                i.beforeRouteEnter = i.beforeRouteLeave = i.beforeRouteUpdate = i.created
            }
        }
        var lt = "undefined" !== typeof window;
        function ut(t, e, n, i) {
            var r = e || []
              , a = n || Object.create(null)
              , o = i || Object.create(null);
            t.forEach((function(t) {
                ht(r, a, o, t)
            }
            ));
            for (var s = 0, c = r.length; s < c; s++)
                "*" === r[s] && (r.push(r.splice(s, 1)[0]),
                c--,
                s--);
            return {
                pathList: r,
                pathMap: a,
                nameMap: o
            }
        }
        function ht(t, e, n, i, r, a) {
            var o = i.path
              , s = i.name;
            var c = i.pathToRegexpOptions || {}
              , l = pt(o, r, c.strict);
            "boolean" === typeof i.caseSensitive && (c.sensitive = i.caseSensitive);
            var u = {
                path: l,
                regex: dt(l, c),
                components: i.components || {
                    default: i.component
                },
                instances: {},
                name: s,
                parent: r,
                matchAs: a,
                redirect: i.redirect,
                beforeEnter: i.beforeEnter,
                meta: i.meta || {},
                props: null == i.props ? {} : i.components ? i.props : {
                    default: i.props
                }
            };
            if (i.children && i.children.forEach((function(i) {
                var r = a ? P(a + "/" + i.path) : void 0;
                ht(t, e, n, i, u, r)
            }
            )),
            e[u.path] || (t.push(u.path),
            e[u.path] = u),
            void 0 !== i.alias)
                for (var h = Array.isArray(i.alias) ? i.alias : [i.alias], d = 0; d < h.length; ++d) {
                    var p = h[d];
                    0;
                    var f = {
                        path: p,
                        children: i.children
                    };
                    ht(t, e, n, f, r, u.path || "/")
                }
            s && (n[s] || (n[s] = u))
        }
        function dt(t, e) {
            var n = I(t, [], e);
            return n
        }
        function pt(t, e, n) {
            return n || (t = t.replace(/\/$/, "")),
            "/" === t[0] || null == e ? t : P(e.path + "/" + t)
        }
        function ft(t, e) {
            var n = ut(t)
              , i = n.pathList
              , r = n.pathMap
              , a = n.nameMap;
            function o(t) {
                ut(t, i, r, a)
            }
            function s(t, n, o) {
                var s = tt(t, n, !1, e)
                  , c = s.name;
                if (c) {
                    var l = a[c];
                    if (!l)
                        return u(null, s);
                    var h = l.regex.keys.filter((function(t) {
                        return !t.optional
                    }
                    )).map((function(t) {
                        return t.name
                    }
                    ));
                    if ("object" !== typeof s.params && (s.params = {}),
                    n && "object" === typeof n.params)
                        for (var d in n.params)
                            !(d in s.params) && h.indexOf(d) > -1 && (s.params[d] = n.params[d]);
                    return s.path = Q(l.path, s.params, 'named route "' + c + '"'),
                    u(l, s, o)
                }
                if (s.path) {
                    s.params = {};
                    for (var p = 0; p < i.length; p++) {
                        var f = i[p]
                          , m = r[f];
                        if (mt(m.regex, s.path, s.params))
                            return u(m, s, o)
                    }
                }
                return u(null, s)
            }
            function c(t, n) {
                var i = t.redirect
                  , r = "function" === typeof i ? i(y(t, n, null, e)) : i;
                if ("string" === typeof r && (r = {
                    path: r
                }),
                !r || "object" !== typeof r)
                    return u(null, n);
                var o = r
                  , c = o.name
                  , l = o.path
                  , h = n.query
                  , d = n.hash
                  , p = n.params;
                if (h = o.hasOwnProperty("query") ? o.query : h,
                d = o.hasOwnProperty("hash") ? o.hash : d,
                p = o.hasOwnProperty("params") ? o.params : p,
                c) {
                    a[c];
                    return s({
                        _normalized: !0,
                        name: c,
                        query: h,
                        hash: d,
                        params: p
                    }, void 0, n)
                }
                if (l) {
                    var f = gt(l, t)
                      , m = Q(f, p, 'redirect route with path "' + f + '"');
                    return s({
                        _normalized: !0,
                        path: m,
                        query: h,
                        hash: d
                    }, void 0, n)
                }
                return u(null, n)
            }
            function l(t, e, n) {
                var i = Q(n, e.params, 'aliased route with path "' + n + '"')
                  , r = s({
                    _normalized: !0,
                    path: i
                });
                if (r) {
                    var a = r.matched
                      , o = a[a.length - 1];
                    return e.params = r.params,
                    u(o, e)
                }
                return u(null, e)
            }
            function u(t, n, i) {
                return t && t.redirect ? c(t, i || n) : t && t.matchAs ? l(t, n, t.matchAs) : y(t, n, i, e)
            }
            return {
                match: s,
                addRoutes: o
            }
        }
        function mt(t, e, n) {
            var i = e.match(t);
            if (!i)
                return !1;
            if (!n)
                return !0;
            for (var r = 1, a = i.length; r < a; ++r) {
                var o = t.keys[r - 1]
                  , s = "string" === typeof i[r] ? decodeURIComponent(i[r]) : i[r];
                o && (n[o.name || "pathMatch"] = s)
            }
            return !0
        }
        function gt(t, e) {
            return R(t, e.parent ? e.parent.path : "/", !0)
        }
        var vt = lt && window.performance && window.performance.now ? window.performance : Date;
        function _t() {
            return vt.now().toFixed(3)
        }
        var yt = _t();
        function xt() {
            return yt
        }
        function Mt(t) {
            return yt = t
        }
        var bt = Object.create(null);
        function St() {
            "scrollRestoration"in window.history && (window.history.scrollRestoration = "manual");
            var t = window.location.protocol + "//" + window.location.host
              , e = window.location.href.replace(t, "")
              , n = o({}, window.history.state);
            n.key = xt(),
            window.history.replaceState(n, "", e),
            window.addEventListener("popstate", (function(t) {
                Tt(),
                t.state && t.state.key && Mt(t.state.key)
            }
            ))
        }
        function Et(t, e, n, i) {
            if (t.app) {
                var r = t.options.scrollBehavior;
                r && t.app.$nextTick((function() {
                    var a = wt()
                      , o = r.call(t, e, n, i ? a : null);
                    o && ("function" === typeof o.then ? o.then((function(t) {
                        Ut(t, a)
                    }
                    )).catch((function(t) {
                        0
                    }
                    )) : Ut(o, a))
                }
                ))
            }
        }
        function Tt() {
            var t = xt();
            t && (bt[t] = {
                x: window.pageXOffset,
                y: window.pageYOffset
            })
        }
        function wt() {
            var t = xt();
            if (t)
                return bt[t]
        }
        function At(t, e) {
            var n = document.documentElement
              , i = n.getBoundingClientRect()
              , r = t.getBoundingClientRect();
            return {
                x: r.left - i.left - e.x,
                y: r.top - i.top - e.y
            }
        }
        function Rt(t) {
            return Lt(t.x) || Lt(t.y)
        }
        function Ct(t) {
            return {
                x: Lt(t.x) ? t.x : window.pageXOffset,
                y: Lt(t.y) ? t.y : window.pageYOffset
            }
        }
        function Pt(t) {
            return {
                x: Lt(t.x) ? t.x : 0,
                y: Lt(t.y) ? t.y : 0
            }
        }
        function Lt(t) {
            return "number" === typeof t
        }
        var It = /^#\d/;
        function Ut(t, e) {
            var n = "object" === typeof t;
            if (n && "string" === typeof t.selector) {
                var i = It.test(t.selector) ? document.getElementById(t.selector.slice(1)) : document.querySelector(t.selector);
                if (i) {
                    var r = t.offset && "object" === typeof t.offset ? t.offset : {};
                    r = Pt(r),
                    e = At(i, r)
                } else
                    Rt(t) && (e = Ct(t))
            } else
                n && Rt(t) && (e = Ct(t));
            e && window.scrollTo(e.x, e.y)
        }
        var Dt = lt && function() {
            var t = window.navigator.userAgent;
            return (-1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone")) && (window.history && "function" === typeof window.history.pushState)
        }();
        function Nt(t, e) {
            Tt();
            var n = window.history;
            try {
                if (e) {
                    var i = o({}, n.state);
                    i.key = xt(),
                    n.replaceState(i, "", t)
                } else
                    n.pushState({
                        key: Mt(_t())
                    }, "", t)
            } catch (r) {
                window.location[e ? "replace" : "assign"](t)
            }
        }
        function Ot(t) {
            Nt(t, !0)
        }
        function Ft(t, e, n) {
            var i = function(r) {
                r >= t.length ? n() : t[r] ? e(t[r], (function() {
                    i(r + 1)
                }
                )) : i(r + 1)
            };
            i(0)
        }
        function Bt(t) {
            return function(e, n, i) {
                var a = !1
                  , o = 0
                  , s = null;
                kt(t, (function(t, e, n, c) {
                    if ("function" === typeof t && void 0 === t.cid) {
                        a = !0,
                        o++;
                        var l, u = Gt((function(e) {
                            Ht(e) && (e = e.default),
                            t.resolved = "function" === typeof e ? e : et.extend(e),
                            n.components[c] = e,
                            o--,
                            o <= 0 && i()
                        }
                        )), h = Gt((function(t) {
                            var e = "Failed to resolve async component " + c + ": " + t;
                            s || (s = r(t) ? t : new Error(e),
                            i(s))
                        }
                        ));
                        try {
                            l = t(u, h)
                        } catch (p) {
                            h(p)
                        }
                        if (l)
                            if ("function" === typeof l.then)
                                l.then(u, h);
                            else {
                                var d = l.component;
                                d && "function" === typeof d.then && d.then(u, h)
                            }
                    }
                }
                )),
                a || i()
            }
        }
        function kt(t, e) {
            return zt(t.map((function(t) {
                return Object.keys(t.components).map((function(n) {
                    return e(t.components[n], t.instances[n], t, n)
                }
                ))
            }
            )))
        }
        function zt(t) {
            return Array.prototype.concat.apply([], t)
        }
        var Vt = "function" === typeof Symbol && "symbol" === typeof Symbol.toStringTag;
        function Ht(t) {
            return t.__esModule || Vt && "Module" === t[Symbol.toStringTag]
        }
        function Gt(t) {
            var e = !1;
            return function() {
                var n = []
                  , i = arguments.length;
                while (i--)
                    n[i] = arguments[i];
                if (!e)
                    return e = !0,
                    t.apply(this, n)
            }
        }
        var jt = function(t) {
            function e(e) {
                t.call(this),
                this.name = this._name = "NavigationDuplicated",
                this.message = 'Navigating to current location ("' + e.fullPath + '") is not allowed',
                Object.defineProperty(this, "stack", {
                    value: (new t).stack,
                    writable: !0,
                    configurable: !0
                })
            }
            return t && (e.__proto__ = t),
            e.prototype = Object.create(t && t.prototype),
            e.prototype.constructor = e,
            e
        }(Error);
        jt._name = "NavigationDuplicated";
        var Wt = function(t, e) {
            this.router = t,
            this.base = Xt(e),
            this.current = M,
            this.pending = null,
            this.ready = !1,
            this.readyCbs = [],
            this.readyErrorCbs = [],
            this.errorCbs = []
        };
        function Xt(t) {
            if (!t)
                if (lt) {
                    var e = document.querySelector("base");
                    t = e && e.getAttribute("href") || "/",
                    t = t.replace(/^https?:\/\/[^\/]+/, "")
                } else
                    t = "/";
            return "/" !== t.charAt(0) && (t = "/" + t),
            t.replace(/\/$/, "")
        }
        function qt(t, e) {
            var n, i = Math.max(t.length, e.length);
            for (n = 0; n < i; n++)
                if (t[n] !== e[n])
                    break;
            return {
                updated: e.slice(0, n),
                activated: e.slice(n),
                deactivated: t.slice(n)
            }
        }
        function $t(t, e, n, i) {
            var r = kt(t, (function(t, i, r, a) {
                var o = Yt(t, e);
                if (o)
                    return Array.isArray(o) ? o.map((function(t) {
                        return n(t, i, r, a)
                    }
                    )) : n(o, i, r, a)
            }
            ));
            return zt(i ? r.reverse() : r)
        }
        function Yt(t, e) {
            return "function" !== typeof t && (t = et.extend(t)),
            t.options[e]
        }
        function Kt(t) {
            return $t(t, "beforeRouteLeave", Jt, !0)
        }
        function Zt(t) {
            return $t(t, "beforeRouteUpdate", Jt)
        }
        function Jt(t, e) {
            if (e)
                return function() {
                    return t.apply(e, arguments)
                }
        }
        function Qt(t, e, n) {
            return $t(t, "beforeRouteEnter", (function(t, i, r, a) {
                return te(t, r, a, e, n)
            }
            ))
        }
        function te(t, e, n, i, r) {
            return function(a, o, s) {
                return t(a, o, (function(t) {
                    "function" === typeof t && i.push((function() {
                        ee(t, e.instances, n, r)
                    }
                    )),
                    s(t)
                }
                ))
            }
        }
        function ee(t, e, n, i) {
            e[n] && !e[n]._isBeingDestroyed ? t(e[n]) : i() && setTimeout((function() {
                ee(t, e, n, i)
            }
            ), 16)
        }
        Wt.prototype.listen = function(t) {
            this.cb = t
        }
        ,
        Wt.prototype.onReady = function(t, e) {
            this.ready ? t() : (this.readyCbs.push(t),
            e && this.readyErrorCbs.push(e))
        }
        ,
        Wt.prototype.onError = function(t) {
            this.errorCbs.push(t)
        }
        ,
        Wt.prototype.transitionTo = function(t, e, n) {
            var i = this
              , r = this.router.match(t, this.current);
            this.confirmTransition(r, (function() {
                i.updateRoute(r),
                e && e(r),
                i.ensureURL(),
                i.ready || (i.ready = !0,
                i.readyCbs.forEach((function(t) {
                    t(r)
                }
                )))
            }
            ), (function(t) {
                n && n(t),
                t && !i.ready && (i.ready = !0,
                i.readyErrorCbs.forEach((function(e) {
                    e(t)
                }
                )))
            }
            ))
        }
        ,
        Wt.prototype.confirmTransition = function(t, e, n) {
            var o = this
              , s = this.current
              , c = function(t) {
                !a(jt, t) && r(t) && (o.errorCbs.length ? o.errorCbs.forEach((function(e) {
                    e(t)
                }
                )) : (i(!1, "uncaught error during route navigation:"),
                console.error(t))),
                n && n(t)
            };
            if (E(t, s) && t.matched.length === s.matched.length)
                return this.ensureURL(),
                c(new jt(t));
            var l = qt(this.current.matched, t.matched)
              , u = l.updated
              , h = l.deactivated
              , d = l.activated
              , p = [].concat(Kt(h), this.router.beforeHooks, Zt(u), d.map((function(t) {
                return t.beforeEnter
            }
            )), Bt(d));
            this.pending = t;
            var f = function(e, n) {
                if (o.pending !== t)
                    return c();
                try {
                    e(t, s, (function(t) {
                        !1 === t || r(t) ? (o.ensureURL(!0),
                        c(t)) : "string" === typeof t || "object" === typeof t && ("string" === typeof t.path || "string" === typeof t.name) ? (c(),
                        "object" === typeof t && t.replace ? o.replace(t) : o.push(t)) : n(t)
                    }
                    ))
                } catch (i) {
                    c(i)
                }
            };
            Ft(p, f, (function() {
                var n = []
                  , i = function() {
                    return o.current === t
                }
                  , r = Qt(d, n, i)
                  , a = r.concat(o.router.resolveHooks);
                Ft(a, f, (function() {
                    if (o.pending !== t)
                        return c();
                    o.pending = null,
                    e(t),
                    o.router.app && o.router.app.$nextTick((function() {
                        n.forEach((function(t) {
                            t()
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            ))
        }
        ,
        Wt.prototype.updateRoute = function(t) {
            var e = this.current;
            this.current = t,
            this.cb && this.cb(t),
            this.router.afterHooks.forEach((function(n) {
                n && n(t, e)
            }
            ))
        }
        ;
        var ne = function(t) {
            function e(e, n) {
                var i = this;
                t.call(this, e, n);
                var r = e.options.scrollBehavior
                  , a = Dt && r;
                a && St();
                var o = ie(this.base);
                window.addEventListener("popstate", (function(t) {
                    var n = i.current
                      , r = ie(i.base);
                    i.current === M && r === o || i.transitionTo(r, (function(t) {
                        a && Et(e, t, n, !0)
                    }
                    ))
                }
                ))
            }
            return t && (e.__proto__ = t),
            e.prototype = Object.create(t && t.prototype),
            e.prototype.constructor = e,
            e.prototype.go = function(t) {
                window.history.go(t)
            }
            ,
            e.prototype.push = function(t, e, n) {
                var i = this
                  , r = this
                  , a = r.current;
                this.transitionTo(t, (function(t) {
                    Nt(P(i.base + t.fullPath)),
                    Et(i.router, t, a, !1),
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.replace = function(t, e, n) {
                var i = this
                  , r = this
                  , a = r.current;
                this.transitionTo(t, (function(t) {
                    Ot(P(i.base + t.fullPath)),
                    Et(i.router, t, a, !1),
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.ensureURL = function(t) {
                if (ie(this.base) !== this.current.fullPath) {
                    var e = P(this.base + this.current.fullPath);
                    t ? Nt(e) : Ot(e)
                }
            }
            ,
            e.prototype.getCurrentLocation = function() {
                return ie(this.base)
            }
            ,
            e
        }(Wt);
        function ie(t) {
            var e = decodeURI(window.location.pathname);
            return t && 0 === e.toLowerCase().indexOf(t.toLowerCase()) && (e = e.slice(t.length)),
            (e || "/") + window.location.search + window.location.hash
        }
        var re = function(t) {
            function e(e, n, i) {
                t.call(this, e, n),
                i && ae(this.base) || oe()
            }
            return t && (e.__proto__ = t),
            e.prototype = Object.create(t && t.prototype),
            e.prototype.constructor = e,
            e.prototype.setupListeners = function() {
                var t = this
                  , e = this.router
                  , n = e.options.scrollBehavior
                  , i = Dt && n;
                i && St(),
                window.addEventListener(Dt ? "popstate" : "hashchange", (function() {
                    var e = t.current;
                    oe() && t.transitionTo(se(), (function(n) {
                        i && Et(t.router, n, e, !0),
                        Dt || ue(n.fullPath)
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.push = function(t, e, n) {
                var i = this
                  , r = this
                  , a = r.current;
                this.transitionTo(t, (function(t) {
                    le(t.fullPath),
                    Et(i.router, t, a, !1),
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.replace = function(t, e, n) {
                var i = this
                  , r = this
                  , a = r.current;
                this.transitionTo(t, (function(t) {
                    ue(t.fullPath),
                    Et(i.router, t, a, !1),
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.go = function(t) {
                window.history.go(t)
            }
            ,
            e.prototype.ensureURL = function(t) {
                var e = this.current.fullPath;
                se() !== e && (t ? le(e) : ue(e))
            }
            ,
            e.prototype.getCurrentLocation = function() {
                return se()
            }
            ,
            e
        }(Wt);
        function ae(t) {
            var e = ie(t);
            if (!/^\/#/.test(e))
                return window.location.replace(P(t + "/#" + e)),
                !0
        }
        function oe() {
            var t = se();
            return "/" === t.charAt(0) || (ue("/" + t),
            !1)
        }
        function se() {
            var t = window.location.href
              , e = t.indexOf("#");
            if (e < 0)
                return "";
            t = t.slice(e + 1);
            var n = t.indexOf("?");
            if (n < 0) {
                var i = t.indexOf("#");
                t = i > -1 ? decodeURI(t.slice(0, i)) + t.slice(i) : decodeURI(t)
            } else
                t = decodeURI(t.slice(0, n)) + t.slice(n);
            return t
        }
        function ce(t) {
            var e = window.location.href
              , n = e.indexOf("#")
              , i = n >= 0 ? e.slice(0, n) : e;
            return i + "#" + t
        }
        function le(t) {
            Dt ? Nt(ce(t)) : window.location.hash = t
        }
        function ue(t) {
            Dt ? Ot(ce(t)) : window.location.replace(ce(t))
        }
        var he = function(t) {
            function e(e, n) {
                t.call(this, e, n),
                this.stack = [],
                this.index = -1
            }
            return t && (e.__proto__ = t),
            e.prototype = Object.create(t && t.prototype),
            e.prototype.constructor = e,
            e.prototype.push = function(t, e, n) {
                var i = this;
                this.transitionTo(t, (function(t) {
                    i.stack = i.stack.slice(0, i.index + 1).concat(t),
                    i.index++,
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.replace = function(t, e, n) {
                var i = this;
                this.transitionTo(t, (function(t) {
                    i.stack = i.stack.slice(0, i.index).concat(t),
                    e && e(t)
                }
                ), n)
            }
            ,
            e.prototype.go = function(t) {
                var e = this
                  , n = this.index + t;
                if (!(n < 0 || n >= this.stack.length)) {
                    var i = this.stack[n];
                    this.confirmTransition(i, (function() {
                        e.index = n,
                        e.updateRoute(i)
                    }
                    ), (function(t) {
                        a(jt, t) && (e.index = n)
                    }
                    ))
                }
            }
            ,
            e.prototype.getCurrentLocation = function() {
                var t = this.stack[this.stack.length - 1];
                return t ? t.fullPath : "/"
            }
            ,
            e.prototype.ensureURL = function() {}
            ,
            e
        }(Wt)
          , de = function(t) {
            void 0 === t && (t = {}),
            this.app = null,
            this.apps = [],
            this.options = t,
            this.beforeHooks = [],
            this.resolveHooks = [],
            this.afterHooks = [],
            this.matcher = ft(t.routes || [], this);
            var e = t.mode || "hash";
            switch (this.fallback = "history" === e && !Dt && !1 !== t.fallback,
            this.fallback && (e = "hash"),
            lt || (e = "abstract"),
            this.mode = e,
            e) {
            case "history":
                this.history = new ne(this,t.base);
                break;
            case "hash":
                this.history = new re(this,t.base,this.fallback);
                break;
            case "abstract":
                this.history = new he(this,t.base);
                break;
            default:
                0
            }
        }
          , pe = {
            currentRoute: {
                configurable: !0
            }
        };
        function fe(t, e) {
            return t.push(e),
            function() {
                var n = t.indexOf(e);
                n > -1 && t.splice(n, 1)
            }
        }
        function me(t, e, n) {
            var i = "hash" === n ? "#" + e : e;
            return t ? P(t + "/" + i) : i
        }
        de.prototype.match = function(t, e, n) {
            return this.matcher.match(t, e, n)
        }
        ,
        pe.currentRoute.get = function() {
            return this.history && this.history.current
        }
        ,
        de.prototype.init = function(t) {
            var e = this;
            if (this.apps.push(t),
            t.$once("hook:destroyed", (function() {
                var n = e.apps.indexOf(t);
                n > -1 && e.apps.splice(n, 1),
                e.app === t && (e.app = e.apps[0] || null)
            }
            )),
            !this.app) {
                this.app = t;
                var n = this.history;
                if (n instanceof ne)
                    n.transitionTo(n.getCurrentLocation());
                else if (n instanceof re) {
                    var i = function() {
                        n.setupListeners()
                    };
                    n.transitionTo(n.getCurrentLocation(), i, i)
                }
                n.listen((function(t) {
                    e.apps.forEach((function(e) {
                        e._route = t
                    }
                    ))
                }
                ))
            }
        }
        ,
        de.prototype.beforeEach = function(t) {
            return fe(this.beforeHooks, t)
        }
        ,
        de.prototype.beforeResolve = function(t) {
            return fe(this.resolveHooks, t)
        }
        ,
        de.prototype.afterEach = function(t) {
            return fe(this.afterHooks, t)
        }
        ,
        de.prototype.onReady = function(t, e) {
            this.history.onReady(t, e)
        }
        ,
        de.prototype.onError = function(t) {
            this.history.onError(t)
        }
        ,
        de.prototype.push = function(t, e, n) {
            var i = this;
            if (!e && !n && "undefined" !== typeof Promise)
                return new Promise((function(e, n) {
                    i.history.push(t, e, n)
                }
                ));
            this.history.push(t, e, n)
        }
        ,
        de.prototype.replace = function(t, e, n) {
            var i = this;
            if (!e && !n && "undefined" !== typeof Promise)
                return new Promise((function(e, n) {
                    i.history.replace(t, e, n)
                }
                ));
            this.history.replace(t, e, n)
        }
        ,
        de.prototype.go = function(t) {
            this.history.go(t)
        }
        ,
        de.prototype.back = function() {
            this.go(-1)
        }
        ,
        de.prototype.forward = function() {
            this.go(1)
        }
        ,
        de.prototype.getMatchedComponents = function(t) {
            var e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute;
            return e ? [].concat.apply([], e.matched.map((function(t) {
                return Object.keys(t.components).map((function(e) {
                    return t.components[e]
                }
                ))
            }
            ))) : []
        }
        ,
        de.prototype.resolve = function(t, e, n) {
            e = e || this.history.current;
            var i = tt(t, e, n, this)
              , r = this.match(i, e)
              , a = r.redirectedFrom || r.fullPath
              , o = this.history.base
              , s = me(o, a, this.mode);
            return {
                location: i,
                route: r,
                href: s,
                normalizedTo: i,
                resolved: r
            }
        }
        ,
        de.prototype.addRoutes = function(t) {
            this.matcher.addRoutes(t),
            this.history.current !== M && this.history.transitionTo(this.history.getCurrentLocation())
        }
        ,
        Object.defineProperties(de.prototype, pe),
        de.install = ct,
        de.version = "3.2.0",
        lt && window.Vue && window.Vue.use(de),
        e.A = de
    },
    2856: function(t, e, n) {
        n.d(e, {
            Ay: function() {
                return Ji
            }
        });
        n(4114),
        n(3375),
        n(9225),
        n(3972),
        n(9209),
        n(5714),
        n(7561),
        n(6197),
        n(9848);
        var i = Object.freeze({})
          , r = Array.isArray;
        function a(t) {
            return void 0 === t || null === t
        }
        function o(t) {
            return void 0 !== t && null !== t
        }
        function s(t) {
            return !0 === t
        }
        function c(t) {
            return !1 === t
        }
        function l(t) {
            return "string" === typeof t || "number" === typeof t || "symbol" === typeof t || "boolean" === typeof t
        }
        function u(t) {
            return "function" === typeof t
        }
        function h(t) {
            return null !== t && "object" === typeof t
        }
        var d = Object.prototype.toString;
        function p(t) {
            return "[object Object]" === d.call(t)
        }
        function f(t) {
            return "[object RegExp]" === d.call(t)
        }
        function m(t) {
            var e = parseFloat(String(t));
            return e >= 0 && Math.floor(e) === e && isFinite(t)
        }
        function g(t) {
            return o(t) && "function" === typeof t.then && "function" === typeof t.catch
        }
        function v(t) {
            return null == t ? "" : Array.isArray(t) || p(t) && t.toString === d ? JSON.stringify(t, _, 2) : String(t)
        }
        function _(t, e) {
            return e && e.__v_isRef ? e.value : e
        }
        function y(t) {
            var e = parseFloat(t);
            return isNaN(e) ? t : e
        }
        function x(t, e) {
            for (var n = Object.create(null), i = t.split(","), r = 0; r < i.length; r++)
                n[i[r]] = !0;
            return e ? function(t) {
                return n[t.toLowerCase()]
            }
            : function(t) {
                return n[t]
            }
        }
        x("slot,component", !0);
        var M = x("key,ref,slot,slot-scope,is");
        function b(t, e) {
            var n = t.length;
            if (n) {
                if (e === t[n - 1])
                    return void (t.length = n - 1);
                var i = t.indexOf(e);
                if (i > -1)
                    return t.splice(i, 1)
            }
        }
        var S = Object.prototype.hasOwnProperty;
        function E(t, e) {
            return S.call(t, e)
        }
        function T(t) {
            var e = Object.create(null);
            return function(n) {
                var i = e[n];
                return i || (e[n] = t(n))
            }
        }
        var w = /-(\w)/g
          , A = T((function(t) {
            return t.replace(w, (function(t, e) {
                return e ? e.toUpperCase() : ""
            }
            ))
        }
        ))
          , R = T((function(t) {
            return t.charAt(0).toUpperCase() + t.slice(1)
        }
        ))
          , C = /\B([A-Z])/g
          , P = T((function(t) {
            return t.replace(C, "-$1").toLowerCase()
        }
        ));
        function L(t, e) {
            function n(n) {
                var i = arguments.length;
                return i ? i > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e)
            }
            return n._length = t.length,
            n
        }
        function I(t, e) {
            return t.bind(e)
        }
        var U = Function.prototype.bind ? I : L;
        function D(t, e) {
            e = e || 0;
            var n = t.length - e
              , i = new Array(n);
            while (n--)
                i[n] = t[n + e];
            return i
        }
        function N(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }
        function O(t) {
            for (var e = {}, n = 0; n < t.length; n++)
                t[n] && N(e, t[n]);
            return e
        }
        function F(t, e, n) {}
        var B = function(t, e, n) {
            return !1
        }
          , k = function(t) {
            return t
        };
        function z(t, e) {
            if (t === e)
                return !0;
            var n = h(t)
              , i = h(e);
            if (!n || !i)
                return !n && !i && String(t) === String(e);
            try {
                var r = Array.isArray(t)
                  , a = Array.isArray(e);
                if (r && a)
                    return t.length === e.length && t.every((function(t, n) {
                        return z(t, e[n])
                    }
                    ));
                if (t instanceof Date && e instanceof Date)
                    return t.getTime() === e.getTime();
                if (r || a)
                    return !1;
                var o = Object.keys(t)
                  , s = Object.keys(e);
                return o.length === s.length && o.every((function(n) {
                    return z(t[n], e[n])
                }
                ))
            } catch (c) {
                return !1
            }
        }
        function V(t, e) {
            for (var n = 0; n < t.length; n++)
                if (z(t[n], e))
                    return n;
            return -1
        }
        function H(t) {
            var e = !1;
            return function() {
                e || (e = !0,
                t.apply(this, arguments))
            }
        }
        function G(t, e) {
            return t === e ? 0 === t && 1 / t !== 1 / e : t === t || e === e
        }
        var j = "data-server-rendered"
          , W = ["component", "directive", "filter"]
          , X = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch", "renderTracked", "renderTriggered"]
          , q = {
            optionMergeStrategies: Object.create(null),
            silent: !1,
            productionTip: !1,
            devtools: !1,
            performance: !1,
            errorHandler: null,
            warnHandler: null,
            ignoredElements: [],
            keyCodes: Object.create(null),
            isReservedTag: B,
            isReservedAttr: B,
            isUnknownElement: B,
            getTagNamespace: F,
            parsePlatformTagName: k,
            mustUseProp: B,
            async: !0,
            _lifecycleHooks: X
        }
          , $ = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        function Y(t) {
            var e = (t + "").charCodeAt(0);
            return 36 === e || 95 === e
        }
        function K(t, e, n, i) {
            Object.defineProperty(t, e, {
                value: n,
                enumerable: !!i,
                writable: !0,
                configurable: !0
            })
        }
        var Z = new RegExp("[^".concat($.source, ".$_\\d]"));
        function J(t) {
            if (!Z.test(t)) {
                var e = t.split(".");
                return function(t) {
                    for (var n = 0; n < e.length; n++) {
                        if (!t)
                            return;
                        t = t[e[n]]
                    }
                    return t
                }
            }
        }
        var Q = "__proto__"in {}
          , tt = "undefined" !== typeof window
          , et = tt && window.navigator.userAgent.toLowerCase()
          , nt = et && /msie|trident/.test(et)
          , it = et && et.indexOf("msie 9.0") > 0
          , rt = et && et.indexOf("edge/") > 0;
        et && et.indexOf("android");
        var at = et && /iphone|ipad|ipod|ios/.test(et);
        et && /chrome\/\d+/.test(et),
        et && /phantomjs/.test(et);
        var ot, st = et && et.match(/firefox\/(\d+)/), ct = {}.watch, lt = !1;
        if (tt)
            try {
                var ut = {};
                Object.defineProperty(ut, "passive", {
                    get: function() {
                        lt = !0
                    }
                }),
                window.addEventListener("test-passive", null, ut)
            } catch (Qo) {}
        var ht = function() {
            return void 0 === ot && (ot = !tt && "undefined" !== typeof n.g && (n.g["process"] && "server" === n.g["process"].env.VUE_ENV)),
            ot
        }
          , dt = tt && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        function pt(t) {
            return "function" === typeof t && /native code/.test(t.toString())
        }
        var ft, mt = "undefined" !== typeof Symbol && pt(Symbol) && "undefined" !== typeof Reflect && pt(Reflect.ownKeys);
        ft = "undefined" !== typeof Set && pt(Set) ? Set : function() {
            function t() {
                this.set = Object.create(null)
            }
            return t.prototype.has = function(t) {
                return !0 === this.set[t]
            }
            ,
            t.prototype.add = function(t) {
                this.set[t] = !0
            }
            ,
            t.prototype.clear = function() {
                this.set = Object.create(null)
            }
            ,
            t
        }();
        var gt = null;
        function vt(t) {
            void 0 === t && (t = null),
            t || gt && gt._scope.off(),
            gt = t,
            t && t._scope.on()
        }
        var _t = function() {
            function t(t, e, n, i, r, a, o, s) {
                this.tag = t,
                this.data = e,
                this.children = n,
                this.text = i,
                this.elm = r,
                this.ns = void 0,
                this.context = a,
                this.fnContext = void 0,
                this.fnOptions = void 0,
                this.fnScopeId = void 0,
                this.key = e && e.key,
                this.componentOptions = o,
                this.componentInstance = void 0,
                this.parent = void 0,
                this.raw = !1,
                this.isStatic = !1,
                this.isRootInsert = !0,
                this.isComment = !1,
                this.isCloned = !1,
                this.isOnce = !1,
                this.asyncFactory = s,
                this.asyncMeta = void 0,
                this.isAsyncPlaceholder = !1
            }
            return Object.defineProperty(t.prototype, "child", {
                get: function() {
                    return this.componentInstance
                },
                enumerable: !1,
                configurable: !0
            }),
            t
        }()
          , yt = function(t) {
            void 0 === t && (t = "");
            var e = new _t;
            return e.text = t,
            e.isComment = !0,
            e
        };
        function xt(t) {
            return new _t(void 0,void 0,void 0,String(t))
        }
        function Mt(t) {
            var e = new _t(t.tag,t.data,t.children && t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);
            return e.ns = t.ns,
            e.isStatic = t.isStatic,
            e.key = t.key,
            e.isComment = t.isComment,
            e.fnContext = t.fnContext,
            e.fnOptions = t.fnOptions,
            e.fnScopeId = t.fnScopeId,
            e.asyncMeta = t.asyncMeta,
            e.isCloned = !0,
            e
        }
        "function" === typeof SuppressedError && SuppressedError;
        var bt = 0
          , St = []
          , Et = function() {
            for (var t = 0; t < St.length; t++) {
                var e = St[t];
                e.subs = e.subs.filter((function(t) {
                    return t
                }
                )),
                e._pending = !1
            }
            St.length = 0
        }
          , Tt = function() {
            function t() {
                this._pending = !1,
                this.id = bt++,
                this.subs = []
            }
            return t.prototype.addSub = function(t) {
                this.subs.push(t)
            }
            ,
            t.prototype.removeSub = function(t) {
                this.subs[this.subs.indexOf(t)] = null,
                this._pending || (this._pending = !0,
                St.push(this))
            }
            ,
            t.prototype.depend = function(e) {
                t.target && t.target.addDep(this)
            }
            ,
            t.prototype.notify = function(t) {
                var e = this.subs.filter((function(t) {
                    return t
                }
                ));
                for (var n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    0,
                    r.update()
                }
            }
            ,
            t
        }();
        Tt.target = null;
        var wt = [];
        function At(t) {
            wt.push(t),
            Tt.target = t
        }
        function Rt() {
            wt.pop(),
            Tt.target = wt[wt.length - 1]
        }
        var Ct = Array.prototype
          , Pt = Object.create(Ct)
          , Lt = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
        Lt.forEach((function(t) {
            var e = Ct[t];
            K(Pt, t, (function() {
                for (var n = [], i = 0; i < arguments.length; i++)
                    n[i] = arguments[i];
                var r, a = e.apply(this, n), o = this.__ob__;
                switch (t) {
                case "push":
                case "unshift":
                    r = n;
                    break;
                case "splice":
                    r = n.slice(2);
                    break
                }
                return r && o.observeArray(r),
                o.dep.notify(),
                a
            }
            ))
        }
        ));
        var It = Object.getOwnPropertyNames(Pt)
          , Ut = {}
          , Dt = !0;
        function Nt(t) {
            Dt = t
        }
        var Ot = {
            notify: F,
            depend: F,
            addSub: F,
            removeSub: F
        }
          , Ft = function() {
            function t(t, e, n) {
                if (void 0 === e && (e = !1),
                void 0 === n && (n = !1),
                this.value = t,
                this.shallow = e,
                this.mock = n,
                this.dep = n ? Ot : new Tt,
                this.vmCount = 0,
                K(t, "__ob__", this),
                r(t)) {
                    if (!n)
                        if (Q)
                            t.__proto__ = Pt;
                        else
                            for (var i = 0, a = It.length; i < a; i++) {
                                var o = It[i];
                                K(t, o, Pt[o])
                            }
                    e || this.observeArray(t)
                } else {
                    var s = Object.keys(t);
                    for (i = 0; i < s.length; i++) {
                        o = s[i];
                        kt(t, o, Ut, void 0, e, n)
                    }
                }
            }
            return t.prototype.observeArray = function(t) {
                for (var e = 0, n = t.length; e < n; e++)
                    Bt(t[e], !1, this.mock)
            }
            ,
            t
        }();
        function Bt(t, e, n) {
            return t && E(t, "__ob__") && t.__ob__ instanceof Ft ? t.__ob__ : !Dt || !n && ht() || !r(t) && !p(t) || !Object.isExtensible(t) || t.__v_skip || Xt(t) || t instanceof _t ? void 0 : new Ft(t,e,n)
        }
        function kt(t, e, n, i, a, o, s) {
            void 0 === s && (s = !1);
            var c = new Tt
              , l = Object.getOwnPropertyDescriptor(t, e);
            if (!l || !1 !== l.configurable) {
                var u = l && l.get
                  , h = l && l.set;
                u && !h || n !== Ut && 2 !== arguments.length || (n = t[e]);
                var d = a ? n && n.__ob__ : Bt(n, !1, o);
                return Object.defineProperty(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        var e = u ? u.call(t) : n;
                        return Tt.target && (c.depend(),
                        d && (d.dep.depend(),
                        r(e) && Ht(e))),
                        Xt(e) && !a ? e.value : e
                    },
                    set: function(e) {
                        var i = u ? u.call(t) : n;
                        if (G(i, e)) {
                            if (h)
                                h.call(t, e);
                            else {
                                if (u)
                                    return;
                                if (!a && Xt(i) && !Xt(e))
                                    return void (i.value = e);
                                n = e
                            }
                            d = a ? e && e.__ob__ : Bt(e, !1, o),
                            c.notify()
                        }
                    }
                }),
                c
            }
        }
        function zt(t, e, n) {
            if (!Wt(t)) {
                var i = t.__ob__;
                return r(t) && m(e) ? (t.length = Math.max(t.length, e),
                t.splice(e, 1, n),
                i && !i.shallow && i.mock && Bt(n, !1, !0),
                n) : e in t && !(e in Object.prototype) ? (t[e] = n,
                n) : t._isVue || i && i.vmCount ? n : i ? (kt(i.value, e, n, void 0, i.shallow, i.mock),
                i.dep.notify(),
                n) : (t[e] = n,
                n)
            }
        }
        function Vt(t, e) {
            if (r(t) && m(e))
                t.splice(e, 1);
            else {
                var n = t.__ob__;
                t._isVue || n && n.vmCount || Wt(t) || E(t, e) && (delete t[e],
                n && n.dep.notify())
            }
        }
        function Ht(t) {
            for (var e = void 0, n = 0, i = t.length; n < i; n++)
                e = t[n],
                e && e.__ob__ && e.__ob__.dep.depend(),
                r(e) && Ht(e)
        }
        function Gt(t) {
            return jt(t, !0),
            K(t, "__v_isShallow", !0),
            t
        }
        function jt(t, e) {
            if (!Wt(t)) {
                Bt(t, e, ht());
                0
            }
        }
        function Wt(t) {
            return !(!t || !t.__v_isReadonly)
        }
        function Xt(t) {
            return !(!t || !0 !== t.__v_isRef)
        }
        function qt(t, e, n) {
            Object.defineProperty(t, n, {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    var t = e[n];
                    if (Xt(t))
                        return t.value;
                    var i = t && t.__ob__;
                    return i && i.dep.depend(),
                    t
                },
                set: function(t) {
                    var i = e[n];
                    Xt(i) && !Xt(t) ? i.value = t : e[n] = t
                }
            })
        }
        var $t = "watcher";
        "".concat($t, " callback"),
        "".concat($t, " getter"),
        "".concat($t, " cleanup");
        var Yt;
        var Kt = function() {
            function t(t) {
                void 0 === t && (t = !1),
                this.detached = t,
                this.active = !0,
                this.effects = [],
                this.cleanups = [],
                this.parent = Yt,
                !t && Yt && (this.index = (Yt.scopes || (Yt.scopes = [])).push(this) - 1)
            }
            return t.prototype.run = function(t) {
                if (this.active) {
                    var e = Yt;
                    try {
                        return Yt = this,
                        t()
                    } finally {
                        Yt = e
                    }
                } else
                    0
            }
            ,
            t.prototype.on = function() {
                Yt = this
            }
            ,
            t.prototype.off = function() {
                Yt = this.parent
            }
            ,
            t.prototype.stop = function(t) {
                if (this.active) {
                    var e = void 0
                      , n = void 0;
                    for (e = 0,
                    n = this.effects.length; e < n; e++)
                        this.effects[e].teardown();
                    for (e = 0,
                    n = this.cleanups.length; e < n; e++)
                        this.cleanups[e]();
                    if (this.scopes)
                        for (e = 0,
                        n = this.scopes.length; e < n; e++)
                            this.scopes[e].stop(!0);
                    if (!this.detached && this.parent && !t) {
                        var i = this.parent.scopes.pop();
                        i && i !== this && (this.parent.scopes[this.index] = i,
                        i.index = this.index)
                    }
                    this.parent = void 0,
                    this.active = !1
                }
            }
            ,
            t
        }();
        function Zt(t, e) {
            void 0 === e && (e = Yt),
            e && e.active && e.effects.push(t)
        }
        function Jt() {
            return Yt
        }
        function Qt(t) {
            var e = t._provided
              , n = t.$parent && t.$parent._provided;
            return n === e ? t._provided = Object.create(n) : e
        }
        var te = T((function(t) {
            var e = "&" === t.charAt(0);
            t = e ? t.slice(1) : t;
            var n = "~" === t.charAt(0);
            t = n ? t.slice(1) : t;
            var i = "!" === t.charAt(0);
            return t = i ? t.slice(1) : t,
            {
                name: t,
                once: n,
                capture: i,
                passive: e
            }
        }
        ));
        function ee(t, e) {
            function n() {
                var t = n.fns;
                if (!r(t))
                    return Ze(t, null, arguments, e, "v-on handler");
                for (var i = t.slice(), a = 0; a < i.length; a++)
                    Ze(i[a], null, arguments, e, "v-on handler")
            }
            return n.fns = t,
            n
        }
        function ne(t, e, n, i, r, o) {
            var c, l, u, h;
            for (c in t)
                l = t[c],
                u = e[c],
                h = te(c),
                a(l) || (a(u) ? (a(l.fns) && (l = t[c] = ee(l, o)),
                s(h.once) && (l = t[c] = r(h.name, l, h.capture)),
                n(h.name, l, h.capture, h.passive, h.params)) : l !== u && (u.fns = l,
                t[c] = u));
            for (c in e)
                a(t[c]) && (h = te(c),
                i(h.name, e[c], h.capture))
        }
        function ie(t, e, n) {
            var i;
            t instanceof _t && (t = t.data.hook || (t.data.hook = {}));
            var r = t[e];
            function c() {
                n.apply(this, arguments),
                b(i.fns, c)
            }
            a(r) ? i = ee([c]) : o(r.fns) && s(r.merged) ? (i = r,
            i.fns.push(c)) : i = ee([r, c]),
            i.merged = !0,
            t[e] = i
        }
        function re(t, e, n) {
            var i = e.options.props;
            if (!a(i)) {
                var r = {}
                  , s = t.attrs
                  , c = t.props;
                if (o(s) || o(c))
                    for (var l in i) {
                        var u = P(l);
                        ae(r, c, l, u, !0) || ae(r, s, l, u, !1)
                    }
                return r
            }
        }
        function ae(t, e, n, i, r) {
            if (o(e)) {
                if (E(e, n))
                    return t[n] = e[n],
                    r || delete e[n],
                    !0;
                if (E(e, i))
                    return t[n] = e[i],
                    r || delete e[i],
                    !0
            }
            return !1
        }
        function oe(t) {
            for (var e = 0; e < t.length; e++)
                if (r(t[e]))
                    return Array.prototype.concat.apply([], t);
            return t
        }
        function se(t) {
            return l(t) ? [xt(t)] : r(t) ? le(t) : void 0
        }
        function ce(t) {
            return o(t) && o(t.text) && c(t.isComment)
        }
        function le(t, e) {
            var n, i, c, u, h = [];
            for (n = 0; n < t.length; n++)
                i = t[n],
                a(i) || "boolean" === typeof i || (c = h.length - 1,
                u = h[c],
                r(i) ? i.length > 0 && (i = le(i, "".concat(e || "", "_").concat(n)),
                ce(i[0]) && ce(u) && (h[c] = xt(u.text + i[0].text),
                i.shift()),
                h.push.apply(h, i)) : l(i) ? ce(u) ? h[c] = xt(u.text + i) : "" !== i && h.push(xt(i)) : ce(i) && ce(u) ? h[c] = xt(u.text + i.text) : (s(t._isVList) && o(i.tag) && a(i.key) && o(e) && (i.key = "__vlist".concat(e, "_").concat(n, "__")),
                h.push(i)));
            return h
        }
        function ue(t, e) {
            var n, i, a, s, c = null;
            if (r(t) || "string" === typeof t)
                for (c = new Array(t.length),
                n = 0,
                i = t.length; n < i; n++)
                    c[n] = e(t[n], n);
            else if ("number" === typeof t)
                for (c = new Array(t),
                n = 0; n < t; n++)
                    c[n] = e(n + 1, n);
            else if (h(t))
                if (mt && t[Symbol.iterator]) {
                    c = [];
                    var l = t[Symbol.iterator]()
                      , u = l.next();
                    while (!u.done)
                        c.push(e(u.value, c.length)),
                        u = l.next()
                } else
                    for (a = Object.keys(t),
                    c = new Array(a.length),
                    n = 0,
                    i = a.length; n < i; n++)
                        s = a[n],
                        c[n] = e(t[s], s, n);
            return o(c) || (c = []),
            c._isVList = !0,
            c
        }
        function he(t, e, n, i) {
            var r, a = this.$scopedSlots[t];
            a ? (n = n || {},
            i && (n = N(N({}, i), n)),
            r = a(n) || (u(e) ? e() : e)) : r = this.$slots[t] || (u(e) ? e() : e);
            var o = n && n.slot;
            return o ? this.$createElement("template", {
                slot: o
            }, r) : r
        }
        function de(t) {
            return Ti(this.$options, "filters", t, !0) || k
        }
        function pe(t, e) {
            return r(t) ? -1 === t.indexOf(e) : t !== e
        }
        function fe(t, e, n, i, r) {
            var a = q.keyCodes[e] || n;
            return r && i && !q.keyCodes[e] ? pe(r, i) : a ? pe(a, t) : i ? P(i) !== e : void 0 === t
        }
        function me(t, e, n, i, a) {
            if (n)
                if (h(n)) {
                    r(n) && (n = O(n));
                    var o = void 0
                      , s = function(r) {
                        if ("class" === r || "style" === r || M(r))
                            o = t;
                        else {
                            var s = t.attrs && t.attrs.type;
                            o = i || q.mustUseProp(e, s, r) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {})
                        }
                        var c = A(r)
                          , l = P(r);
                        if (!(c in o) && !(l in o) && (o[r] = n[r],
                        a)) {
                            var u = t.on || (t.on = {});
                            u["update:".concat(r)] = function(t) {
                                n[r] = t
                            }
                        }
                    };
                    for (var c in n)
                        s(c)
                } else
                    ;return t
        }
        function ge(t, e) {
            var n = this._staticTrees || (this._staticTrees = [])
              , i = n[t];
            return i && !e || (i = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, this._c, this),
            _e(i, "__static__".concat(t), !1)),
            i
        }
        function ve(t, e, n) {
            return _e(t, "__once__".concat(e).concat(n ? "_".concat(n) : ""), !0),
            t
        }
        function _e(t, e, n) {
            if (r(t))
                for (var i = 0; i < t.length; i++)
                    t[i] && "string" !== typeof t[i] && ye(t[i], "".concat(e, "_").concat(i), n);
            else
                ye(t, e, n)
        }
        function ye(t, e, n) {
            t.isStatic = !0,
            t.key = e,
            t.isOnce = n
        }
        function xe(t, e) {
            if (e)
                if (p(e)) {
                    var n = t.on = t.on ? N({}, t.on) : {};
                    for (var i in e) {
                        var r = n[i]
                          , a = e[i];
                        n[i] = r ? [].concat(r, a) : a
                    }
                } else
                    ;return t
        }
        function Me(t, e, n, i) {
            e = e || {
                $stable: !n
            };
            for (var a = 0; a < t.length; a++) {
                var o = t[a];
                r(o) ? Me(o, e, n) : o && (o.proxy && (o.fn.proxy = !0),
                e[o.key] = o.fn)
            }
            return i && (e.$key = i),
            e
        }
        function be(t, e) {
            for (var n = 0; n < e.length; n += 2) {
                var i = e[n];
                "string" === typeof i && i && (t[e[n]] = e[n + 1])
            }
            return t
        }
        function Se(t, e) {
            return "string" === typeof t ? e + t : t
        }
        function Ee(t) {
            t._o = ve,
            t._n = y,
            t._s = v,
            t._l = ue,
            t._t = he,
            t._q = z,
            t._i = V,
            t._m = ge,
            t._f = de,
            t._k = fe,
            t._b = me,
            t._v = xt,
            t._e = yt,
            t._u = Me,
            t._g = xe,
            t._d = be,
            t._p = Se
        }
        function Te(t, e) {
            if (!t || !t.length)
                return {};
            for (var n = {}, i = 0, r = t.length; i < r; i++) {
                var a = t[i]
                  , o = a.data;
                if (o && o.attrs && o.attrs.slot && delete o.attrs.slot,
                a.context !== e && a.fnContext !== e || !o || null == o.slot)
                    (n.default || (n.default = [])).push(a);
                else {
                    var s = o.slot
                      , c = n[s] || (n[s] = []);
                    "template" === a.tag ? c.push.apply(c, a.children || []) : c.push(a)
                }
            }
            for (var l in n)
                n[l].every(we) && delete n[l];
            return n
        }
        function we(t) {
            return t.isComment && !t.asyncFactory || " " === t.text
        }
        function Ae(t) {
            return t.isComment && t.asyncFactory
        }
        function Re(t, e, n, r) {
            var a, o = Object.keys(n).length > 0, s = e ? !!e.$stable : !o, c = e && e.$key;
            if (e) {
                if (e._normalized)
                    return e._normalized;
                if (s && r && r !== i && c === r.$key && !o && !r.$hasNormal)
                    return r;
                for (var l in a = {},
                e)
                    e[l] && "$" !== l[0] && (a[l] = Ce(t, n, l, e[l]))
            } else
                a = {};
            for (var u in n)
                u in a || (a[u] = Pe(n, u));
            return e && Object.isExtensible(e) && (e._normalized = a),
            K(a, "$stable", s),
            K(a, "$key", c),
            K(a, "$hasNormal", o),
            a
        }
        function Ce(t, e, n, i) {
            var a = function() {
                var e = gt;
                vt(t);
                var n = arguments.length ? i.apply(null, arguments) : i({});
                n = n && "object" === typeof n && !r(n) ? [n] : se(n);
                var a = n && n[0];
                return vt(e),
                n && (!a || 1 === n.length && a.isComment && !Ae(a)) ? void 0 : n
            };
            return i.proxy && Object.defineProperty(e, n, {
                get: a,
                enumerable: !0,
                configurable: !0
            }),
            a
        }
        function Pe(t, e) {
            return function() {
                return t[e]
            }
        }
        function Le(t) {
            var e = t.$options
              , n = e.setup;
            if (n) {
                var i = t._setupContext = Ie(t);
                vt(t),
                At();
                var r = Ze(n, null, [t._props || Gt({}), i], t, "setup");
                if (Rt(),
                vt(),
                u(r))
                    e.render = r;
                else if (h(r))
                    if (t._setupState = r,
                    r.__sfc) {
                        var a = t._setupProxy = {};
                        for (var o in r)
                            "__sfc" !== o && qt(a, r, o)
                    } else
                        for (var o in r)
                            Y(o) || qt(t, r, o);
                else
                    0
            }
        }
        function Ie(t) {
            return {
                get attrs() {
                    if (!t._attrsProxy) {
                        var e = t._attrsProxy = {};
                        K(e, "_v_attr_proxy", !0),
                        Ue(e, t.$attrs, i, t, "$attrs")
                    }
                    return t._attrsProxy
                },
                get listeners() {
                    if (!t._listenersProxy) {
                        var e = t._listenersProxy = {};
                        Ue(e, t.$listeners, i, t, "$listeners")
                    }
                    return t._listenersProxy
                },
                get slots() {
                    return Ne(t)
                },
                emit: U(t.$emit, t),
                expose: function(e) {
                    e && Object.keys(e).forEach((function(n) {
                        return qt(t, e, n)
                    }
                    ))
                }
            }
        }
        function Ue(t, e, n, i, r) {
            var a = !1;
            for (var o in e)
                o in t ? e[o] !== n[o] && (a = !0) : (a = !0,
                De(t, o, i, r));
            for (var o in t)
                o in e || (a = !0,
                delete t[o]);
            return a
        }
        function De(t, e, n, i) {
            Object.defineProperty(t, e, {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return n[i][e]
                }
            })
        }
        function Ne(t) {
            return t._slotsProxy || Oe(t._slotsProxy = {}, t.$scopedSlots),
            t._slotsProxy
        }
        function Oe(t, e) {
            for (var n in e)
                t[n] = e[n];
            for (var n in t)
                n in e || delete t[n]
        }
        function Fe(t) {
            t._vnode = null,
            t._staticTrees = null;
            var e = t.$options
              , n = t.$vnode = e._parentVnode
              , r = n && n.context;
            t.$slots = Te(e._renderChildren, r),
            t.$scopedSlots = n ? Re(t.$parent, n.data.scopedSlots, t.$slots) : i,
            t._c = function(e, n, i, r) {
                return Xe(t, e, n, i, r, !1)
            }
            ,
            t.$createElement = function(e, n, i, r) {
                return Xe(t, e, n, i, r, !0)
            }
            ;
            var a = n && n.data;
            kt(t, "$attrs", a && a.attrs || i, null, !0),
            kt(t, "$listeners", e._parentListeners || i, null, !0)
        }
        var Be = null;
        function ke(t) {
            Ee(t.prototype),
            t.prototype.$nextTick = function(t) {
                return un(t, this)
            }
            ,
            t.prototype._render = function() {
                var t = this
                  , e = t.$options
                  , n = e.render
                  , i = e._parentVnode;
                i && t._isMounted && (t.$scopedSlots = Re(t.$parent, i.data.scopedSlots, t.$slots, t.$scopedSlots),
                t._slotsProxy && Oe(t._slotsProxy, t.$scopedSlots)),
                t.$vnode = i;
                var a, o = gt, s = Be;
                try {
                    vt(t),
                    Be = t,
                    a = n.call(t._renderProxy, t.$createElement)
                } catch (Qo) {
                    Ke(Qo, t, "render"),
                    a = t._vnode
                } finally {
                    Be = s,
                    vt(o)
                }
                return r(a) && 1 === a.length && (a = a[0]),
                a instanceof _t || (a = yt()),
                a.parent = i,
                a
            }
        }
        function ze(t, e) {
            return (t.__esModule || mt && "Module" === t[Symbol.toStringTag]) && (t = t.default),
            h(t) ? e.extend(t) : t
        }
        function Ve(t, e, n, i, r) {
            var a = yt();
            return a.asyncFactory = t,
            a.asyncMeta = {
                data: e,
                context: n,
                children: i,
                tag: r
            },
            a
        }
        function He(t, e) {
            if (s(t.error) && o(t.errorComp))
                return t.errorComp;
            if (o(t.resolved))
                return t.resolved;
            var n = Be;
            if (n && o(t.owners) && -1 === t.owners.indexOf(n) && t.owners.push(n),
            s(t.loading) && o(t.loadingComp))
                return t.loadingComp;
            if (n && !o(t.owners)) {
                var i = t.owners = [n]
                  , r = !0
                  , c = null
                  , l = null;
                n.$on("hook:destroyed", (function() {
                    return b(i, n)
                }
                ));
                var u = function(t) {
                    for (var e = 0, n = i.length; e < n; e++)
                        i[e].$forceUpdate();
                    t && (i.length = 0,
                    null !== c && (clearTimeout(c),
                    c = null),
                    null !== l && (clearTimeout(l),
                    l = null))
                }
                  , d = H((function(n) {
                    t.resolved = ze(n, e),
                    r ? i.length = 0 : u(!0)
                }
                ))
                  , p = H((function(e) {
                    o(t.errorComp) && (t.error = !0,
                    u(!0))
                }
                ))
                  , f = t(d, p);
                return h(f) && (g(f) ? a(t.resolved) && f.then(d, p) : g(f.component) && (f.component.then(d, p),
                o(f.error) && (t.errorComp = ze(f.error, e)),
                o(f.loading) && (t.loadingComp = ze(f.loading, e),
                0 === f.delay ? t.loading = !0 : c = setTimeout((function() {
                    c = null,
                    a(t.resolved) && a(t.error) && (t.loading = !0,
                    u(!1))
                }
                ), f.delay || 200)),
                o(f.timeout) && (l = setTimeout((function() {
                    l = null,
                    a(t.resolved) && p(null)
                }
                ), f.timeout)))),
                r = !1,
                t.loading ? t.loadingComp : t.resolved
            }
        }
        function Ge(t) {
            if (r(t))
                for (var e = 0; e < t.length; e++) {
                    var n = t[e];
                    if (o(n) && (o(n.componentOptions) || Ae(n)))
                        return n
                }
        }
        var je = 1
          , We = 2;
        function Xe(t, e, n, i, a, o) {
            return (r(n) || l(n)) && (a = i,
            i = n,
            n = void 0),
            s(o) && (a = We),
            qe(t, e, n, i, a)
        }
        function qe(t, e, n, i, a) {
            if (o(n) && o(n.__ob__))
                return yt();
            if (o(n) && o(n.is) && (e = n.is),
            !e)
                return yt();
            var s, c;
            if (r(i) && u(i[0]) && (n = n || {},
            n.scopedSlots = {
                default: i[0]
            },
            i.length = 0),
            a === We ? i = se(i) : a === je && (i = oe(i)),
            "string" === typeof e) {
                var l = void 0;
                c = t.$vnode && t.$vnode.ns || q.getTagNamespace(e),
                s = q.isReservedTag(e) ? new _t(q.parsePlatformTagName(e),n,i,void 0,void 0,t) : n && n.pre || !o(l = Ti(t.$options, "components", e)) ? new _t(e,n,i,void 0,void 0,t) : ci(l, n, t, i, e)
            } else
                s = ci(e, n, t, i);
            return r(s) ? s : o(s) ? (o(c) && $e(s, c),
            o(n) && Ye(n),
            s) : yt()
        }
        function $e(t, e, n) {
            if (t.ns = e,
            "foreignObject" === t.tag && (e = void 0,
            n = !0),
            o(t.children))
                for (var i = 0, r = t.children.length; i < r; i++) {
                    var c = t.children[i];
                    o(c.tag) && (a(c.ns) || s(n) && "svg" !== c.tag) && $e(c, e, n)
                }
        }
        function Ye(t) {
            h(t.style) && mn(t.style),
            h(t.class) && mn(t.class)
        }
        function Ke(t, e, n) {
            At();
            try {
                if (e) {
                    var i = e;
                    while (i = i.$parent) {
                        var r = i.$options.errorCaptured;
                        if (r)
                            for (var a = 0; a < r.length; a++)
                                try {
                                    var o = !1 === r[a].call(i, t, e, n);
                                    if (o)
                                        return
                                } catch (Qo) {
                                    Je(Qo, i, "errorCaptured hook")
                                }
                    }
                }
                Je(t, e, n)
            } finally {
                Rt()
            }
        }
        function Ze(t, e, n, i, r) {
            var a;
            try {
                a = n ? t.apply(e, n) : t.call(e),
                a && !a._isVue && g(a) && !a._handled && (a.catch((function(t) {
                    return Ke(t, i, r + " (Promise/async)")
                }
                )),
                a._handled = !0)
            } catch (Qo) {
                Ke(Qo, i, r)
            }
            return a
        }
        function Je(t, e, n) {
            if (q.errorHandler)
                try {
                    return q.errorHandler.call(null, t, e, n)
                } catch (Qo) {
                    Qo !== t && Qe(Qo, null, "config.errorHandler")
                }
            Qe(t, e, n)
        }
        function Qe(t, e, n) {
            if (!tt || "undefined" === typeof console)
                throw t;
            console.error(t)
        }
        var tn, en = !1, nn = [], rn = !1;
        function an() {
            rn = !1;
            var t = nn.slice(0);
            nn.length = 0;
            for (var e = 0; e < t.length; e++)
                t[e]()
        }
        if ("undefined" !== typeof Promise && pt(Promise)) {
            var on = Promise.resolve();
            tn = function() {
                on.then(an),
                at && setTimeout(F)
            }
            ,
            en = !0
        } else if (nt || "undefined" === typeof MutationObserver || !pt(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString())
            tn = "undefined" !== typeof setImmediate && pt(setImmediate) ? function() {
                setImmediate(an)
            }
            : function() {
                setTimeout(an, 0)
            }
            ;
        else {
            var sn = 1
              , cn = new MutationObserver(an)
              , ln = document.createTextNode(String(sn));
            cn.observe(ln, {
                characterData: !0
            }),
            tn = function() {
                sn = (sn + 1) % 2,
                ln.data = String(sn)
            }
            ,
            en = !0
        }
        function un(t, e) {
            var n;
            if (nn.push((function() {
                if (t)
                    try {
                        t.call(e)
                    } catch (Qo) {
                        Ke(Qo, e, "nextTick")
                    }
                else
                    n && n(e)
            }
            )),
            rn || (rn = !0,
            tn()),
            !t && "undefined" !== typeof Promise)
                return new Promise((function(t) {
                    n = t
                }
                ))
        }
        function hn(t) {
            return function(e, n) {
                if (void 0 === n && (n = gt),
                n)
                    return dn(n, t, e)
            }
        }
        function dn(t, e, n) {
            var i = t.$options;
            i[e] = vi(i[e], n)
        }
        hn("beforeMount"),
        hn("mounted"),
        hn("beforeUpdate"),
        hn("updated"),
        hn("beforeDestroy"),
        hn("destroyed"),
        hn("activated"),
        hn("deactivated"),
        hn("serverPrefetch"),
        hn("renderTracked"),
        hn("renderTriggered"),
        hn("errorCaptured");
        var pn = "2.7.16";
        var fn = new ft;
        function mn(t) {
            return gn(t, fn),
            fn.clear(),
            t
        }
        function gn(t, e) {
            var n, i, a = r(t);
            if (!(!a && !h(t) || t.__v_skip || Object.isFrozen(t) || t instanceof _t)) {
                if (t.__ob__) {
                    var o = t.__ob__.dep.id;
                    if (e.has(o))
                        return;
                    e.add(o)
                }
                if (a) {
                    n = t.length;
                    while (n--)
                        gn(t[n], e)
                } else if (Xt(t))
                    gn(t.value, e);
                else {
                    i = Object.keys(t),
                    n = i.length;
                    while (n--)
                        gn(t[i[n]], e)
                }
            }
        }
        var vn, _n = 0, yn = function() {
            function t(t, e, n, i, r) {
                Zt(this, Yt && !Yt._vm ? Yt : t ? t._scope : void 0),
                (this.vm = t) && r && (t._watcher = this),
                i ? (this.deep = !!i.deep,
                this.user = !!i.user,
                this.lazy = !!i.lazy,
                this.sync = !!i.sync,
                this.before = i.before) : this.deep = this.user = this.lazy = this.sync = !1,
                this.cb = n,
                this.id = ++_n,
                this.active = !0,
                this.post = !1,
                this.dirty = this.lazy,
                this.deps = [],
                this.newDeps = [],
                this.depIds = new ft,
                this.newDepIds = new ft,
                this.expression = "",
                u(e) ? this.getter = e : (this.getter = J(e),
                this.getter || (this.getter = F)),
                this.value = this.lazy ? void 0 : this.get()
            }
            return t.prototype.get = function() {
                var t;
                At(this);
                var e = this.vm;
                try {
                    t = this.getter.call(e, e)
                } catch (Qo) {
                    if (!this.user)
                        throw Qo;
                    Ke(Qo, e, 'getter for watcher "'.concat(this.expression, '"'))
                } finally {
                    this.deep && mn(t),
                    Rt(),
                    this.cleanupDeps()
                }
                return t
            }
            ,
            t.prototype.addDep = function(t) {
                var e = t.id;
                this.newDepIds.has(e) || (this.newDepIds.add(e),
                this.newDeps.push(t),
                this.depIds.has(e) || t.addSub(this))
            }
            ,
            t.prototype.cleanupDeps = function() {
                var t = this.deps.length;
                while (t--) {
                    var e = this.deps[t];
                    this.newDepIds.has(e.id) || e.removeSub(this)
                }
                var n = this.depIds;
                this.depIds = this.newDepIds,
                this.newDepIds = n,
                this.newDepIds.clear(),
                n = this.deps,
                this.deps = this.newDeps,
                this.newDeps = n,
                this.newDeps.length = 0
            }
            ,
            t.prototype.update = function() {
                this.lazy ? this.dirty = !0 : this.sync ? this.run() : Zn(this)
            }
            ,
            t.prototype.run = function() {
                if (this.active) {
                    var t = this.get();
                    if (t !== this.value || h(t) || this.deep) {
                        var e = this.value;
                        if (this.value = t,
                        this.user) {
                            var n = 'callback for watcher "'.concat(this.expression, '"');
                            Ze(this.cb, this.vm, [t, e], this.vm, n)
                        } else
                            this.cb.call(this.vm, t, e)
                    }
                }
            }
            ,
            t.prototype.evaluate = function() {
                this.value = this.get(),
                this.dirty = !1
            }
            ,
            t.prototype.depend = function() {
                var t = this.deps.length;
                while (t--)
                    this.deps[t].depend()
            }
            ,
            t.prototype.teardown = function() {
                if (this.vm && !this.vm._isBeingDestroyed && b(this.vm._scope.effects, this),
                this.active) {
                    var t = this.deps.length;
                    while (t--)
                        this.deps[t].removeSub(this);
                    this.active = !1,
                    this.onStop && this.onStop()
                }
            }
            ,
            t
        }();
        function xn(t) {
            t._events = Object.create(null),
            t._hasHookEvent = !1;
            var e = t.$options._parentListeners;
            e && En(t, e)
        }
        function Mn(t, e) {
            vn.$on(t, e)
        }
        function bn(t, e) {
            vn.$off(t, e)
        }
        function Sn(t, e) {
            var n = vn;
            return function i() {
                var r = e.apply(null, arguments);
                null !== r && n.$off(t, i)
            }
        }
        function En(t, e, n) {
            vn = t,
            ne(e, n || {}, Mn, bn, Sn, t),
            vn = void 0
        }
        function Tn(t) {
            var e = /^hook:/;
            t.prototype.$on = function(t, n) {
                var i = this;
                if (r(t))
                    for (var a = 0, o = t.length; a < o; a++)
                        i.$on(t[a], n);
                else
                    (i._events[t] || (i._events[t] = [])).push(n),
                    e.test(t) && (i._hasHookEvent = !0);
                return i
            }
            ,
            t.prototype.$once = function(t, e) {
                var n = this;
                function i() {
                    n.$off(t, i),
                    e.apply(n, arguments)
                }
                return i.fn = e,
                n.$on(t, i),
                n
            }
            ,
            t.prototype.$off = function(t, e) {
                var n = this;
                if (!arguments.length)
                    return n._events = Object.create(null),
                    n;
                if (r(t)) {
                    for (var i = 0, a = t.length; i < a; i++)
                        n.$off(t[i], e);
                    return n
                }
                var o, s = n._events[t];
                if (!s)
                    return n;
                if (!e)
                    return n._events[t] = null,
                    n;
                var c = s.length;
                while (c--)
                    if (o = s[c],
                    o === e || o.fn === e) {
                        s.splice(c, 1);
                        break
                    }
                return n
            }
            ,
            t.prototype.$emit = function(t) {
                var e = this
                  , n = e._events[t];
                if (n) {
                    n = n.length > 1 ? D(n) : n;
                    for (var i = D(arguments, 1), r = 'event handler for "'.concat(t, '"'), a = 0, o = n.length; a < o; a++)
                        Ze(n[a], e, i, e, r)
                }
                return e
            }
        }
        var wn = null;
        function An(t) {
            var e = wn;
            return wn = t,
            function() {
                wn = e
            }
        }
        function Rn(t) {
            var e = t.$options
              , n = e.parent;
            if (n && !e.abstract) {
                while (n.$options.abstract && n.$parent)
                    n = n.$parent;
                n.$children.push(t)
            }
            t.$parent = n,
            t.$root = n ? n.$root : t,
            t.$children = [],
            t.$refs = {},
            t._provided = n ? n._provided : Object.create(null),
            t._watcher = null,
            t._inactive = null,
            t._directInactive = !1,
            t._isMounted = !1,
            t._isDestroyed = !1,
            t._isBeingDestroyed = !1
        }
        function Cn(t) {
            t.prototype._update = function(t, e) {
                var n = this
                  , i = n.$el
                  , r = n._vnode
                  , a = An(n);
                n._vnode = t,
                n.$el = r ? n.__patch__(r, t) : n.__patch__(n.$el, t, e, !1),
                a(),
                i && (i.__vue__ = null),
                n.$el && (n.$el.__vue__ = n);
                var o = n;
                while (o && o.$vnode && o.$parent && o.$vnode === o.$parent._vnode)
                    o.$parent.$el = o.$el,
                    o = o.$parent
            }
            ,
            t.prototype.$forceUpdate = function() {
                var t = this;
                t._watcher && t._watcher.update()
            }
            ,
            t.prototype.$destroy = function() {
                var t = this;
                if (!t._isBeingDestroyed) {
                    Nn(t, "beforeDestroy"),
                    t._isBeingDestroyed = !0;
                    var e = t.$parent;
                    !e || e._isBeingDestroyed || t.$options.abstract || b(e.$children, t),
                    t._scope.stop(),
                    t._data.__ob__ && t._data.__ob__.vmCount--,
                    t._isDestroyed = !0,
                    t.__patch__(t._vnode, null),
                    Nn(t, "destroyed"),
                    t.$off(),
                    t.$el && (t.$el.__vue__ = null),
                    t.$vnode && (t.$vnode.parent = null)
                }
            }
        }
        function Pn(t, e, n) {
            var i;
            t.$el = e,
            t.$options.render || (t.$options.render = yt),
            Nn(t, "beforeMount"),
            i = function() {
                t._update(t._render(), n)
            }
            ;
            var r = {
                before: function() {
                    t._isMounted && !t._isDestroyed && Nn(t, "beforeUpdate")
                }
            };
            new yn(t,i,F,r,!0),
            n = !1;
            var a = t._preWatchers;
            if (a)
                for (var o = 0; o < a.length; o++)
                    a[o].run();
            return null == t.$vnode && (t._isMounted = !0,
            Nn(t, "mounted")),
            t
        }
        function Ln(t, e, n, r, a) {
            var o = r.data.scopedSlots
              , s = t.$scopedSlots
              , c = !!(o && !o.$stable || s !== i && !s.$stable || o && t.$scopedSlots.$key !== o.$key || !o && t.$scopedSlots.$key)
              , l = !!(a || t.$options._renderChildren || c)
              , u = t.$vnode;
            t.$options._parentVnode = r,
            t.$vnode = r,
            t._vnode && (t._vnode.parent = r),
            t.$options._renderChildren = a;
            var h = r.data.attrs || i;
            t._attrsProxy && Ue(t._attrsProxy, h, u.data && u.data.attrs || i, t, "$attrs") && (l = !0),
            t.$attrs = h,
            n = n || i;
            var d = t.$options._parentListeners;
            if (t._listenersProxy && Ue(t._listenersProxy, n, d || i, t, "$listeners"),
            t.$listeners = t.$options._parentListeners = n,
            En(t, n, d),
            e && t.$options.props) {
                Nt(!1);
                for (var p = t._props, f = t.$options._propKeys || [], m = 0; m < f.length; m++) {
                    var g = f[m]
                      , v = t.$options.props;
                    p[g] = wi(g, v, e, t)
                }
                Nt(!0),
                t.$options.propsData = e
            }
            l && (t.$slots = Te(a, r.context),
            t.$forceUpdate())
        }
        function In(t) {
            while (t && (t = t.$parent))
                if (t._inactive)
                    return !0;
            return !1
        }
        function Un(t, e) {
            if (e) {
                if (t._directInactive = !1,
                In(t))
                    return
            } else if (t._directInactive)
                return;
            if (t._inactive || null === t._inactive) {
                t._inactive = !1;
                for (var n = 0; n < t.$children.length; n++)
                    Un(t.$children[n]);
                Nn(t, "activated")
            }
        }
        function Dn(t, e) {
            if ((!e || (t._directInactive = !0,
            !In(t))) && !t._inactive) {
                t._inactive = !0;
                for (var n = 0; n < t.$children.length; n++)
                    Dn(t.$children[n]);
                Nn(t, "deactivated")
            }
        }
        function Nn(t, e, n, i) {
            void 0 === i && (i = !0),
            At();
            var r = gt
              , a = Jt();
            i && vt(t);
            var o = t.$options[e]
              , s = "".concat(e, " hook");
            if (o)
                for (var c = 0, l = o.length; c < l; c++)
                    Ze(o[c], t, n || null, t, s);
            t._hasHookEvent && t.$emit("hook:" + e),
            i && (vt(r),
            a && a.on()),
            Rt()
        }
        var On = []
          , Fn = []
          , Bn = {}
          , kn = !1
          , zn = !1
          , Vn = 0;
        function Hn() {
            Vn = On.length = Fn.length = 0,
            Bn = {},
            kn = zn = !1
        }
        var Gn = 0
          , jn = Date.now;
        if (tt && !nt) {
            var Wn = window.performance;
            Wn && "function" === typeof Wn.now && jn() > document.createEvent("Event").timeStamp && (jn = function() {
                return Wn.now()
            }
            )
        }
        var Xn = function(t, e) {
            if (t.post) {
                if (!e.post)
                    return 1
            } else if (e.post)
                return -1;
            return t.id - e.id
        };
        function qn() {
            var t, e;
            for (Gn = jn(),
            zn = !0,
            On.sort(Xn),
            Vn = 0; Vn < On.length; Vn++)
                t = On[Vn],
                t.before && t.before(),
                e = t.id,
                Bn[e] = null,
                t.run();
            var n = Fn.slice()
              , i = On.slice();
            Hn(),
            Kn(n),
            $n(i),
            Et(),
            dt && q.devtools && dt.emit("flush")
        }
        function $n(t) {
            var e = t.length;
            while (e--) {
                var n = t[e]
                  , i = n.vm;
                i && i._watcher === n && i._isMounted && !i._isDestroyed && Nn(i, "updated")
            }
        }
        function Yn(t) {
            t._inactive = !1,
            Fn.push(t)
        }
        function Kn(t) {
            for (var e = 0; e < t.length; e++)
                t[e]._inactive = !0,
                Un(t[e], !0)
        }
        function Zn(t) {
            var e = t.id;
            if (null == Bn[e] && (t !== Tt.target || !t.noRecurse)) {
                if (Bn[e] = !0,
                zn) {
                    var n = On.length - 1;
                    while (n > Vn && On[n].id > t.id)
                        n--;
                    On.splice(n + 1, 0, t)
                } else
                    On.push(t);
                kn || (kn = !0,
                un(qn))
            }
        }
        function Jn(t) {
            var e = t.$options.provide;
            if (e) {
                var n = u(e) ? e.call(t) : e;
                if (!h(n))
                    return;
                for (var i = Qt(t), r = mt ? Reflect.ownKeys(n) : Object.keys(n), a = 0; a < r.length; a++) {
                    var o = r[a];
                    Object.defineProperty(i, o, Object.getOwnPropertyDescriptor(n, o))
                }
            }
        }
        function Qn(t) {
            var e = ti(t.$options.inject, t);
            e && (Nt(!1),
            Object.keys(e).forEach((function(n) {
                kt(t, n, e[n])
            }
            )),
            Nt(!0))
        }
        function ti(t, e) {
            if (t) {
                for (var n = Object.create(null), i = mt ? Reflect.ownKeys(t) : Object.keys(t), r = 0; r < i.length; r++) {
                    var a = i[r];
                    if ("__ob__" !== a) {
                        var o = t[a].from;
                        if (o in e._provided)
                            n[a] = e._provided[o];
                        else if ("default"in t[a]) {
                            var s = t[a].default;
                            n[a] = u(s) ? s.call(e) : s
                        } else
                            0
                    }
                }
                return n
            }
        }
        function ei(t, e, n, a, o) {
            var c, l = this, u = o.options;
            E(a, "_uid") ? (c = Object.create(a),
            c._original = a) : (c = a,
            a = a._original);
            var h = s(u._compiled)
              , d = !h;
            this.data = t,
            this.props = e,
            this.children = n,
            this.parent = a,
            this.listeners = t.on || i,
            this.injections = ti(u.inject, a),
            this.slots = function() {
                return l.$slots || Re(a, t.scopedSlots, l.$slots = Te(n, a)),
                l.$slots
            }
            ,
            Object.defineProperty(this, "scopedSlots", {
                enumerable: !0,
                get: function() {
                    return Re(a, t.scopedSlots, this.slots())
                }
            }),
            h && (this.$options = u,
            this.$slots = this.slots(),
            this.$scopedSlots = Re(a, t.scopedSlots, this.$slots)),
            u._scopeId ? this._c = function(t, e, n, i) {
                var o = Xe(c, t, e, n, i, d);
                return o && !r(o) && (o.fnScopeId = u._scopeId,
                o.fnContext = a),
                o
            }
            : this._c = function(t, e, n, i) {
                return Xe(c, t, e, n, i, d)
            }
        }
        function ni(t, e, n, a, s) {
            var c = t.options
              , l = {}
              , u = c.props;
            if (o(u))
                for (var h in u)
                    l[h] = wi(h, u, e || i);
            else
                o(n.attrs) && ri(l, n.attrs),
                o(n.props) && ri(l, n.props);
            var d = new ei(n,l,s,a,t)
              , p = c.render.call(null, d._c, d);
            if (p instanceof _t)
                return ii(p, n, d.parent, c, d);
            if (r(p)) {
                for (var f = se(p) || [], m = new Array(f.length), g = 0; g < f.length; g++)
                    m[g] = ii(f[g], n, d.parent, c, d);
                return m
            }
        }
        function ii(t, e, n, i, r) {
            var a = Mt(t);
            return a.fnContext = n,
            a.fnOptions = i,
            e.slot && ((a.data || (a.data = {})).slot = e.slot),
            a
        }
        function ri(t, e) {
            for (var n in e)
                t[A(n)] = e[n]
        }
        function ai(t) {
            return t.name || t.__name || t._componentTag
        }
        Ee(ei.prototype);
        var oi = {
            init: function(t, e) {
                if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
                    var n = t;
                    oi.prepatch(n, n)
                } else {
                    var i = t.componentInstance = li(t, wn);
                    i.$mount(e ? t.elm : void 0, e)
                }
            },
            prepatch: function(t, e) {
                var n = e.componentOptions
                  , i = e.componentInstance = t.componentInstance;
                Ln(i, n.propsData, n.listeners, e, n.children)
            },
            insert: function(t) {
                var e = t.context
                  , n = t.componentInstance;
                n._isMounted || (n._isMounted = !0,
                Nn(n, "mounted")),
                t.data.keepAlive && (e._isMounted ? Yn(n) : Un(n, !0))
            },
            destroy: function(t) {
                var e = t.componentInstance;
                e._isDestroyed || (t.data.keepAlive ? Dn(e, !0) : e.$destroy())
            }
        }
          , si = Object.keys(oi);
        function ci(t, e, n, i, r) {
            if (!a(t)) {
                var c = n.$options._base;
                if (h(t) && (t = c.extend(t)),
                "function" === typeof t) {
                    var l;
                    if (a(t.cid) && (l = t,
                    t = He(l, c),
                    void 0 === t))
                        return Ve(l, e, n, i, r);
                    e = e || {},
                    Ki(t),
                    o(e.model) && di(t.options, e);
                    var u = re(e, t, r);
                    if (s(t.options.functional))
                        return ni(t, u, e, n, i);
                    var d = e.on;
                    if (e.on = e.nativeOn,
                    s(t.options.abstract)) {
                        var p = e.slot;
                        e = {},
                        p && (e.slot = p)
                    }
                    ui(e);
                    var f = ai(t.options) || r
                      , m = new _t("vue-component-".concat(t.cid).concat(f ? "-".concat(f) : ""),e,void 0,void 0,void 0,n,{
                        Ctor: t,
                        propsData: u,
                        listeners: d,
                        tag: r,
                        children: i
                    },l);
                    return m
                }
            }
        }
        function li(t, e) {
            var n = {
                _isComponent: !0,
                _parentVnode: t,
                parent: e
            }
              , i = t.data.inlineTemplate;
            return o(i) && (n.render = i.render,
            n.staticRenderFns = i.staticRenderFns),
            new t.componentOptions.Ctor(n)
        }
        function ui(t) {
            for (var e = t.hook || (t.hook = {}), n = 0; n < si.length; n++) {
                var i = si[n]
                  , r = e[i]
                  , a = oi[i];
                r === a || r && r._merged || (e[i] = r ? hi(a, r) : a)
            }
        }
        function hi(t, e) {
            var n = function(n, i) {
                t(n, i),
                e(n, i)
            };
            return n._merged = !0,
            n
        }
        function di(t, e) {
            var n = t.model && t.model.prop || "value"
              , i = t.model && t.model.event || "input";
            (e.attrs || (e.attrs = {}))[n] = e.model.value;
            var a = e.on || (e.on = {})
              , s = a[i]
              , c = e.model.callback;
            o(s) ? (r(s) ? -1 === s.indexOf(c) : s !== c) && (a[i] = [c].concat(s)) : a[i] = c
        }
        var pi = F
          , fi = q.optionMergeStrategies;
        function mi(t, e, n) {
            if (void 0 === n && (n = !0),
            !e)
                return t;
            for (var i, r, a, o = mt ? Reflect.ownKeys(e) : Object.keys(e), s = 0; s < o.length; s++)
                i = o[s],
                "__ob__" !== i && (r = t[i],
                a = e[i],
                n && E(t, i) ? r !== a && p(r) && p(a) && mi(r, a) : zt(t, i, a));
            return t
        }
        function gi(t, e, n) {
            return n ? function() {
                var i = u(e) ? e.call(n, n) : e
                  , r = u(t) ? t.call(n, n) : t;
                return i ? mi(i, r) : r
            }
            : e ? t ? function() {
                return mi(u(e) ? e.call(this, this) : e, u(t) ? t.call(this, this) : t)
            }
            : e : t
        }
        function vi(t, e) {
            var n = e ? t ? t.concat(e) : r(e) ? e : [e] : t;
            return n ? _i(n) : n
        }
        function _i(t) {
            for (var e = [], n = 0; n < t.length; n++)
                -1 === e.indexOf(t[n]) && e.push(t[n]);
            return e
        }
        function yi(t, e, n, i) {
            var r = Object.create(t || null);
            return e ? N(r, e) : r
        }
        fi.data = function(t, e, n) {
            return n ? gi(t, e, n) : e && "function" !== typeof e ? t : gi(t, e)
        }
        ,
        X.forEach((function(t) {
            fi[t] = vi
        }
        )),
        W.forEach((function(t) {
            fi[t + "s"] = yi
        }
        )),
        fi.watch = function(t, e, n, i) {
            if (t === ct && (t = void 0),
            e === ct && (e = void 0),
            !e)
                return Object.create(t || null);
            if (!t)
                return e;
            var a = {};
            for (var o in N(a, t),
            e) {
                var s = a[o]
                  , c = e[o];
                s && !r(s) && (s = [s]),
                a[o] = s ? s.concat(c) : r(c) ? c : [c]
            }
            return a
        }
        ,
        fi.props = fi.methods = fi.inject = fi.computed = function(t, e, n, i) {
            if (!t)
                return e;
            var r = Object.create(null);
            return N(r, t),
            e && N(r, e),
            r
        }
        ,
        fi.provide = function(t, e) {
            return t ? function() {
                var n = Object.create(null);
                return mi(n, u(t) ? t.call(this) : t),
                e && mi(n, u(e) ? e.call(this) : e, !1),
                n
            }
            : e
        }
        ;
        var xi = function(t, e) {
            return void 0 === e ? t : e
        };
        function Mi(t, e) {
            var n = t.props;
            if (n) {
                var i, a, o, s = {};
                if (r(n)) {
                    i = n.length;
                    while (i--)
                        a = n[i],
                        "string" === typeof a && (o = A(a),
                        s[o] = {
                            type: null
                        })
                } else if (p(n))
                    for (var c in n)
                        a = n[c],
                        o = A(c),
                        s[o] = p(a) ? a : {
                            type: a
                        };
                else
                    0;
                t.props = s
            }
        }
        function bi(t, e) {
            var n = t.inject;
            if (n) {
                var i = t.inject = {};
                if (r(n))
                    for (var a = 0; a < n.length; a++)
                        i[n[a]] = {
                            from: n[a]
                        };
                else if (p(n))
                    for (var o in n) {
                        var s = n[o];
                        i[o] = p(s) ? N({
                            from: o
                        }, s) : {
                            from: s
                        }
                    }
                else
                    0
            }
        }
        function Si(t) {
            var e = t.directives;
            if (e)
                for (var n in e) {
                    var i = e[n];
                    u(i) && (e[n] = {
                        bind: i,
                        update: i
                    })
                }
        }
        function Ei(t, e, n) {
            if (u(e) && (e = e.options),
            Mi(e, n),
            bi(e, n),
            Si(e),
            !e._base && (e.extends && (t = Ei(t, e.extends, n)),
            e.mixins))
                for (var i = 0, r = e.mixins.length; i < r; i++)
                    t = Ei(t, e.mixins[i], n);
            var a, o = {};
            for (a in t)
                s(a);
            for (a in e)
                E(t, a) || s(a);
            function s(i) {
                var r = fi[i] || xi;
                o[i] = r(t[i], e[i], n, i)
            }
            return o
        }
        function Ti(t, e, n, i) {
            if ("string" === typeof n) {
                var r = t[e];
                if (E(r, n))
                    return r[n];
                var a = A(n);
                if (E(r, a))
                    return r[a];
                var o = R(a);
                if (E(r, o))
                    return r[o];
                var s = r[n] || r[a] || r[o];
                return s
            }
        }
        function wi(t, e, n, i) {
            var r = e[t]
              , a = !E(n, t)
              , o = n[t]
              , s = Li(Boolean, r.type);
            if (s > -1)
                if (a && !E(r, "default"))
                    o = !1;
                else if ("" === o || o === P(t)) {
                    var c = Li(String, r.type);
                    (c < 0 || s < c) && (o = !0)
                }
            if (void 0 === o) {
                o = Ai(i, r, t);
                var l = Dt;
                Nt(!0),
                Bt(o),
                Nt(l)
            }
            return o
        }
        function Ai(t, e, n) {
            if (E(e, "default")) {
                var i = e.default;
                return t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n] ? t._props[n] : u(i) && "Function" !== Ci(e.type) ? i.call(t) : i
            }
        }
        var Ri = /^\s*function (\w+)/;
        function Ci(t) {
            var e = t && t.toString().match(Ri);
            return e ? e[1] : ""
        }
        function Pi(t, e) {
            return Ci(t) === Ci(e)
        }
        function Li(t, e) {
            if (!r(e))
                return Pi(e, t) ? 0 : -1;
            for (var n = 0, i = e.length; n < i; n++)
                if (Pi(e[n], t))
                    return n;
            return -1
        }
        var Ii = {
            enumerable: !0,
            configurable: !0,
            get: F,
            set: F
        };
        function Ui(t, e, n) {
            Ii.get = function() {
                return this[e][n]
            }
            ,
            Ii.set = function(t) {
                this[e][n] = t
            }
            ,
            Object.defineProperty(t, n, Ii)
        }
        function Di(t) {
            var e = t.$options;
            if (e.props && Ni(t, e.props),
            Le(t),
            e.methods && Gi(t, e.methods),
            e.data)
                Oi(t);
            else {
                var n = Bt(t._data = {});
                n && n.vmCount++
            }
            e.computed && ki(t, e.computed),
            e.watch && e.watch !== ct && ji(t, e.watch)
        }
        function Ni(t, e) {
            var n = t.$options.propsData || {}
              , i = t._props = Gt({})
              , r = t.$options._propKeys = []
              , a = !t.$parent;
            a || Nt(!1);
            var o = function(a) {
                r.push(a);
                var o = wi(a, e, n, t);
                kt(i, a, o, void 0, !0),
                a in t || Ui(t, "_props", a)
            };
            for (var s in e)
                o(s);
            Nt(!0)
        }
        function Oi(t) {
            var e = t.$options.data;
            e = t._data = u(e) ? Fi(e, t) : e || {},
            p(e) || (e = {});
            var n = Object.keys(e)
              , i = t.$options.props
              , r = (t.$options.methods,
            n.length);
            while (r--) {
                var a = n[r];
                0,
                i && E(i, a) || Y(a) || Ui(t, "_data", a)
            }
            var o = Bt(e);
            o && o.vmCount++
        }
        function Fi(t, e) {
            At();
            try {
                return t.call(e, e)
            } catch (Qo) {
                return Ke(Qo, e, "data()"),
                {}
            } finally {
                Rt()
            }
        }
        var Bi = {
            lazy: !0
        };
        function ki(t, e) {
            var n = t._computedWatchers = Object.create(null)
              , i = ht();
            for (var r in e) {
                var a = e[r]
                  , o = u(a) ? a : a.get;
                0,
                i || (n[r] = new yn(t,o || F,F,Bi)),
                r in t || zi(t, r, a)
            }
        }
        function zi(t, e, n) {
            var i = !ht();
            u(n) ? (Ii.get = i ? Vi(e) : Hi(n),
            Ii.set = F) : (Ii.get = n.get ? i && !1 !== n.cache ? Vi(e) : Hi(n.get) : F,
            Ii.set = n.set || F),
            Object.defineProperty(t, e, Ii)
        }
        function Vi(t) {
            return function() {
                var e = this._computedWatchers && this._computedWatchers[t];
                if (e)
                    return e.dirty && e.evaluate(),
                    Tt.target && e.depend(),
                    e.value
            }
        }
        function Hi(t) {
            return function() {
                return t.call(this, this)
            }
        }
        function Gi(t, e) {
            t.$options.props;
            for (var n in e)
                t[n] = "function" !== typeof e[n] ? F : U(e[n], t)
        }
        function ji(t, e) {
            for (var n in e) {
                var i = e[n];
                if (r(i))
                    for (var a = 0; a < i.length; a++)
                        Wi(t, n, i[a]);
                else
                    Wi(t, n, i)
            }
        }
        function Wi(t, e, n, i) {
            return p(n) && (i = n,
            n = n.handler),
            "string" === typeof n && (n = t[n]),
            t.$watch(e, n, i)
        }
        function Xi(t) {
            var e = {
                get: function() {
                    return this._data
                }
            }
              , n = {
                get: function() {
                    return this._props
                }
            };
            Object.defineProperty(t.prototype, "$data", e),
            Object.defineProperty(t.prototype, "$props", n),
            t.prototype.$set = zt,
            t.prototype.$delete = Vt,
            t.prototype.$watch = function(t, e, n) {
                var i = this;
                if (p(e))
                    return Wi(i, t, e, n);
                n = n || {},
                n.user = !0;
                var r = new yn(i,t,e,n);
                if (n.immediate) {
                    var a = 'callback for immediate watcher "'.concat(r.expression, '"');
                    At(),
                    Ze(e, i, [r.value], i, a),
                    Rt()
                }
                return function() {
                    r.teardown()
                }
            }
        }
        var qi = 0;
        function $i(t) {
            t.prototype._init = function(t) {
                var e = this;
                e._uid = qi++,
                e._isVue = !0,
                e.__v_skip = !0,
                e._scope = new Kt(!0),
                e._scope.parent = void 0,
                e._scope._vm = !0,
                t && t._isComponent ? Yi(e, t) : e.$options = Ei(Ki(e.constructor), t || {}, e),
                e._renderProxy = e,
                e._self = e,
                Rn(e),
                xn(e),
                Fe(e),
                Nn(e, "beforeCreate", void 0, !1),
                Qn(e),
                Di(e),
                Jn(e),
                Nn(e, "created"),
                e.$options.el && e.$mount(e.$options.el)
            }
        }
        function Yi(t, e) {
            var n = t.$options = Object.create(t.constructor.options)
              , i = e._parentVnode;
            n.parent = e.parent,
            n._parentVnode = i;
            var r = i.componentOptions;
            n.propsData = r.propsData,
            n._parentListeners = r.listeners,
            n._renderChildren = r.children,
            n._componentTag = r.tag,
            e.render && (n.render = e.render,
            n.staticRenderFns = e.staticRenderFns)
        }
        function Ki(t) {
            var e = t.options;
            if (t.super) {
                var n = Ki(t.super)
                  , i = t.superOptions;
                if (n !== i) {
                    t.superOptions = n;
                    var r = Zi(t);
                    r && N(t.extendOptions, r),
                    e = t.options = Ei(n, t.extendOptions),
                    e.name && (e.components[e.name] = t)
                }
            }
            return e
        }
        function Zi(t) {
            var e, n = t.options, i = t.sealedOptions;
            for (var r in n)
                n[r] !== i[r] && (e || (e = {}),
                e[r] = n[r]);
            return e
        }
        function Ji(t) {
            this._init(t)
        }
        function Qi(t) {
            t.use = function(t) {
                var e = this._installedPlugins || (this._installedPlugins = []);
                if (e.indexOf(t) > -1)
                    return this;
                var n = D(arguments, 1);
                return n.unshift(this),
                u(t.install) ? t.install.apply(t, n) : u(t) && t.apply(null, n),
                e.push(t),
                this
            }
        }
        function tr(t) {
            t.mixin = function(t) {
                return this.options = Ei(this.options, t),
                this
            }
        }
        function er(t) {
            t.cid = 0;
            var e = 1;
            t.extend = function(t) {
                t = t || {};
                var n = this
                  , i = n.cid
                  , r = t._Ctor || (t._Ctor = {});
                if (r[i])
                    return r[i];
                var a = ai(t) || ai(n.options);
                var o = function(t) {
                    this._init(t)
                };
                return o.prototype = Object.create(n.prototype),
                o.prototype.constructor = o,
                o.cid = e++,
                o.options = Ei(n.options, t),
                o["super"] = n,
                o.options.props && nr(o),
                o.options.computed && ir(o),
                o.extend = n.extend,
                o.mixin = n.mixin,
                o.use = n.use,
                W.forEach((function(t) {
                    o[t] = n[t]
                }
                )),
                a && (o.options.components[a] = o),
                o.superOptions = n.options,
                o.extendOptions = t,
                o.sealedOptions = N({}, o.options),
                r[i] = o,
                o
            }
        }
        function nr(t) {
            var e = t.options.props;
            for (var n in e)
                Ui(t.prototype, "_props", n)
        }
        function ir(t) {
            var e = t.options.computed;
            for (var n in e)
                zi(t.prototype, n, e[n])
        }
        function rr(t) {
            W.forEach((function(e) {
                t[e] = function(t, n) {
                    return n ? ("component" === e && p(n) && (n.name = n.name || t,
                    n = this.options._base.extend(n)),
                    "directive" === e && u(n) && (n = {
                        bind: n,
                        update: n
                    }),
                    this.options[e + "s"][t] = n,
                    n) : this.options[e + "s"][t]
                }
            }
            ))
        }
        function ar(t) {
            return t && (ai(t.Ctor.options) || t.tag)
        }
        function or(t, e) {
            return r(t) ? t.indexOf(e) > -1 : "string" === typeof t ? t.split(",").indexOf(e) > -1 : !!f(t) && t.test(e)
        }
        function sr(t, e) {
            var n = t.cache
              , i = t.keys
              , r = t._vnode
              , a = t.$vnode;
            for (var o in n) {
                var s = n[o];
                if (s) {
                    var c = s.name;
                    c && !e(c) && cr(n, o, i, r)
                }
            }
            a.componentOptions.children = void 0
        }
        function cr(t, e, n, i) {
            var r = t[e];
            !r || i && r.tag === i.tag || r.componentInstance.$destroy(),
            t[e] = null,
            b(n, e)
        }
        $i(Ji),
        Xi(Ji),
        Tn(Ji),
        Cn(Ji),
        ke(Ji);
        var lr = [String, RegExp, Array]
          , ur = {
            name: "keep-alive",
            abstract: !0,
            props: {
                include: lr,
                exclude: lr,
                max: [String, Number]
            },
            methods: {
                cacheVNode: function() {
                    var t = this
                      , e = t.cache
                      , n = t.keys
                      , i = t.vnodeToCache
                      , r = t.keyToCache;
                    if (i) {
                        var a = i.tag
                          , o = i.componentInstance
                          , s = i.componentOptions;
                        e[r] = {
                            name: ar(s),
                            tag: a,
                            componentInstance: o
                        },
                        n.push(r),
                        this.max && n.length > parseInt(this.max) && cr(e, n[0], n, this._vnode),
                        this.vnodeToCache = null
                    }
                }
            },
            created: function() {
                this.cache = Object.create(null),
                this.keys = []
            },
            destroyed: function() {
                for (var t in this.cache)
                    cr(this.cache, t, this.keys)
            },
            mounted: function() {
                var t = this;
                this.cacheVNode(),
                this.$watch("include", (function(e) {
                    sr(t, (function(t) {
                        return or(e, t)
                    }
                    ))
                }
                )),
                this.$watch("exclude", (function(e) {
                    sr(t, (function(t) {
                        return !or(e, t)
                    }
                    ))
                }
                ))
            },
            updated: function() {
                this.cacheVNode()
            },
            render: function() {
                var t = this.$slots.default
                  , e = Ge(t)
                  , n = e && e.componentOptions;
                if (n) {
                    var i = ar(n)
                      , r = this
                      , a = r.include
                      , o = r.exclude;
                    if (a && (!i || !or(a, i)) || o && i && or(o, i))
                        return e;
                    var s = this
                      , c = s.cache
                      , l = s.keys
                      , u = null == e.key ? n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "") : e.key;
                    c[u] ? (e.componentInstance = c[u].componentInstance,
                    b(l, u),
                    l.push(u)) : (this.vnodeToCache = e,
                    this.keyToCache = u),
                    e.data.keepAlive = !0
                }
                return e || t && t[0]
            }
        }
          , hr = {
            KeepAlive: ur
        };
        function dr(t) {
            var e = {
                get: function() {
                    return q
                }
            };
            Object.defineProperty(t, "config", e),
            t.util = {
                warn: pi,
                extend: N,
                mergeOptions: Ei,
                defineReactive: kt
            },
            t.set = zt,
            t.delete = Vt,
            t.nextTick = un,
            t.observable = function(t) {
                return Bt(t),
                t
            }
            ,
            t.options = Object.create(null),
            W.forEach((function(e) {
                t.options[e + "s"] = Object.create(null)
            }
            )),
            t.options._base = t,
            N(t.options.components, hr),
            Qi(t),
            tr(t),
            er(t),
            rr(t)
        }
        dr(Ji),
        Object.defineProperty(Ji.prototype, "$isServer", {
            get: ht
        }),
        Object.defineProperty(Ji.prototype, "$ssrContext", {
            get: function() {
                return this.$vnode && this.$vnode.ssrContext
            }
        }),
        Object.defineProperty(Ji, "FunctionalRenderContext", {
            value: ei
        }),
        Ji.version = pn;
        var pr = x("style,class")
          , fr = x("input,textarea,option,select,progress")
          , mr = function(t, e, n) {
            return "value" === n && fr(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t
        }
          , gr = x("contenteditable,draggable,spellcheck")
          , vr = x("events,caret,typing,plaintext-only")
          , _r = function(t, e) {
            return Sr(e) || "false" === e ? "false" : "contenteditable" === t && vr(e) ? e : "true"
        }
          , yr = x("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible")
          , xr = "http://www.w3.org/1999/xlink"
          , Mr = function(t) {
            return ":" === t.charAt(5) && "xlink" === t.slice(0, 5)
        }
          , br = function(t) {
            return Mr(t) ? t.slice(6, t.length) : ""
        }
          , Sr = function(t) {
            return null == t || !1 === t
        };
        function Er(t) {
            var e = t.data
              , n = t
              , i = t;
            while (o(i.componentInstance))
                i = i.componentInstance._vnode,
                i && i.data && (e = Tr(i.data, e));
            while (o(n = n.parent))
                n && n.data && (e = Tr(e, n.data));
            return wr(e.staticClass, e.class)
        }
        function Tr(t, e) {
            return {
                staticClass: Ar(t.staticClass, e.staticClass),
                class: o(t.class) ? [t.class, e.class] : e.class
            }
        }
        function wr(t, e) {
            return o(t) || o(e) ? Ar(t, Rr(e)) : ""
        }
        function Ar(t, e) {
            return t ? e ? t + " " + e : t : e || ""
        }
        function Rr(t) {
            return Array.isArray(t) ? Cr(t) : h(t) ? Pr(t) : "string" === typeof t ? t : ""
        }
        function Cr(t) {
            for (var e, n = "", i = 0, r = t.length; i < r; i++)
                o(e = Rr(t[i])) && "" !== e && (n && (n += " "),
                n += e);
            return n
        }
        function Pr(t) {
            var e = "";
            for (var n in t)
                t[n] && (e && (e += " "),
                e += n);
            return e
        }
        var Lr = {
            svg: "http://www.w3.org/2000/svg",
            math: "http://www.w3.org/1998/Math/MathML"
        }
          , Ir = x("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot")
          , Ur = x("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0)
          , Dr = function(t) {
            return Ir(t) || Ur(t)
        };
        function Nr(t) {
            return Ur(t) ? "svg" : "math" === t ? "math" : void 0
        }
        var Or = Object.create(null);
        function Fr(t) {
            if (!tt)
                return !0;
            if (Dr(t))
                return !1;
            if (t = t.toLowerCase(),
            null != Or[t])
                return Or[t];
            var e = document.createElement(t);
            return t.indexOf("-") > -1 ? Or[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Or[t] = /HTMLUnknownElement/.test(e.toString())
        }
        var Br = x("text,number,password,search,email,tel,url");
        function kr(t) {
            if ("string" === typeof t) {
                var e = document.querySelector(t);
                return e || document.createElement("div")
            }
            return t
        }
        function zr(t, e) {
            var n = document.createElement(t);
            return "select" !== t || e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"),
            n
        }
        function Vr(t, e) {
            return document.createElementNS(Lr[t], e)
        }
        function Hr(t) {
            return document.createTextNode(t)
        }
        function Gr(t) {
            return document.createComment(t)
        }
        function jr(t, e, n) {
            t.insertBefore(e, n)
        }
        function Wr(t, e) {
            t.removeChild(e)
        }
        function Xr(t, e) {
            t.appendChild(e)
        }
        function qr(t) {
            return t.parentNode
        }
        function $r(t) {
            return t.nextSibling
        }
        function Yr(t) {
            return t.tagName
        }
        function Kr(t, e) {
            t.textContent = e
        }
        function Zr(t, e) {
            t.setAttribute(e, "")
        }
        var Jr = Object.freeze({
            __proto__: null,
            createElement: zr,
            createElementNS: Vr,
            createTextNode: Hr,
            createComment: Gr,
            insertBefore: jr,
            removeChild: Wr,
            appendChild: Xr,
            parentNode: qr,
            nextSibling: $r,
            tagName: Yr,
            setTextContent: Kr,
            setStyleScope: Zr
        })
          , Qr = {
            create: function(t, e) {
                ta(e)
            },
            update: function(t, e) {
                t.data.ref !== e.data.ref && (ta(t, !0),
                ta(e))
            },
            destroy: function(t) {
                ta(t, !0)
            }
        };
        function ta(t, e) {
            var n = t.data.ref;
            if (o(n)) {
                var i = t.context
                  , a = t.componentInstance || t.elm
                  , s = e ? null : a
                  , c = e ? void 0 : a;
                if (u(n))
                    Ze(n, i, [s], i, "template ref function");
                else {
                    var l = t.data.refInFor
                      , h = "string" === typeof n || "number" === typeof n
                      , d = Xt(n)
                      , p = i.$refs;
                    if (h || d)
                        if (l) {
                            var f = h ? p[n] : n.value;
                            e ? r(f) && b(f, a) : r(f) ? f.includes(a) || f.push(a) : h ? (p[n] = [a],
                            ea(i, n, p[n])) : n.value = [a]
                        } else if (h) {
                            if (e && p[n] !== a)
                                return;
                            p[n] = c,
                            ea(i, n, s)
                        } else if (d) {
                            if (e && n.value !== a)
                                return;
                            n.value = s
                        } else
                            0
                }
            }
        }
        function ea(t, e, n) {
            var i = t._setupState;
            i && E(i, e) && (Xt(i[e]) ? i[e].value = n : i[e] = n)
        }
        var na = new _t("",{},[])
          , ia = ["create", "activate", "update", "remove", "destroy"];
        function ra(t, e) {
            return t.key === e.key && t.asyncFactory === e.asyncFactory && (t.tag === e.tag && t.isComment === e.isComment && o(t.data) === o(e.data) && aa(t, e) || s(t.isAsyncPlaceholder) && a(e.asyncFactory.error))
        }
        function aa(t, e) {
            if ("input" !== t.tag)
                return !0;
            var n, i = o(n = t.data) && o(n = n.attrs) && n.type, r = o(n = e.data) && o(n = n.attrs) && n.type;
            return i === r || Br(i) && Br(r)
        }
        function oa(t, e, n) {
            var i, r, a = {};
            for (i = e; i <= n; ++i)
                r = t[i].key,
                o(r) && (a[r] = i);
            return a
        }
        function sa(t) {
            var e, n, i = {}, c = t.modules, u = t.nodeOps;
            for (e = 0; e < ia.length; ++e)
                for (i[ia[e]] = [],
                n = 0; n < c.length; ++n)
                    o(c[n][ia[e]]) && i[ia[e]].push(c[n][ia[e]]);
            function h(t) {
                return new _t(u.tagName(t).toLowerCase(),{},[],void 0,t)
            }
            function d(t, e) {
                function n() {
                    0 === --n.listeners && p(t)
                }
                return n.listeners = e,
                n
            }
            function p(t) {
                var e = u.parentNode(t);
                o(e) && u.removeChild(e, t)
            }
            function f(t, e, n, i, r, a, c) {
                if (o(t.elm) && o(a) && (t = a[c] = Mt(t)),
                t.isRootInsert = !r,
                !m(t, e, n, i)) {
                    var l = t.data
                      , h = t.children
                      , d = t.tag;
                    o(d) ? (t.elm = t.ns ? u.createElementNS(t.ns, d) : u.createElement(d, t),
                    S(t),
                    y(t, h, e),
                    o(l) && b(t, e),
                    _(n, t.elm, i)) : s(t.isComment) ? (t.elm = u.createComment(t.text),
                    _(n, t.elm, i)) : (t.elm = u.createTextNode(t.text),
                    _(n, t.elm, i))
                }
            }
            function m(t, e, n, i) {
                var r = t.data;
                if (o(r)) {
                    var a = o(t.componentInstance) && r.keepAlive;
                    if (o(r = r.hook) && o(r = r.init) && r(t, !1),
                    o(t.componentInstance))
                        return g(t, e),
                        _(n, t.elm, i),
                        s(a) && v(t, e, n, i),
                        !0
                }
            }
            function g(t, e) {
                o(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert),
                t.data.pendingInsert = null),
                t.elm = t.componentInstance.$el,
                M(t) ? (b(t, e),
                S(t)) : (ta(t),
                e.push(t))
            }
            function v(t, e, n, r) {
                var a, s = t;
                while (s.componentInstance)
                    if (s = s.componentInstance._vnode,
                    o(a = s.data) && o(a = a.transition)) {
                        for (a = 0; a < i.activate.length; ++a)
                            i.activate[a](na, s);
                        e.push(s);
                        break
                    }
                _(n, t.elm, r)
            }
            function _(t, e, n) {
                o(t) && (o(n) ? u.parentNode(n) === t && u.insertBefore(t, e, n) : u.appendChild(t, e))
            }
            function y(t, e, n) {
                if (r(e)) {
                    0;
                    for (var i = 0; i < e.length; ++i)
                        f(e[i], n, t.elm, null, !0, e, i)
                } else
                    l(t.text) && u.appendChild(t.elm, u.createTextNode(String(t.text)))
            }
            function M(t) {
                while (t.componentInstance)
                    t = t.componentInstance._vnode;
                return o(t.tag)
            }
            function b(t, n) {
                for (var r = 0; r < i.create.length; ++r)
                    i.create[r](na, t);
                e = t.data.hook,
                o(e) && (o(e.create) && e.create(na, t),
                o(e.insert) && n.push(t))
            }
            function S(t) {
                var e;
                if (o(e = t.fnScopeId))
                    u.setStyleScope(t.elm, e);
                else {
                    var n = t;
                    while (n)
                        o(e = n.context) && o(e = e.$options._scopeId) && u.setStyleScope(t.elm, e),
                        n = n.parent
                }
                o(e = wn) && e !== t.context && e !== t.fnContext && o(e = e.$options._scopeId) && u.setStyleScope(t.elm, e)
            }
            function E(t, e, n, i, r, a) {
                for (; i <= r; ++i)
                    f(n[i], a, t, e, !1, n, i)
            }
            function T(t) {
                var e, n, r = t.data;
                if (o(r))
                    for (o(e = r.hook) && o(e = e.destroy) && e(t),
                    e = 0; e < i.destroy.length; ++e)
                        i.destroy[e](t);
                if (o(e = t.children))
                    for (n = 0; n < t.children.length; ++n)
                        T(t.children[n])
            }
            function w(t, e, n) {
                for (; e <= n; ++e) {
                    var i = t[e];
                    o(i) && (o(i.tag) ? (A(i),
                    T(i)) : p(i.elm))
                }
            }
            function A(t, e) {
                if (o(e) || o(t.data)) {
                    var n, r = i.remove.length + 1;
                    for (o(e) ? e.listeners += r : e = d(t.elm, r),
                    o(n = t.componentInstance) && o(n = n._vnode) && o(n.data) && A(n, e),
                    n = 0; n < i.remove.length; ++n)
                        i.remove[n](t, e);
                    o(n = t.data.hook) && o(n = n.remove) ? n(t, e) : e()
                } else
                    p(t.elm)
            }
            function R(t, e, n, i, r) {
                var s, c, l, h, d = 0, p = 0, m = e.length - 1, g = e[0], v = e[m], _ = n.length - 1, y = n[0], x = n[_], M = !r;
                while (d <= m && p <= _)
                    a(g) ? g = e[++d] : a(v) ? v = e[--m] : ra(g, y) ? (P(g, y, i, n, p),
                    g = e[++d],
                    y = n[++p]) : ra(v, x) ? (P(v, x, i, n, _),
                    v = e[--m],
                    x = n[--_]) : ra(g, x) ? (P(g, x, i, n, _),
                    M && u.insertBefore(t, g.elm, u.nextSibling(v.elm)),
                    g = e[++d],
                    x = n[--_]) : ra(v, y) ? (P(v, y, i, n, p),
                    M && u.insertBefore(t, v.elm, g.elm),
                    v = e[--m],
                    y = n[++p]) : (a(s) && (s = oa(e, d, m)),
                    c = o(y.key) ? s[y.key] : C(y, e, d, m),
                    a(c) ? f(y, i, t, g.elm, !1, n, p) : (l = e[c],
                    ra(l, y) ? (P(l, y, i, n, p),
                    e[c] = void 0,
                    M && u.insertBefore(t, l.elm, g.elm)) : f(y, i, t, g.elm, !1, n, p)),
                    y = n[++p]);
                d > m ? (h = a(n[_ + 1]) ? null : n[_ + 1].elm,
                E(t, h, n, p, _, i)) : p > _ && w(e, d, m)
            }
            function C(t, e, n, i) {
                for (var r = n; r < i; r++) {
                    var a = e[r];
                    if (o(a) && ra(t, a))
                        return r
                }
            }
            function P(t, e, n, r, c, l) {
                if (t !== e) {
                    o(e.elm) && o(r) && (e = r[c] = Mt(e));
                    var h = e.elm = t.elm;
                    if (s(t.isAsyncPlaceholder))
                        o(e.asyncFactory.resolved) ? U(t.elm, e, n) : e.isAsyncPlaceholder = !0;
                    else if (s(e.isStatic) && s(t.isStatic) && e.key === t.key && (s(e.isCloned) || s(e.isOnce)))
                        e.componentInstance = t.componentInstance;
                    else {
                        var d, p = e.data;
                        o(p) && o(d = p.hook) && o(d = d.prepatch) && d(t, e);
                        var f = t.children
                          , m = e.children;
                        if (o(p) && M(e)) {
                            for (d = 0; d < i.update.length; ++d)
                                i.update[d](t, e);
                            o(d = p.hook) && o(d = d.update) && d(t, e)
                        }
                        a(e.text) ? o(f) && o(m) ? f !== m && R(h, f, m, n, l) : o(m) ? (o(t.text) && u.setTextContent(h, ""),
                        E(h, null, m, 0, m.length - 1, n)) : o(f) ? w(f, 0, f.length - 1) : o(t.text) && u.setTextContent(h, "") : t.text !== e.text && u.setTextContent(h, e.text),
                        o(p) && o(d = p.hook) && o(d = d.postpatch) && d(t, e)
                    }
                }
            }
            function L(t, e, n) {
                if (s(n) && o(t.parent))
                    t.parent.data.pendingInsert = e;
                else
                    for (var i = 0; i < e.length; ++i)
                        e[i].data.hook.insert(e[i])
            }
            var I = x("attrs,class,staticClass,staticStyle,key");
            function U(t, e, n, i) {
                var r, a = e.tag, c = e.data, l = e.children;
                if (i = i || c && c.pre,
                e.elm = t,
                s(e.isComment) && o(e.asyncFactory))
                    return e.isAsyncPlaceholder = !0,
                    !0;
                if (o(c) && (o(r = c.hook) && o(r = r.init) && r(e, !0),
                o(r = e.componentInstance)))
                    return g(e, n),
                    !0;
                if (o(a)) {
                    if (o(l))
                        if (t.hasChildNodes())
                            if (o(r = c) && o(r = r.domProps) && o(r = r.innerHTML)) {
                                if (r !== t.innerHTML)
                                    return !1
                            } else {
                                for (var u = !0, h = t.firstChild, d = 0; d < l.length; d++) {
                                    if (!h || !U(h, l[d], n, i)) {
                                        u = !1;
                                        break
                                    }
                                    h = h.nextSibling
                                }
                                if (!u || h)
                                    return !1
                            }
                        else
                            y(e, l, n);
                    if (o(c)) {
                        var p = !1;
                        for (var f in c)
                            if (!I(f)) {
                                p = !0,
                                b(e, n);
                                break
                            }
                        !p && c["class"] && mn(c["class"])
                    }
                } else
                    t.data !== e.text && (t.data = e.text);
                return !0
            }
            return function(t, e, n, r) {
                if (!a(e)) {
                    var c = !1
                      , l = [];
                    if (a(t))
                        c = !0,
                        f(e, l);
                    else {
                        var d = o(t.nodeType);
                        if (!d && ra(t, e))
                            P(t, e, l, null, null, r);
                        else {
                            if (d) {
                                if (1 === t.nodeType && t.hasAttribute(j) && (t.removeAttribute(j),
                                n = !0),
                                s(n) && U(t, e, l))
                                    return L(e, l, !0),
                                    t;
                                t = h(t)
                            }
                            var p = t.elm
                              , m = u.parentNode(p);
                            if (f(e, l, p._leaveCb ? null : m, u.nextSibling(p)),
                            o(e.parent)) {
                                var g = e.parent
                                  , v = M(e);
                                while (g) {
                                    for (var _ = 0; _ < i.destroy.length; ++_)
                                        i.destroy[_](g);
                                    if (g.elm = e.elm,
                                    v) {
                                        for (var y = 0; y < i.create.length; ++y)
                                            i.create[y](na, g);
                                        var x = g.data.hook.insert;
                                        if (x.merged)
                                            for (var b = x.fns.slice(1), S = 0; S < b.length; S++)
                                                b[S]()
                                    } else
                                        ta(g);
                                    g = g.parent
                                }
                            }
                            o(m) ? w([t], 0, 0) : o(t.tag) && T(t)
                        }
                    }
                    return L(e, l, c),
                    e.elm
                }
                o(t) && T(t)
            }
        }
        var ca = {
            create: la,
            update: la,
            destroy: function(t) {
                la(t, na)
            }
        };
        function la(t, e) {
            (t.data.directives || e.data.directives) && ua(t, e)
        }
        function ua(t, e) {
            var n, i, r, a = t === na, o = e === na, s = da(t.data.directives, t.context), c = da(e.data.directives, e.context), l = [], u = [];
            for (n in c)
                i = s[n],
                r = c[n],
                i ? (r.oldValue = i.value,
                r.oldArg = i.arg,
                fa(r, "update", e, t),
                r.def && r.def.componentUpdated && u.push(r)) : (fa(r, "bind", e, t),
                r.def && r.def.inserted && l.push(r));
            if (l.length) {
                var h = function() {
                    for (var n = 0; n < l.length; n++)
                        fa(l[n], "inserted", e, t)
                };
                a ? ie(e, "insert", h) : h()
            }
            if (u.length && ie(e, "postpatch", (function() {
                for (var n = 0; n < u.length; n++)
                    fa(u[n], "componentUpdated", e, t)
            }
            )),
            !a)
                for (n in s)
                    c[n] || fa(s[n], "unbind", t, t, o)
        }
        var ha = Object.create(null);
        function da(t, e) {
            var n, i, r = Object.create(null);
            if (!t)
                return r;
            for (n = 0; n < t.length; n++) {
                if (i = t[n],
                i.modifiers || (i.modifiers = ha),
                r[pa(i)] = i,
                e._setupState && e._setupState.__sfc) {
                    var a = i.def || Ti(e, "_setupState", "v-" + i.name);
                    i.def = "function" === typeof a ? {
                        bind: a,
                        update: a
                    } : a
                }
                i.def = i.def || Ti(e.$options, "directives", i.name, !0)
            }
            return r
        }
        function pa(t) {
            return t.rawName || "".concat(t.name, ".").concat(Object.keys(t.modifiers || {}).join("."))
        }
        function fa(t, e, n, i, r) {
            var a = t.def && t.def[e];
            if (a)
                try {
                    a(n.elm, t, n, i, r)
                } catch (Qo) {
                    Ke(Qo, n.context, "directive ".concat(t.name, " ").concat(e, " hook"))
                }
        }
        var ma = [Qr, ca];
        function ga(t, e) {
            var n = e.componentOptions;
            if ((!o(n) || !1 !== n.Ctor.options.inheritAttrs) && (!a(t.data.attrs) || !a(e.data.attrs))) {
                var i, r, c, l = e.elm, u = t.data.attrs || {}, h = e.data.attrs || {};
                for (i in (o(h.__ob__) || s(h._v_attr_proxy)) && (h = e.data.attrs = N({}, h)),
                h)
                    r = h[i],
                    c = u[i],
                    c !== r && va(l, i, r, e.data.pre);
                for (i in (nt || rt) && h.value !== u.value && va(l, "value", h.value),
                u)
                    a(h[i]) && (Mr(i) ? l.removeAttributeNS(xr, br(i)) : gr(i) || l.removeAttribute(i))
            }
        }
        function va(t, e, n, i) {
            i || t.tagName.indexOf("-") > -1 ? _a(t, e, n) : yr(e) ? Sr(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e,
            t.setAttribute(e, n)) : gr(e) ? t.setAttribute(e, _r(e, n)) : Mr(e) ? Sr(n) ? t.removeAttributeNS(xr, br(e)) : t.setAttributeNS(xr, e, n) : _a(t, e, n)
        }
        function _a(t, e, n) {
            if (Sr(n))
                t.removeAttribute(e);
            else {
                if (nt && !it && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
                    var i = function(e) {
                        e.stopImmediatePropagation(),
                        t.removeEventListener("input", i)
                    };
                    t.addEventListener("input", i),
                    t.__ieph = !0
                }
                t.setAttribute(e, n)
            }
        }
        var ya = {
            create: ga,
            update: ga
        };
        function xa(t, e) {
            var n = e.elm
              , i = e.data
              , r = t.data;
            if (!(a(i.staticClass) && a(i.class) && (a(r) || a(r.staticClass) && a(r.class)))) {
                var s = Er(e)
                  , c = n._transitionClasses;
                o(c) && (s = Ar(s, Rr(c))),
                s !== n._prevClass && (n.setAttribute("class", s),
                n._prevClass = s)
            }
        }
        var Ma, ba = {
            create: xa,
            update: xa
        }, Sa = "__r", Ea = "__c";
        function Ta(t) {
            if (o(t[Sa])) {
                var e = nt ? "change" : "input";
                t[e] = [].concat(t[Sa], t[e] || []),
                delete t[Sa]
            }
            o(t[Ea]) && (t.change = [].concat(t[Ea], t.change || []),
            delete t[Ea])
        }
        function wa(t, e, n) {
            var i = Ma;
            return function r() {
                var a = e.apply(null, arguments);
                null !== a && Ca(t, r, n, i)
            }
        }
        var Aa = en && !(st && Number(st[1]) <= 53);
        function Ra(t, e, n, i) {
            if (Aa) {
                var r = Gn
                  , a = e;
                e = a._wrapper = function(t) {
                    if (t.target === t.currentTarget || t.timeStamp >= r || t.timeStamp <= 0 || t.target.ownerDocument !== document)
                        return a.apply(this, arguments)
                }
            }
            Ma.addEventListener(t, e, lt ? {
                capture: n,
                passive: i
            } : n)
        }
        function Ca(t, e, n, i) {
            (i || Ma).removeEventListener(t, e._wrapper || e, n)
        }
        function Pa(t, e) {
            if (!a(t.data.on) || !a(e.data.on)) {
                var n = e.data.on || {}
                  , i = t.data.on || {};
                Ma = e.elm || t.elm,
                Ta(n),
                ne(n, i, Ra, Ca, wa, e.context),
                Ma = void 0
            }
        }
        var La, Ia = {
            create: Pa,
            update: Pa,
            destroy: function(t) {
                return Pa(t, na)
            }
        };
        function Ua(t, e) {
            if (!a(t.data.domProps) || !a(e.data.domProps)) {
                var n, i, r = e.elm, c = t.data.domProps || {}, l = e.data.domProps || {};
                for (n in (o(l.__ob__) || s(l._v_attr_proxy)) && (l = e.data.domProps = N({}, l)),
                c)
                    n in l || (r[n] = "");
                for (n in l) {
                    if (i = l[n],
                    "textContent" === n || "innerHTML" === n) {
                        if (e.children && (e.children.length = 0),
                        i === c[n])
                            continue;
                        1 === r.childNodes.length && r.removeChild(r.childNodes[0])
                    }
                    if ("value" === n && "PROGRESS" !== r.tagName) {
                        r._value = i;
                        var u = a(i) ? "" : String(i);
                        Da(r, u) && (r.value = u)
                    } else if ("innerHTML" === n && Ur(r.tagName) && a(r.innerHTML)) {
                        La = La || document.createElement("div"),
                        La.innerHTML = "<svg>".concat(i, "</svg>");
                        var h = La.firstChild;
                        while (r.firstChild)
                            r.removeChild(r.firstChild);
                        while (h.firstChild)
                            r.appendChild(h.firstChild)
                    } else if (i !== c[n])
                        try {
                            r[n] = i
                        } catch (Qo) {}
                }
            }
        }
        function Da(t, e) {
            return !t.composing && ("OPTION" === t.tagName || Na(t, e) || Oa(t, e))
        }
        function Na(t, e) {
            var n = !0;
            try {
                n = document.activeElement !== t
            } catch (Qo) {}
            return n && t.value !== e
        }
        function Oa(t, e) {
            var n = t.value
              , i = t._vModifiers;
            if (o(i)) {
                if (i.number)
                    return y(n) !== y(e);
                if (i.trim)
                    return n.trim() !== e.trim()
            }
            return n !== e
        }
        var Fa = {
            create: Ua,
            update: Ua
        }
          , Ba = T((function(t) {
            var e = {}
              , n = /;(?![^(]*\))/g
              , i = /:(.+)/;
            return t.split(n).forEach((function(t) {
                if (t) {
                    var n = t.split(i);
                    n.length > 1 && (e[n[0].trim()] = n[1].trim())
                }
            }
            )),
            e
        }
        ));
        function ka(t) {
            var e = za(t.style);
            return t.staticStyle ? N(t.staticStyle, e) : e
        }
        function za(t) {
            return Array.isArray(t) ? O(t) : "string" === typeof t ? Ba(t) : t
        }
        function Va(t, e) {
            var n, i = {};
            if (e) {
                var r = t;
                while (r.componentInstance)
                    r = r.componentInstance._vnode,
                    r && r.data && (n = ka(r.data)) && N(i, n)
            }
            (n = ka(t.data)) && N(i, n);
            var a = t;
            while (a = a.parent)
                a.data && (n = ka(a.data)) && N(i, n);
            return i
        }
        var Ha, Ga = /^--/, ja = /\s*!important$/, Wa = function(t, e, n) {
            if (Ga.test(e))
                t.style.setProperty(e, n);
            else if (ja.test(n))
                t.style.setProperty(P(e), n.replace(ja, ""), "important");
            else {
                var i = qa(e);
                if (Array.isArray(n))
                    for (var r = 0, a = n.length; r < a; r++)
                        t.style[i] = n[r];
                else
                    t.style[i] = n
            }
        }, Xa = ["Webkit", "Moz", "ms"], qa = T((function(t) {
            if (Ha = Ha || document.createElement("div").style,
            t = A(t),
            "filter" !== t && t in Ha)
                return t;
            for (var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < Xa.length; n++) {
                var i = Xa[n] + e;
                if (i in Ha)
                    return i
            }
        }
        ));
        function $a(t, e) {
            var n = e.data
              , i = t.data;
            if (!(a(n.staticStyle) && a(n.style) && a(i.staticStyle) && a(i.style))) {
                var r, s, c = e.elm, l = i.staticStyle, u = i.normalizedStyle || i.style || {}, h = l || u, d = za(e.data.style) || {};
                e.data.normalizedStyle = o(d.__ob__) ? N({}, d) : d;
                var p = Va(e, !0);
                for (s in h)
                    a(p[s]) && Wa(c, s, "");
                for (s in p)
                    r = p[s],
                    Wa(c, s, null == r ? "" : r)
            }
        }
        var Ya = {
            create: $a,
            update: $a
        }
          , Ka = /\s+/;
        function Za(t, e) {
            if (e && (e = e.trim()))
                if (t.classList)
                    e.indexOf(" ") > -1 ? e.split(Ka).forEach((function(e) {
                        return t.classList.add(e)
                    }
                    )) : t.classList.add(e);
                else {
                    var n = " ".concat(t.getAttribute("class") || "", " ");
                    n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim())
                }
        }
        function Ja(t, e) {
            if (e && (e = e.trim()))
                if (t.classList)
                    e.indexOf(" ") > -1 ? e.split(Ka).forEach((function(e) {
                        return t.classList.remove(e)
                    }
                    )) : t.classList.remove(e),
                    t.classList.length || t.removeAttribute("class");
                else {
                    var n = " ".concat(t.getAttribute("class") || "", " ")
                      , i = " " + e + " ";
                    while (n.indexOf(i) >= 0)
                        n = n.replace(i, " ");
                    n = n.trim(),
                    n ? t.setAttribute("class", n) : t.removeAttribute("class")
                }
        }
        function Qa(t) {
            if (t) {
                if ("object" === typeof t) {
                    var e = {};
                    return !1 !== t.css && N(e, to(t.name || "v")),
                    N(e, t),
                    e
                }
                return "string" === typeof t ? to(t) : void 0
            }
        }
        var to = T((function(t) {
            return {
                enterClass: "".concat(t, "-enter"),
                enterToClass: "".concat(t, "-enter-to"),
                enterActiveClass: "".concat(t, "-enter-active"),
                leaveClass: "".concat(t, "-leave"),
                leaveToClass: "".concat(t, "-leave-to"),
                leaveActiveClass: "".concat(t, "-leave-active")
            }
        }
        ))
          , eo = tt && !it
          , no = "transition"
          , io = "animation"
          , ro = "transition"
          , ao = "transitionend"
          , oo = "animation"
          , so = "animationend";
        eo && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (ro = "WebkitTransition",
        ao = "webkitTransitionEnd"),
        void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (oo = "WebkitAnimation",
        so = "webkitAnimationEnd"));
        var co = tt ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(t) {
            return t()
        }
        ;
        function lo(t) {
            co((function() {
                co(t)
            }
            ))
        }
        function uo(t, e) {
            var n = t._transitionClasses || (t._transitionClasses = []);
            n.indexOf(e) < 0 && (n.push(e),
            Za(t, e))
        }
        function ho(t, e) {
            t._transitionClasses && b(t._transitionClasses, e),
            Ja(t, e)
        }
        function po(t, e, n) {
            var i = mo(t, e)
              , r = i.type
              , a = i.timeout
              , o = i.propCount;
            if (!r)
                return n();
            var s = r === no ? ao : so
              , c = 0
              , l = function() {
                t.removeEventListener(s, u),
                n()
            }
              , u = function(e) {
                e.target === t && ++c >= o && l()
            };
            setTimeout((function() {
                c < o && l()
            }
            ), a + 1),
            t.addEventListener(s, u)
        }
        var fo = /\b(transform|all)(,|$)/;
        function mo(t, e) {
            var n, i = window.getComputedStyle(t), r = (i[ro + "Delay"] || "").split(", "), a = (i[ro + "Duration"] || "").split(", "), o = go(r, a), s = (i[oo + "Delay"] || "").split(", "), c = (i[oo + "Duration"] || "").split(", "), l = go(s, c), u = 0, h = 0;
            e === no ? o > 0 && (n = no,
            u = o,
            h = a.length) : e === io ? l > 0 && (n = io,
            u = l,
            h = c.length) : (u = Math.max(o, l),
            n = u > 0 ? o > l ? no : io : null,
            h = n ? n === no ? a.length : c.length : 0);
            var d = n === no && fo.test(i[ro + "Property"]);
            return {
                type: n,
                timeout: u,
                propCount: h,
                hasTransform: d
            }
        }
        function go(t, e) {
            while (t.length < e.length)
                t = t.concat(t);
            return Math.max.apply(null, e.map((function(e, n) {
                return vo(e) + vo(t[n])
            }
            )))
        }
        function vo(t) {
            return 1e3 * Number(t.slice(0, -1).replace(",", "."))
        }
        function _o(t, e) {
            var n = t.elm;
            o(n._leaveCb) && (n._leaveCb.cancelled = !0,
            n._leaveCb());
            var i = Qa(t.data.transition);
            if (!a(i) && !o(n._enterCb) && 1 === n.nodeType) {
                var r = i.css
                  , s = i.type
                  , c = i.enterClass
                  , l = i.enterToClass
                  , d = i.enterActiveClass
                  , p = i.appearClass
                  , f = i.appearToClass
                  , m = i.appearActiveClass
                  , g = i.beforeEnter
                  , v = i.enter
                  , _ = i.afterEnter
                  , x = i.enterCancelled
                  , M = i.beforeAppear
                  , b = i.appear
                  , S = i.afterAppear
                  , E = i.appearCancelled
                  , T = i.duration
                  , w = wn
                  , A = wn.$vnode;
                while (A && A.parent)
                    w = A.context,
                    A = A.parent;
                var R = !w._isMounted || !t.isRootInsert;
                if (!R || b || "" === b) {
                    var C = R && p ? p : c
                      , P = R && m ? m : d
                      , L = R && f ? f : l
                      , I = R && M || g
                      , U = R && u(b) ? b : v
                      , D = R && S || _
                      , N = R && E || x
                      , O = y(h(T) ? T.enter : T);
                    0;
                    var F = !1 !== r && !it
                      , B = Mo(U)
                      , k = n._enterCb = H((function() {
                        F && (ho(n, L),
                        ho(n, P)),
                        k.cancelled ? (F && ho(n, C),
                        N && N(n)) : D && D(n),
                        n._enterCb = null
                    }
                    ));
                    t.data.show || ie(t, "insert", (function() {
                        var e = n.parentNode
                          , i = e && e._pending && e._pending[t.key];
                        i && i.tag === t.tag && i.elm._leaveCb && i.elm._leaveCb(),
                        U && U(n, k)
                    }
                    )),
                    I && I(n),
                    F && (uo(n, C),
                    uo(n, P),
                    lo((function() {
                        ho(n, C),
                        k.cancelled || (uo(n, L),
                        B || (xo(O) ? setTimeout(k, O) : po(n, s, k)))
                    }
                    ))),
                    t.data.show && (e && e(),
                    U && U(n, k)),
                    F || B || k()
                }
            }
        }
        function yo(t, e) {
            var n = t.elm;
            o(n._enterCb) && (n._enterCb.cancelled = !0,
            n._enterCb());
            var i = Qa(t.data.transition);
            if (a(i) || 1 !== n.nodeType)
                return e();
            if (!o(n._leaveCb)) {
                var r = i.css
                  , s = i.type
                  , c = i.leaveClass
                  , l = i.leaveToClass
                  , u = i.leaveActiveClass
                  , d = i.beforeLeave
                  , p = i.leave
                  , f = i.afterLeave
                  , m = i.leaveCancelled
                  , g = i.delayLeave
                  , v = i.duration
                  , _ = !1 !== r && !it
                  , x = Mo(p)
                  , M = y(h(v) ? v.leave : v);
                0;
                var b = n._leaveCb = H((function() {
                    n.parentNode && n.parentNode._pending && (n.parentNode._pending[t.key] = null),
                    _ && (ho(n, l),
                    ho(n, u)),
                    b.cancelled ? (_ && ho(n, c),
                    m && m(n)) : (e(),
                    f && f(n)),
                    n._leaveCb = null
                }
                ));
                g ? g(S) : S()
            }
            function S() {
                b.cancelled || (!t.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[t.key] = t),
                d && d(n),
                _ && (uo(n, c),
                uo(n, u),
                lo((function() {
                    ho(n, c),
                    b.cancelled || (uo(n, l),
                    x || (xo(M) ? setTimeout(b, M) : po(n, s, b)))
                }
                ))),
                p && p(n, b),
                _ || x || b())
            }
        }
        function xo(t) {
            return "number" === typeof t && !isNaN(t)
        }
        function Mo(t) {
            if (a(t))
                return !1;
            var e = t.fns;
            return o(e) ? Mo(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1
        }
        function bo(t, e) {
            !0 !== e.data.show && _o(e)
        }
        var So = tt ? {
            create: bo,
            activate: bo,
            remove: function(t, e) {
                !0 !== t.data.show ? yo(t, e) : e()
            }
        } : {}
          , Eo = [ya, ba, Ia, Fa, Ya, So]
          , To = Eo.concat(ma)
          , wo = sa({
            nodeOps: Jr,
            modules: To
        });
        it && document.addEventListener("selectionchange", (function() {
            var t = document.activeElement;
            t && t.vmodel && Do(t, "input")
        }
        ));
        var Ao = {
            inserted: function(t, e, n, i) {
                "select" === n.tag ? (i.elm && !i.elm._vOptions ? ie(n, "postpatch", (function() {
                    Ao.componentUpdated(t, e, n)
                }
                )) : Ro(t, e, n.context),
                t._vOptions = [].map.call(t.options, Lo)) : ("textarea" === n.tag || Br(t.type)) && (t._vModifiers = e.modifiers,
                e.modifiers.lazy || (t.addEventListener("compositionstart", Io),
                t.addEventListener("compositionend", Uo),
                t.addEventListener("change", Uo),
                it && (t.vmodel = !0)))
            },
            componentUpdated: function(t, e, n) {
                if ("select" === n.tag) {
                    Ro(t, e, n.context);
                    var i = t._vOptions
                      , r = t._vOptions = [].map.call(t.options, Lo);
                    if (r.some((function(t, e) {
                        return !z(t, i[e])
                    }
                    ))) {
                        var a = t.multiple ? e.value.some((function(t) {
                            return Po(t, r)
                        }
                        )) : e.value !== e.oldValue && Po(e.value, r);
                        a && Do(t, "change")
                    }
                }
            }
        };
        function Ro(t, e, n) {
            Co(t, e, n),
            (nt || rt) && setTimeout((function() {
                Co(t, e, n)
            }
            ), 0)
        }
        function Co(t, e, n) {
            var i = e.value
              , r = t.multiple;
            if (!r || Array.isArray(i)) {
                for (var a, o, s = 0, c = t.options.length; s < c; s++)
                    if (o = t.options[s],
                    r)
                        a = V(i, Lo(o)) > -1,
                        o.selected !== a && (o.selected = a);
                    else if (z(Lo(o), i))
                        return void (t.selectedIndex !== s && (t.selectedIndex = s));
                r || (t.selectedIndex = -1)
            }
        }
        function Po(t, e) {
            return e.every((function(e) {
                return !z(e, t)
            }
            ))
        }
        function Lo(t) {
            return "_value"in t ? t._value : t.value
        }
        function Io(t) {
            t.target.composing = !0
        }
        function Uo(t) {
            t.target.composing && (t.target.composing = !1,
            Do(t.target, "input"))
        }
        function Do(t, e) {
            var n = document.createEvent("HTMLEvents");
            n.initEvent(e, !0, !0),
            t.dispatchEvent(n)
        }
        function No(t) {
            return !t.componentInstance || t.data && t.data.transition ? t : No(t.componentInstance._vnode)
        }
        var Oo = {
            bind: function(t, e, n) {
                var i = e.value;
                n = No(n);
                var r = n.data && n.data.transition
                  , a = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
                i && r ? (n.data.show = !0,
                _o(n, (function() {
                    t.style.display = a
                }
                ))) : t.style.display = i ? a : "none"
            },
            update: function(t, e, n) {
                var i = e.value
                  , r = e.oldValue;
                if (!i !== !r) {
                    n = No(n);
                    var a = n.data && n.data.transition;
                    a ? (n.data.show = !0,
                    i ? _o(n, (function() {
                        t.style.display = t.__vOriginalDisplay
                    }
                    )) : yo(n, (function() {
                        t.style.display = "none"
                    }
                    ))) : t.style.display = i ? t.__vOriginalDisplay : "none"
                }
            },
            unbind: function(t, e, n, i, r) {
                r || (t.style.display = t.__vOriginalDisplay)
            }
        }
          , Fo = {
            model: Ao,
            show: Oo
        }
          , Bo = {
            name: String,
            appear: Boolean,
            css: Boolean,
            mode: String,
            type: String,
            enterClass: String,
            leaveClass: String,
            enterToClass: String,
            leaveToClass: String,
            enterActiveClass: String,
            leaveActiveClass: String,
            appearClass: String,
            appearActiveClass: String,
            appearToClass: String,
            duration: [Number, String, Object]
        };
        function ko(t) {
            var e = t && t.componentOptions;
            return e && e.Ctor.options.abstract ? ko(Ge(e.children)) : t
        }
        function zo(t) {
            var e = {}
              , n = t.$options;
            for (var i in n.propsData)
                e[i] = t[i];
            var r = n._parentListeners;
            for (var i in r)
                e[A(i)] = r[i];
            return e
        }
        function Vo(t, e) {
            if (/\d-keep-alive$/.test(e.tag))
                return t("keep-alive", {
                    props: e.componentOptions.propsData
                })
        }
        function Ho(t) {
            while (t = t.parent)
                if (t.data.transition)
                    return !0
        }
        function Go(t, e) {
            return e.key === t.key && e.tag === t.tag
        }
        var jo = function(t) {
            return t.tag || Ae(t)
        }
          , Wo = function(t) {
            return "show" === t.name
        }
          , Xo = {
            name: "transition",
            props: Bo,
            abstract: !0,
            render: function(t) {
                var e = this
                  , n = this.$slots.default;
                if (n && (n = n.filter(jo),
                n.length)) {
                    0;
                    var i = this.mode;
                    0;
                    var r = n[0];
                    if (Ho(this.$vnode))
                        return r;
                    var a = ko(r);
                    if (!a)
                        return r;
                    if (this._leaving)
                        return Vo(t, r);
                    var o = "__transition-".concat(this._uid, "-");
                    a.key = null == a.key ? a.isComment ? o + "comment" : o + a.tag : l(a.key) ? 0 === String(a.key).indexOf(o) ? a.key : o + a.key : a.key;
                    var s = (a.data || (a.data = {})).transition = zo(this)
                      , c = this._vnode
                      , u = ko(c);
                    if (a.data.directives && a.data.directives.some(Wo) && (a.data.show = !0),
                    u && u.data && !Go(a, u) && !Ae(u) && (!u.componentInstance || !u.componentInstance._vnode.isComment)) {
                        var h = u.data.transition = N({}, s);
                        if ("out-in" === i)
                            return this._leaving = !0,
                            ie(h, "afterLeave", (function() {
                                e._leaving = !1,
                                e.$forceUpdate()
                            }
                            )),
                            Vo(t, r);
                        if ("in-out" === i) {
                            if (Ae(a))
                                return c;
                            var d, p = function() {
                                d()
                            };
                            ie(s, "afterEnter", p),
                            ie(s, "enterCancelled", p),
                            ie(h, "delayLeave", (function(t) {
                                d = t
                            }
                            ))
                        }
                    }
                    return r
                }
            }
        }
          , qo = N({
            tag: String,
            moveClass: String
        }, Bo);
        delete qo.mode;
        var $o = {
            props: qo,
            beforeMount: function() {
                var t = this
                  , e = this._update;
                this._update = function(n, i) {
                    var r = An(t);
                    t.__patch__(t._vnode, t.kept, !1, !0),
                    t._vnode = t.kept,
                    r(),
                    e.call(t, n, i)
                }
            },
            render: function(t) {
                for (var e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), i = this.prevChildren = this.children, r = this.$slots.default || [], a = this.children = [], o = zo(this), s = 0; s < r.length; s++) {
                    var c = r[s];
                    if (c.tag)
                        if (null != c.key && 0 !== String(c.key).indexOf("__vlist"))
                            a.push(c),
                            n[c.key] = c,
                            (c.data || (c.data = {})).transition = o;
                        else
                            ;
                }
                if (i) {
                    var l = []
                      , u = [];
                    for (s = 0; s < i.length; s++) {
                        c = i[s];
                        c.data.transition = o,
                        c.data.pos = c.elm.getBoundingClientRect(),
                        n[c.key] ? l.push(c) : u.push(c)
                    }
                    this.kept = t(e, null, l),
                    this.removed = u
                }
                return t(e, null, a)
            },
            updated: function() {
                var t = this.prevChildren
                  , e = this.moveClass || (this.name || "v") + "-move";
                t.length && this.hasMove(t[0].elm, e) && (t.forEach(Yo),
                t.forEach(Ko),
                t.forEach(Zo),
                this._reflow = document.body.offsetHeight,
                t.forEach((function(t) {
                    if (t.data.moved) {
                        var n = t.elm
                          , i = n.style;
                        uo(n, e),
                        i.transform = i.WebkitTransform = i.transitionDuration = "",
                        n.addEventListener(ao, n._moveCb = function t(i) {
                            i && i.target !== n || i && !/transform$/.test(i.propertyName) || (n.removeEventListener(ao, t),
                            n._moveCb = null,
                            ho(n, e))
                        }
                        )
                    }
                }
                )))
            },
            methods: {
                hasMove: function(t, e) {
                    if (!eo)
                        return !1;
                    if (this._hasMove)
                        return this._hasMove;
                    var n = t.cloneNode();
                    t._transitionClasses && t._transitionClasses.forEach((function(t) {
                        Ja(n, t)
                    }
                    )),
                    Za(n, e),
                    n.style.display = "none",
                    this.$el.appendChild(n);
                    var i = mo(n);
                    return this.$el.removeChild(n),
                    this._hasMove = i.hasTransform
                }
            }
        };
        function Yo(t) {
            t.elm._moveCb && t.elm._moveCb(),
            t.elm._enterCb && t.elm._enterCb()
        }
        function Ko(t) {
            t.data.newPos = t.elm.getBoundingClientRect()
        }
        function Zo(t) {
            var e = t.data.pos
              , n = t.data.newPos
              , i = e.left - n.left
              , r = e.top - n.top;
            if (i || r) {
                t.data.moved = !0;
                var a = t.elm.style;
                a.transform = a.WebkitTransform = "translate(".concat(i, "px,").concat(r, "px)"),
                a.transitionDuration = "0s"
            }
        }
        var Jo = {
            Transition: Xo,
            TransitionGroup: $o
        };
        Ji.config.mustUseProp = mr,
        Ji.config.isReservedTag = Dr,
        Ji.config.isReservedAttr = pr,
        Ji.config.getTagNamespace = Nr,
        Ji.config.isUnknownElement = Fr,
        N(Ji.options.directives, Fo),
        N(Ji.options.components, Jo),
        Ji.prototype.__patch__ = tt ? wo : F,
        Ji.prototype.$mount = function(t, e) {
            return t = t && tt ? kr(t) : void 0,
            Pn(this, t, e)
        }
        ,
        tt && setTimeout((function() {
            q.devtools && dt && dt.emit("init", Ji)
        }
        ), 0)
    },
    1910: function(t, e, n) {
        n(4114);
        /*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
        function i(t) {
            var e = Number(t.version.split(".")[0]);
            if (e >= 2)
                t.mixin({
                    beforeCreate: i
                });
            else {
                var n = t.prototype._init;
                t.prototype._init = function(t) {
                    void 0 === t && (t = {}),
                    t.init = t.init ? [i].concat(t.init) : i,
                    n.call(this, t)
                }
            }
            function i() {
                var t = this.$options;
                t.store ? this.$store = "function" === typeof t.store ? t.store() : t.store : t.parent && t.parent.$store && (this.$store = t.parent.$store)
            }
        }
        var r = "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : {}
          , a = r.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        function o(t) {
            a && (t._devtoolHook = a,
            a.emit("vuex:init", t),
            a.on("vuex:travel-to-state", (function(e) {
                t.replaceState(e)
            }
            )),
            t.subscribe((function(t, e) {
                a.emit("vuex:mutation", t, e)
            }
            ), {
                prepend: !0
            }),
            t.subscribeAction((function(t, e) {
                a.emit("vuex:action", t, e)
            }
            ), {
                prepend: !0
            }))
        }
        function s(t, e) {
            return t.filter(e)[0]
        }
        function c(t, e) {
            if (void 0 === e && (e = []),
            null === t || "object" !== typeof t)
                return t;
            var n = s(e, (function(e) {
                return e.original === t
            }
            ));
            if (n)
                return n.copy;
            var i = Array.isArray(t) ? [] : {};
            return e.push({
                original: t,
                copy: i
            }),
            Object.keys(t).forEach((function(n) {
                i[n] = c(t[n], e)
            }
            )),
            i
        }
        function l(t, e) {
            Object.keys(t).forEach((function(n) {
                return e(t[n], n)
            }
            ))
        }
        function u(t) {
            return null !== t && "object" === typeof t
        }
        function h(t) {
            return t && "function" === typeof t.then
        }
        function d(t, e) {
            return function() {
                return t(e)
            }
        }
        var p = function(t, e) {
            this.runtime = e,
            this._children = Object.create(null),
            this._rawModule = t;
            var n = t.state;
            this.state = ("function" === typeof n ? n() : n) || {}
        }
          , f = {
            namespaced: {
                configurable: !0
            }
        };
        f.namespaced.get = function() {
            return !!this._rawModule.namespaced
        }
        ,
        p.prototype.addChild = function(t, e) {
            this._children[t] = e
        }
        ,
        p.prototype.removeChild = function(t) {
            delete this._children[t]
        }
        ,
        p.prototype.getChild = function(t) {
            return this._children[t]
        }
        ,
        p.prototype.hasChild = function(t) {
            return t in this._children
        }
        ,
        p.prototype.update = function(t) {
            this._rawModule.namespaced = t.namespaced,
            t.actions && (this._rawModule.actions = t.actions),
            t.mutations && (this._rawModule.mutations = t.mutations),
            t.getters && (this._rawModule.getters = t.getters)
        }
        ,
        p.prototype.forEachChild = function(t) {
            l(this._children, t)
        }
        ,
        p.prototype.forEachGetter = function(t) {
            this._rawModule.getters && l(this._rawModule.getters, t)
        }
        ,
        p.prototype.forEachAction = function(t) {
            this._rawModule.actions && l(this._rawModule.actions, t)
        }
        ,
        p.prototype.forEachMutation = function(t) {
            this._rawModule.mutations && l(this._rawModule.mutations, t)
        }
        ,
        Object.defineProperties(p.prototype, f);
        var m = function(t) {
            this.register([], t, !1)
        };
        function g(t, e, n) {
            if (e.update(n),
            n.modules)
                for (var i in n.modules) {
                    if (!e.getChild(i))
                        return void 0;
                    g(t.concat(i), e.getChild(i), n.modules[i])
                }
        }
        m.prototype.get = function(t) {
            return t.reduce((function(t, e) {
                return t.getChild(e)
            }
            ), this.root)
        }
        ,
        m.prototype.getNamespace = function(t) {
            var e = this.root;
            return t.reduce((function(t, n) {
                return e = e.getChild(n),
                t + (e.namespaced ? n + "/" : "")
            }
            ), "")
        }
        ,
        m.prototype.update = function(t) {
            g([], this.root, t)
        }
        ,
        m.prototype.register = function(t, e, n) {
            var i = this;
            void 0 === n && (n = !0);
            var r = new p(e,n);
            if (0 === t.length)
                this.root = r;
            else {
                var a = this.get(t.slice(0, -1));
                a.addChild(t[t.length - 1], r)
            }
            e.modules && l(e.modules, (function(e, r) {
                i.register(t.concat(r), e, n)
            }
            ))
        }
        ,
        m.prototype.unregister = function(t) {
            var e = this.get(t.slice(0, -1))
              , n = t[t.length - 1]
              , i = e.getChild(n);
            i && i.runtime && e.removeChild(n)
        }
        ,
        m.prototype.isRegistered = function(t) {
            var e = this.get(t.slice(0, -1))
              , n = t[t.length - 1];
            return !!e && e.hasChild(n)
        }
        ;
        var v;
        var _ = function(t) {
            var e = this;
            void 0 === t && (t = {}),
            !v && "undefined" !== typeof window && window.Vue && I(window.Vue);
            var n = t.plugins;
            void 0 === n && (n = []);
            var i = t.strict;
            void 0 === i && (i = !1),
            this._committing = !1,
            this._actions = Object.create(null),
            this._actionSubscribers = [],
            this._mutations = Object.create(null),
            this._wrappedGetters = Object.create(null),
            this._modules = new m(t),
            this._modulesNamespaceMap = Object.create(null),
            this._subscribers = [],
            this._watcherVM = new v,
            this._makeLocalGettersCache = Object.create(null);
            var r = this
              , a = this
              , s = a.dispatch
              , c = a.commit;
            this.dispatch = function(t, e) {
                return s.call(r, t, e)
            }
            ,
            this.commit = function(t, e, n) {
                return c.call(r, t, e, n)
            }
            ,
            this.strict = i;
            var l = this._modules.root.state;
            S(this, l, [], this._modules.root),
            b(this, l),
            n.forEach((function(t) {
                return t(e)
            }
            ));
            var u = void 0 !== t.devtools ? t.devtools : v.config.devtools;
            u && o(this)
        }
          , y = {
            state: {
                configurable: !0
            }
        };
        function x(t, e, n) {
            return e.indexOf(t) < 0 && (n && n.prepend ? e.unshift(t) : e.push(t)),
            function() {
                var n = e.indexOf(t);
                n > -1 && e.splice(n, 1)
            }
        }
        function M(t, e) {
            t._actions = Object.create(null),
            t._mutations = Object.create(null),
            t._wrappedGetters = Object.create(null),
            t._modulesNamespaceMap = Object.create(null);
            var n = t.state;
            S(t, n, [], t._modules.root, !0),
            b(t, n, e)
        }
        function b(t, e, n) {
            var i = t._vm;
            t.getters = {},
            t._makeLocalGettersCache = Object.create(null);
            var r = t._wrappedGetters
              , a = {};
            l(r, (function(e, n) {
                a[n] = d(e, t),
                Object.defineProperty(t.getters, n, {
                    get: function() {
                        return t._vm[n]
                    },
                    enumerable: !0
                })
            }
            ));
            var o = v.config.silent;
            v.config.silent = !0,
            t._vm = new v({
                data: {
                    $$state: e
                },
                computed: a
            }),
            v.config.silent = o,
            t.strict && C(t),
            i && (n && t._withCommit((function() {
                i._data.$$state = null
            }
            )),
            v.nextTick((function() {
                return i.$destroy()
            }
            )))
        }
        function S(t, e, n, i, r) {
            var a = !n.length
              , o = t._modules.getNamespace(n);
            if (i.namespaced && (t._modulesNamespaceMap[o],
            t._modulesNamespaceMap[o] = i),
            !a && !r) {
                var s = P(e, n.slice(0, -1))
                  , c = n[n.length - 1];
                t._withCommit((function() {
                    v.set(s, c, i.state)
                }
                ))
            }
            var l = i.context = E(t, o, n);
            i.forEachMutation((function(e, n) {
                var i = o + n;
                w(t, i, e, l)
            }
            )),
            i.forEachAction((function(e, n) {
                var i = e.root ? n : o + n
                  , r = e.handler || e;
                A(t, i, r, l)
            }
            )),
            i.forEachGetter((function(e, n) {
                var i = o + n;
                R(t, i, e, l)
            }
            )),
            i.forEachChild((function(i, a) {
                S(t, e, n.concat(a), i, r)
            }
            ))
        }
        function E(t, e, n) {
            var i = "" === e
              , r = {
                dispatch: i ? t.dispatch : function(n, i, r) {
                    var a = L(n, i, r)
                      , o = a.payload
                      , s = a.options
                      , c = a.type;
                    return s && s.root || (c = e + c),
                    t.dispatch(c, o)
                }
                ,
                commit: i ? t.commit : function(n, i, r) {
                    var a = L(n, i, r)
                      , o = a.payload
                      , s = a.options
                      , c = a.type;
                    s && s.root || (c = e + c),
                    t.commit(c, o, s)
                }
            };
            return Object.defineProperties(r, {
                getters: {
                    get: i ? function() {
                        return t.getters
                    }
                    : function() {
                        return T(t, e)
                    }
                },
                state: {
                    get: function() {
                        return P(t.state, n)
                    }
                }
            }),
            r
        }
        function T(t, e) {
            if (!t._makeLocalGettersCache[e]) {
                var n = {}
                  , i = e.length;
                Object.keys(t.getters).forEach((function(r) {
                    if (r.slice(0, i) === e) {
                        var a = r.slice(i);
                        Object.defineProperty(n, a, {
                            get: function() {
                                return t.getters[r]
                            },
                            enumerable: !0
                        })
                    }
                }
                )),
                t._makeLocalGettersCache[e] = n
            }
            return t._makeLocalGettersCache[e]
        }
        function w(t, e, n, i) {
            var r = t._mutations[e] || (t._mutations[e] = []);
            r.push((function(e) {
                n.call(t, i.state, e)
            }
            ))
        }
        function A(t, e, n, i) {
            var r = t._actions[e] || (t._actions[e] = []);
            r.push((function(e) {
                var r = n.call(t, {
                    dispatch: i.dispatch,
                    commit: i.commit,
                    getters: i.getters,
                    state: i.state,
                    rootGetters: t.getters,
                    rootState: t.state
                }, e);
                return h(r) || (r = Promise.resolve(r)),
                t._devtoolHook ? r.catch((function(e) {
                    throw t._devtoolHook.emit("vuex:error", e),
                    e
                }
                )) : r
            }
            ))
        }
        function R(t, e, n, i) {
            t._wrappedGetters[e] || (t._wrappedGetters[e] = function(t) {
                return n(i.state, i.getters, t.state, t.getters)
            }
            )
        }
        function C(t) {
            t._vm.$watch((function() {
                return this._data.$$state
            }
            ), (function() {
                0
            }
            ), {
                deep: !0,
                sync: !0
            })
        }
        function P(t, e) {
            return e.reduce((function(t, e) {
                return t[e]
            }
            ), t)
        }
        function L(t, e, n) {
            return u(t) && t.type && (n = e,
            e = t,
            t = t.type),
            {
                type: t,
                payload: e,
                options: n
            }
        }
        function I(t) {
            v && t === v || (v = t,
            i(v))
        }
        y.state.get = function() {
            return this._vm._data.$$state
        }
        ,
        y.state.set = function(t) {
            0
        }
        ,
        _.prototype.commit = function(t, e, n) {
            var i = this
              , r = L(t, e, n)
              , a = r.type
              , o = r.payload
              , s = (r.options,
            {
                type: a,
                payload: o
            })
              , c = this._mutations[a];
            c && (this._withCommit((function() {
                c.forEach((function(t) {
                    t(o)
                }
                ))
            }
            )),
            this._subscribers.slice().forEach((function(t) {
                return t(s, i.state)
            }
            )))
        }
        ,
        _.prototype.dispatch = function(t, e) {
            var n = this
              , i = L(t, e)
              , r = i.type
              , a = i.payload
              , o = {
                type: r,
                payload: a
            }
              , s = this._actions[r];
            if (s) {
                try {
                    this._actionSubscribers.slice().filter((function(t) {
                        return t.before
                    }
                    )).forEach((function(t) {
                        return t.before(o, n.state)
                    }
                    ))
                } catch (l) {
                    0
                }
                var c = s.length > 1 ? Promise.all(s.map((function(t) {
                    return t(a)
                }
                ))) : s[0](a);
                return new Promise((function(t, e) {
                    c.then((function(e) {
                        try {
                            n._actionSubscribers.filter((function(t) {
                                return t.after
                            }
                            )).forEach((function(t) {
                                return t.after(o, n.state)
                            }
                            ))
                        } catch (l) {
                            0
                        }
                        t(e)
                    }
                    ), (function(t) {
                        try {
                            n._actionSubscribers.filter((function(t) {
                                return t.error
                            }
                            )).forEach((function(e) {
                                return e.error(o, n.state, t)
                            }
                            ))
                        } catch (l) {
                            0
                        }
                        e(t)
                    }
                    ))
                }
                ))
            }
        }
        ,
        _.prototype.subscribe = function(t, e) {
            return x(t, this._subscribers, e)
        }
        ,
        _.prototype.subscribeAction = function(t, e) {
            var n = "function" === typeof t ? {
                before: t
            } : t;
            return x(n, this._actionSubscribers, e)
        }
        ,
        _.prototype.watch = function(t, e, n) {
            var i = this;
            return this._watcherVM.$watch((function() {
                return t(i.state, i.getters)
            }
            ), e, n)
        }
        ,
        _.prototype.replaceState = function(t) {
            var e = this;
            this._withCommit((function() {
                e._vm._data.$$state = t
            }
            ))
        }
        ,
        _.prototype.registerModule = function(t, e, n) {
            void 0 === n && (n = {}),
            "string" === typeof t && (t = [t]),
            this._modules.register(t, e),
            S(this, this.state, t, this._modules.get(t), n.preserveState),
            b(this, this.state)
        }
        ,
        _.prototype.unregisterModule = function(t) {
            var e = this;
            "string" === typeof t && (t = [t]),
            this._modules.unregister(t),
            this._withCommit((function() {
                var n = P(e.state, t.slice(0, -1));
                v.delete(n, t[t.length - 1])
            }
            )),
            M(this)
        }
        ,
        _.prototype.hasModule = function(t) {
            return "string" === typeof t && (t = [t]),
            this._modules.isRegistered(t)
        }
        ,
        _.prototype.hotUpdate = function(t) {
            this._modules.update(t),
            M(this, !0)
        }
        ,
        _.prototype._withCommit = function(t) {
            var e = this._committing;
            this._committing = !0,
            t(),
            this._committing = e
        }
        ,
        Object.defineProperties(_.prototype, y);
        var U = z((function(t, e) {
            var n = {};
            return B(e).forEach((function(e) {
                var i = e.key
                  , r = e.val;
                n[i] = function() {
                    var e = this.$store.state
                      , n = this.$store.getters;
                    if (t) {
                        var i = V(this.$store, "mapState", t);
                        if (!i)
                            return;
                        e = i.context.state,
                        n = i.context.getters
                    }
                    return "function" === typeof r ? r.call(this, e, n) : e[r]
                }
                ,
                n[i].vuex = !0
            }
            )),
            n
        }
        ))
          , D = z((function(t, e) {
            var n = {};
            return B(e).forEach((function(e) {
                var i = e.key
                  , r = e.val;
                n[i] = function() {
                    var e = []
                      , n = arguments.length;
                    while (n--)
                        e[n] = arguments[n];
                    var i = this.$store.commit;
                    if (t) {
                        var a = V(this.$store, "mapMutations", t);
                        if (!a)
                            return;
                        i = a.context.commit
                    }
                    return "function" === typeof r ? r.apply(this, [i].concat(e)) : i.apply(this.$store, [r].concat(e))
                }
            }
            )),
            n
        }
        ))
          , N = z((function(t, e) {
            var n = {};
            return B(e).forEach((function(e) {
                var i = e.key
                  , r = e.val;
                r = t + r,
                n[i] = function() {
                    if (!t || V(this.$store, "mapGetters", t))
                        return this.$store.getters[r]
                }
                ,
                n[i].vuex = !0
            }
            )),
            n
        }
        ))
          , O = z((function(t, e) {
            var n = {};
            return B(e).forEach((function(e) {
                var i = e.key
                  , r = e.val;
                n[i] = function() {
                    var e = []
                      , n = arguments.length;
                    while (n--)
                        e[n] = arguments[n];
                    var i = this.$store.dispatch;
                    if (t) {
                        var a = V(this.$store, "mapActions", t);
                        if (!a)
                            return;
                        i = a.context.dispatch
                    }
                    return "function" === typeof r ? r.apply(this, [i].concat(e)) : i.apply(this.$store, [r].concat(e))
                }
            }
            )),
            n
        }
        ))
          , F = function(t) {
            return {
                mapState: U.bind(null, t),
                mapGetters: N.bind(null, t),
                mapMutations: D.bind(null, t),
                mapActions: O.bind(null, t)
            }
        };
        function B(t) {
            return k(t) ? Array.isArray(t) ? t.map((function(t) {
                return {
                    key: t,
                    val: t
                }
            }
            )) : Object.keys(t).map((function(e) {
                return {
                    key: e,
                    val: t[e]
                }
            }
            )) : []
        }
        function k(t) {
            return Array.isArray(t) || u(t)
        }
        function z(t) {
            return function(e, n) {
                return "string" !== typeof e ? (n = e,
                e = "") : "/" !== e.charAt(e.length - 1) && (e += "/"),
                t(e, n)
            }
        }
        function V(t, e, n) {
            var i = t._modulesNamespaceMap[n];
            return i
        }
        function H(t) {
            void 0 === t && (t = {});
            var e = t.collapsed;
            void 0 === e && (e = !0);
            var n = t.filter;
            void 0 === n && (n = function(t, e, n) {
                return !0
            }
            );
            var i = t.transformer;
            void 0 === i && (i = function(t) {
                return t
            }
            );
            var r = t.mutationTransformer;
            void 0 === r && (r = function(t) {
                return t
            }
            );
            var a = t.actionFilter;
            void 0 === a && (a = function(t, e) {
                return !0
            }
            );
            var o = t.actionTransformer;
            void 0 === o && (o = function(t) {
                return t
            }
            );
            var s = t.logMutations;
            void 0 === s && (s = !0);
            var l = t.logActions;
            void 0 === l && (l = !0);
            var u = t.logger;
            return void 0 === u && (u = console),
            function(t) {
                var h = c(t.state);
                "undefined" !== typeof u && (s && t.subscribe((function(t, a) {
                    var o = c(a);
                    if (n(t, h, o)) {
                        var s = W()
                          , l = r(t)
                          , d = "mutation " + t.type + s;
                        G(u, d, e),
                        u.log("%c prev state", "color: #9E9E9E; font-weight: bold", i(h)),
                        u.log("%c mutation", "color: #03A9F4; font-weight: bold", l),
                        u.log("%c next state", "color: #4CAF50; font-weight: bold", i(o)),
                        j(u)
                    }
                    h = o
                }
                )),
                l && t.subscribeAction((function(t, n) {
                    if (a(t, n)) {
                        var i = W()
                          , r = o(t)
                          , s = "action " + t.type + i;
                        G(u, s, e),
                        u.log("%c action", "color: #03A9F4; font-weight: bold", r),
                        j(u)
                    }
                }
                )))
            }
        }
        function G(t, e, n) {
            var i = n ? t.groupCollapsed : t.group;
            try {
                i.call(t, e)
            } catch (r) {
                t.log(e)
            }
        }
        function j(t) {
            try {
                t.groupEnd()
            } catch (e) {
                t.log("—— log end ——")
            }
        }
        function W() {
            var t = new Date;
            return " @ " + q(t.getHours(), 2) + ":" + q(t.getMinutes(), 2) + ":" + q(t.getSeconds(), 2) + "." + q(t.getMilliseconds(), 3)
        }
        function X(t, e) {
            return new Array(e + 1).join(t)
        }
        function q(t, e) {
            return X("0", e - t.toString().length) + t
        }
        var $ = {
            Store: _,
            install: I,
            version: "3.6.2",
            mapState: U,
            mapMutations: D,
            mapGetters: N,
            mapActions: O,
            createNamespacedHelpers: F,
            createLogger: H
        };
        e.Ay = $
    },
    9306: function(t, e, n) {
        var i = n(4901)
          , r = n(6823)
          , a = TypeError;
        t.exports = function(t) {
            if (i(t))
                return t;
            throw new a(r(t) + " is not a function")
        }
    },
    3506: function(t, e, n) {
        var i = n(3925)
          , r = String
          , a = TypeError;
        t.exports = function(t) {
            if (i(t))
                return t;
            throw new a("Can't set " + r(t) + " as a prototype")
        }
    },
    7080: function(t, e, n) {
        var i = n(4402).has;
        t.exports = function(t) {
            return i(t),
            t
        }
    },
    8551: function(t, e, n) {
        var i = n(34)
          , r = String
          , a = TypeError;
        t.exports = function(t) {
            if (i(t))
                return t;
            throw new a(r(t) + " is not an object")
        }
    },
    7811: function(t) {
        t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView
    },
    7394: function(t, e, n) {
        var i = n(6706)
          , r = n(4576)
          , a = TypeError;
        t.exports = i(ArrayBuffer.prototype, "byteLength", "get") || function(t) {
            if ("ArrayBuffer" !== r(t))
                throw new a("ArrayBuffer expected");
            return t.byteLength
        }
    },
    3238: function(t, e, n) {
        var i = n(9504)
          , r = n(7394)
          , a = i(ArrayBuffer.prototype.slice);
        t.exports = function(t) {
            if (0 !== r(t))
                return !1;
            try {
                return a(t, 0, 0),
                !1
            } catch (e) {
                return !0
            }
        }
    },
    5636: function(t, e, n) {
        var i = n(4475)
          , r = n(9504)
          , a = n(6706)
          , o = n(7696)
          , s = n(3238)
          , c = n(7394)
          , l = n(4483)
          , u = n(1548)
          , h = i.structuredClone
          , d = i.ArrayBuffer
          , p = i.DataView
          , f = i.TypeError
          , m = Math.min
          , g = d.prototype
          , v = p.prototype
          , _ = r(g.slice)
          , y = a(g, "resizable", "get")
          , x = a(g, "maxByteLength", "get")
          , M = r(v.getInt8)
          , b = r(v.setInt8);
        t.exports = (u || l) && function(t, e, n) {
            var i, r = c(t), a = void 0 === e ? r : o(e), g = !y || !y(t);
            if (s(t))
                throw new f("ArrayBuffer is detached");
            if (u && (t = h(t, {
                transfer: [t]
            }),
            r === a && (n || g)))
                return t;
            if (r >= a && (!n || g))
                i = _(t, 0, a);
            else {
                var v = n && !g && x ? {
                    maxByteLength: x(t)
                } : void 0;
                i = new d(a,v);
                for (var S = new p(t), E = new p(i), T = m(a, r), w = 0; w < T; w++)
                    b(E, w, M(S, w))
            }
            return u || l(t),
            i
        }
    },
    4644: function(t, e, n) {
        var i, r, a, o = n(7811), s = n(3724), c = n(4475), l = n(4901), u = n(34), h = n(9297), d = n(6955), p = n(6823), f = n(6699), m = n(6840), g = n(2106), v = n(1625), _ = n(2787), y = n(2967), x = n(8227), M = n(3392), b = n(1181), S = b.enforce, E = b.get, T = c.Int8Array, w = T && T.prototype, A = c.Uint8ClampedArray, R = A && A.prototype, C = T && _(T), P = w && _(w), L = Object.prototype, I = c.TypeError, U = x("toStringTag"), D = M("TYPED_ARRAY_TAG"), N = "TypedArrayConstructor", O = o && !!y && "Opera" !== d(c.opera), F = !1, B = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
        }, k = {
            BigInt64Array: 8,
            BigUint64Array: 8
        }, z = function(t) {
            if (!u(t))
                return !1;
            var e = d(t);
            return "DataView" === e || h(B, e) || h(k, e)
        }, V = function(t) {
            var e = _(t);
            if (u(e)) {
                var n = E(e);
                return n && h(n, N) ? n[N] : V(e)
            }
        }, H = function(t) {
            if (!u(t))
                return !1;
            var e = d(t);
            return h(B, e) || h(k, e)
        }, G = function(t) {
            if (H(t))
                return t;
            throw new I("Target is not a typed array")
        }, j = function(t) {
            if (l(t) && (!y || v(C, t)))
                return t;
            throw new I(p(t) + " is not a typed array constructor")
        }, W = function(t, e, n, i) {
            if (s) {
                if (n)
                    for (var r in B) {
                        var a = c[r];
                        if (a && h(a.prototype, t))
                            try {
                                delete a.prototype[t]
                            } catch (o) {
                                try {
                                    a.prototype[t] = e
                                } catch (l) {}
                            }
                    }
                P[t] && !n || m(P, t, n ? e : O && w[t] || e, i)
            }
        }, X = function(t, e, n) {
            var i, r;
            if (s) {
                if (y) {
                    if (n)
                        for (i in B)
                            if (r = c[i],
                            r && h(r, t))
                                try {
                                    delete r[t]
                                } catch (a) {}
                    if (C[t] && !n)
                        return;
                    try {
                        return m(C, t, n ? e : O && C[t] || e)
                    } catch (a) {}
                }
                for (i in B)
                    r = c[i],
                    !r || r[t] && !n || m(r, t, e)
            }
        };
        for (i in B)
            r = c[i],
            a = r && r.prototype,
            a ? S(a)[N] = r : O = !1;
        for (i in k)
            r = c[i],
            a = r && r.prototype,
            a && (S(a)[N] = r);
        if ((!O || !l(C) || C === Function.prototype) && (C = function() {
            throw new I("Incorrect invocation")
        }
        ,
        O))
            for (i in B)
                c[i] && y(c[i], C);
        if ((!O || !P || P === L) && (P = C.prototype,
        O))
            for (i in B)
                c[i] && y(c[i].prototype, P);
        if (O && _(R) !== P && y(R, P),
        s && !h(P, U))
            for (i in F = !0,
            g(P, U, {
                configurable: !0,
                get: function() {
                    return u(this) ? this[D] : void 0
                }
            }),
            B)
                c[i] && f(c[i], D, i);
        t.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS: O,
            TYPED_ARRAY_TAG: F && D,
            aTypedArray: G,
            aTypedArrayConstructor: j,
            exportTypedArrayMethod: W,
            exportTypedArrayStaticMethod: X,
            getTypedArrayConstructor: V,
            isView: z,
            isTypedArray: H,
            TypedArray: C,
            TypedArrayPrototype: P
        }
    },
    5370: function(t, e, n) {
        var i = n(6198);
        t.exports = function(t, e, n) {
            var r = 0
              , a = arguments.length > 2 ? n : i(e)
              , o = new t(a);
            while (a > r)
                o[r] = e[r++];
            return o
        }
    },
    9617: function(t, e, n) {
        var i = n(5397)
          , r = n(5610)
          , a = n(6198)
          , o = function(t) {
            return function(e, n, o) {
                var s = i(e)
                  , c = a(s);
                if (0 === c)
                    return !t && -1;
                var l, u = r(o, c);
                if (t && n !== n) {
                    while (c > u)
                        if (l = s[u++],
                        l !== l)
                            return !0
                } else
                    for (; c > u; u++)
                        if ((t || u in s) && s[u] === n)
                            return t || u || 0;
                return !t && -1
            }
        };
        t.exports = {
            includes: o(!0),
            indexOf: o(!1)
        }
    },
    4527: function(t, e, n) {
        var i = n(3724)
          , r = n(4376)
          , a = TypeError
          , o = Object.getOwnPropertyDescriptor
          , s = i && !function() {
            if (void 0 !== this)
                return !0;
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).length = 1
            } catch (t) {
                return t instanceof TypeError
            }
        }();
        t.exports = s ? function(t, e) {
            if (r(t) && !o(t, "length").writable)
                throw new a("Cannot set read only .length");
            return t.length = e
        }
        : function(t, e) {
            return t.length = e
        }
    },
    7680: function(t, e, n) {
        var i = n(9504);
        t.exports = i([].slice)
    },
    7628: function(t, e, n) {
        var i = n(6198);
        t.exports = function(t, e) {
            for (var n = i(t), r = new e(n), a = 0; a < n; a++)
                r[a] = t[n - a - 1];
            return r
        }
    },
    9928: function(t, e, n) {
        var i = n(6198)
          , r = n(1291)
          , a = RangeError;
        t.exports = function(t, e, n, o) {
            var s = i(t)
              , c = r(n)
              , l = c < 0 ? s + c : c;
            if (l >= s || l < 0)
                throw new a("Incorrect index");
            for (var u = new e(s), h = 0; h < s; h++)
                u[h] = h === l ? o : t[h];
            return u
        }
    },
    4576: function(t, e, n) {
        var i = n(9504)
          , r = i({}.toString)
          , a = i("".slice);
        t.exports = function(t) {
            return a(r(t), 8, -1)
        }
    },
    6955: function(t, e, n) {
        var i = n(2140)
          , r = n(4901)
          , a = n(4576)
          , o = n(8227)
          , s = o("toStringTag")
          , c = Object
          , l = "Arguments" === a(function() {
            return arguments
        }())
          , u = function(t, e) {
            try {
                return t[e]
            } catch (n) {}
        };
        t.exports = i ? a : function(t) {
            var e, n, i;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = u(e = c(t), s)) ? n : l ? a(e) : "Object" === (i = a(e)) && r(e.callee) ? "Arguments" : i
        }
    },
    7740: function(t, e, n) {
        var i = n(9297)
          , r = n(5031)
          , a = n(7347)
          , o = n(4913);
        t.exports = function(t, e, n) {
            for (var s = r(e), c = o.f, l = a.f, u = 0; u < s.length; u++) {
                var h = s[u];
                i(t, h) || n && i(n, h) || c(t, h, l(e, h))
            }
        }
    },
    2211: function(t, e, n) {
        var i = n(9039);
        t.exports = !i((function() {
            function t() {}
            return t.prototype.constructor = null,
            Object.getPrototypeOf(new t) !== t.prototype
        }
        ))
    },
    6699: function(t, e, n) {
        var i = n(3724)
          , r = n(4913)
          , a = n(6980);
        t.exports = i ? function(t, e, n) {
            return r.f(t, e, a(1, n))
        }
        : function(t, e, n) {
            return t[e] = n,
            t
        }
    },
    6980: function(t) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    },
    2106: function(t, e, n) {
        var i = n(283)
          , r = n(4913);
        t.exports = function(t, e, n) {
            return n.get && i(n.get, e, {
                getter: !0
            }),
            n.set && i(n.set, e, {
                setter: !0
            }),
            r.f(t, e, n)
        }
    },
    6840: function(t, e, n) {
        var i = n(4901)
          , r = n(4913)
          , a = n(283)
          , o = n(9433);
        t.exports = function(t, e, n, s) {
            s || (s = {});
            var c = s.enumerable
              , l = void 0 !== s.name ? s.name : e;
            if (i(n) && a(n, l, s),
            s.global)
                c ? t[e] = n : o(e, n);
            else {
                try {
                    s.unsafe ? t[e] && (c = !0) : delete t[e]
                } catch (u) {}
                c ? t[e] = n : r.f(t, e, {
                    value: n,
                    enumerable: !1,
                    configurable: !s.nonConfigurable,
                    writable: !s.nonWritable
                })
            }
            return t
        }
    },
    9433: function(t, e, n) {
        var i = n(4475)
          , r = Object.defineProperty;
        t.exports = function(t, e) {
            try {
                r(i, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch (n) {
                i[t] = e
            }
            return e
        }
    },
    3724: function(t, e, n) {
        var i = n(9039);
        t.exports = !i((function() {
            return 7 !== Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        }
        ))
    },
    4483: function(t, e, n) {
        var i, r, a, o, s = n(4475), c = n(9714), l = n(1548), u = s.structuredClone, h = s.ArrayBuffer, d = s.MessageChannel, p = !1;
        if (l)
            p = function(t) {
                u(t, {
                    transfer: [t]
                })
            }
            ;
        else if (h)
            try {
                d || (i = c("worker_threads"),
                i && (d = i.MessageChannel)),
                d && (r = new d,
                a = new h(2),
                o = function(t) {
                    r.port1.postMessage(null, [t])
                }
                ,
                2 === a.byteLength && (o(a),
                0 === a.byteLength && (p = o)))
            } catch (f) {}
        t.exports = p
    },
    4055: function(t, e, n) {
        var i = n(4475)
          , r = n(34)
          , a = i.document
          , o = r(a) && r(a.createElement);
        t.exports = function(t) {
            return o ? a.createElement(t) : {}
        }
    },
    6837: function(t) {
        var e = TypeError
          , n = 9007199254740991;
        t.exports = function(t) {
            if (t > n)
                throw e("Maximum allowed index exceeded");
            return t
        }
    },
    7290: function(t, e, n) {
        var i = n(516)
          , r = n(9088);
        t.exports = !i && !r && "object" == typeof window && "object" == typeof document
    },
    6763: function(t) {
        t.exports = "function" == typeof Bun && Bun && "string" == typeof Bun.version
    },
    516: function(t) {
        t.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version
    },
    8119: function(t, e, n) {
        var i = n(9392);
        t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(i)
    },
    9088: function(t, e, n) {
        var i = n(4475)
          , r = n(4576);
        t.exports = "process" === r(i.process)
    },
    9392: function(t) {
        t.exports = "undefined" != typeof navigator && String(navigator.userAgent) || ""
    },
    7388: function(t, e, n) {
        var i, r, a = n(4475), o = n(9392), s = a.process, c = a.Deno, l = s && s.versions || c && c.version, u = l && l.v8;
        u && (i = u.split("."),
        r = i[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])),
        !r && o && (i = o.match(/Edge\/(\d+)/),
        (!i || i[1] >= 74) && (i = o.match(/Chrome\/(\d+)/),
        i && (r = +i[1]))),
        t.exports = r
    },
    8727: function(t) {
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    },
    6518: function(t, e, n) {
        var i = n(4475)
          , r = n(7347).f
          , a = n(6699)
          , o = n(6840)
          , s = n(9433)
          , c = n(7740)
          , l = n(2796);
        t.exports = function(t, e) {
            var n, u, h, d, p, f, m = t.target, g = t.global, v = t.stat;
            if (u = g ? i : v ? i[m] || s(m, {}) : i[m] && i[m].prototype,
            u)
                for (h in e) {
                    if (p = e[h],
                    t.dontCallGetSet ? (f = r(u, h),
                    d = f && f.value) : d = u[h],
                    n = l(g ? h : m + (v ? "." : "#") + h, t.forced),
                    !n && void 0 !== d) {
                        if (typeof p == typeof d)
                            continue;
                        c(p, d)
                    }
                    (t.sham || d && d.sham) && a(p, "sham", !0),
                    o(u, h, p, t)
                }
        }
    },
    9039: function(t) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (e) {
                return !0
            }
        }
    },
    8745: function(t, e, n) {
        var i = n(616)
          , r = Function.prototype
          , a = r.apply
          , o = r.call;
        t.exports = "object" == typeof Reflect && Reflect.apply || (i ? o.bind(a) : function() {
            return o.apply(a, arguments)
        }
        )
    },
    6080: function(t, e, n) {
        var i = n(7476)
          , r = n(9306)
          , a = n(616)
          , o = i(i.bind);
        t.exports = function(t, e) {
            return r(t),
            void 0 === e ? t : a ? o(t, e) : function() {
                return t.apply(e, arguments)
            }
        }
    },
    616: function(t, e, n) {
        var i = n(9039);
        t.exports = !i((function() {
            var t = function() {}
            .bind();
            return "function" != typeof t || t.hasOwnProperty("prototype")
        }
        ))
    },
    9565: function(t, e, n) {
        var i = n(616)
          , r = Function.prototype.call;
        t.exports = i ? r.bind(r) : function() {
            return r.apply(r, arguments)
        }
    },
    350: function(t, e, n) {
        var i = n(3724)
          , r = n(9297)
          , a = Function.prototype
          , o = i && Object.getOwnPropertyDescriptor
          , s = r(a, "name")
          , c = s && "something" === function() {}
        .name
          , l = s && (!i || i && o(a, "name").configurable);
        t.exports = {
            EXISTS: s,
            PROPER: c,
            CONFIGURABLE: l
        }
    },
    6706: function(t, e, n) {
        var i = n(9504)
          , r = n(9306);
        t.exports = function(t, e, n) {
            try {
                return i(r(Object.getOwnPropertyDescriptor(t, e)[n]))
            } catch (a) {}
        }
    },
    7476: function(t, e, n) {
        var i = n(4576)
          , r = n(9504);
        t.exports = function(t) {
            if ("Function" === i(t))
                return r(t)
        }
    },
    9504: function(t, e, n) {
        var i = n(616)
          , r = Function.prototype
          , a = r.call
          , o = i && r.bind.bind(a, a);
        t.exports = i ? o : function(t) {
            return function() {
                return a.apply(t, arguments)
            }
        }
    },
    7751: function(t, e, n) {
        var i = n(4475)
          , r = n(4901)
          , a = function(t) {
            return r(t) ? t : void 0
        };
        t.exports = function(t, e) {
            return arguments.length < 2 ? a(i[t]) : i[t] && i[t][e]
        }
    },
    1767: function(t) {
        t.exports = function(t) {
            return {
                iterator: t,
                next: t.next,
                done: !1
            }
        }
    },
    5966: function(t, e, n) {
        var i = n(9306)
          , r = n(4117);
        t.exports = function(t, e) {
            var n = t[e];
            return r(n) ? void 0 : i(n)
        }
    },
    3789: function(t, e, n) {
        var i = n(9306)
          , r = n(8551)
          , a = n(9565)
          , o = n(1291)
          , s = n(1767)
          , c = "Invalid size"
          , l = RangeError
          , u = TypeError
          , h = Math.max
          , d = function(t, e) {
            this.set = t,
            this.size = h(e, 0),
            this.has = i(t.has),
            this.keys = i(t.keys)
        };
        d.prototype = {
            getIterator: function() {
                return s(r(a(this.keys, this.set)))
            },
            includes: function(t) {
                return a(this.has, this.set, t)
            }
        },
        t.exports = function(t) {
            r(t);
            var e = +t.size;
            if (e !== e)
                throw new u(c);
            var n = o(e);
            if (n < 0)
                throw new l(c);
            return new d(t,n)
        }
    },
    4475: function(t, e, n) {
        var i = function(t) {
            return t && t.Math === Math && t
        };
        t.exports = i("object" == typeof globalThis && globalThis) || i("object" == typeof window && window) || i("object" == typeof self && self) || i("object" == typeof n.g && n.g) || i("object" == typeof this && this) || function() {
            return this
        }() || Function("return this")()
    },
    9297: function(t, e, n) {
        var i = n(9504)
          , r = n(8981)
          , a = i({}.hasOwnProperty);
        t.exports = Object.hasOwn || function(t, e) {
            return a(r(t), e)
        }
    },
    421: function(t) {
        t.exports = {}
    },
    397: function(t, e, n) {
        var i = n(7751);
        t.exports = i("document", "documentElement")
    },
    5917: function(t, e, n) {
        var i = n(3724)
          , r = n(9039)
          , a = n(4055);
        t.exports = !i && !r((function() {
            return 7 !== Object.defineProperty(a("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
    },
    7055: function(t, e, n) {
        var i = n(9504)
          , r = n(9039)
          , a = n(4576)
          , o = Object
          , s = i("".split);
        t.exports = r((function() {
            return !o("z").propertyIsEnumerable(0)
        }
        )) ? function(t) {
            return "String" === a(t) ? s(t, "") : o(t)
        }
        : o
    },
    3706: function(t, e, n) {
        var i = n(9504)
          , r = n(4901)
          , a = n(7629)
          , o = i(Function.toString);
        r(a.inspectSource) || (a.inspectSource = function(t) {
            return o(t)
        }
        ),
        t.exports = a.inspectSource
    },
    1181: function(t, e, n) {
        var i, r, a, o = n(8622), s = n(4475), c = n(34), l = n(6699), u = n(9297), h = n(7629), d = n(6119), p = n(421), f = "Object already initialized", m = s.TypeError, g = s.WeakMap, v = function(t) {
            return a(t) ? r(t) : i(t, {})
        }, _ = function(t) {
            return function(e) {
                var n;
                if (!c(e) || (n = r(e)).type !== t)
                    throw new m("Incompatible receiver, " + t + " required");
                return n
            }
        };
        if (o || h.state) {
            var y = h.state || (h.state = new g);
            y.get = y.get,
            y.has = y.has,
            y.set = y.set,
            i = function(t, e) {
                if (y.has(t))
                    throw new m(f);
                return e.facade = t,
                y.set(t, e),
                e
            }
            ,
            r = function(t) {
                return y.get(t) || {}
            }
            ,
            a = function(t) {
                return y.has(t)
            }
        } else {
            var x = d("state");
            p[x] = !0,
            i = function(t, e) {
                if (u(t, x))
                    throw new m(f);
                return e.facade = t,
                l(t, x, e),
                e
            }
            ,
            r = function(t) {
                return u(t, x) ? t[x] : {}
            }
            ,
            a = function(t) {
                return u(t, x)
            }
        }
        t.exports = {
            set: i,
            get: r,
            has: a,
            enforce: v,
            getterFor: _
        }
    },
    4376: function(t, e, n) {
        var i = n(4576);
        t.exports = Array.isArray || function(t) {
            return "Array" === i(t)
        }
    },
    1108: function(t, e, n) {
        var i = n(6955);
        t.exports = function(t) {
            var e = i(t);
            return "BigInt64Array" === e || "BigUint64Array" === e
        }
    },
    4901: function(t) {
        var e = "object" == typeof document && document.all;
        t.exports = "undefined" == typeof e && void 0 !== e ? function(t) {
            return "function" == typeof t || t === e
        }
        : function(t) {
            return "function" == typeof t
        }
    },
    2796: function(t, e, n) {
        var i = n(9039)
          , r = n(4901)
          , a = /#|\.prototype\./
          , o = function(t, e) {
            var n = c[s(t)];
            return n === u || n !== l && (r(e) ? i(e) : !!e)
        }
          , s = o.normalize = function(t) {
            return String(t).replace(a, ".").toLowerCase()
        }
          , c = o.data = {}
          , l = o.NATIVE = "N"
          , u = o.POLYFILL = "P";
        t.exports = o
    },
    4117: function(t) {
        t.exports = function(t) {
            return null === t || void 0 === t
        }
    },
    34: function(t, e, n) {
        var i = n(4901);
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : i(t)
        }
    },
    3925: function(t, e, n) {
        var i = n(34);
        t.exports = function(t) {
            return i(t) || null === t
        }
    },
    6395: function(t) {
        t.exports = !1
    },
    757: function(t, e, n) {
        var i = n(7751)
          , r = n(4901)
          , a = n(1625)
          , o = n(7040)
          , s = Object;
        t.exports = o ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            var e = i("Symbol");
            return r(e) && a(e.prototype, s(t))
        }
    },
    507: function(t, e, n) {
        var i = n(9565);
        t.exports = function(t, e, n) {
            var r, a, o = n ? t : t.iterator, s = t.next;
            while (!(r = i(s, o)).done)
                if (a = e(r.value),
                void 0 !== a)
                    return a
        }
    },
    9539: function(t, e, n) {
        var i = n(9565)
          , r = n(8551)
          , a = n(5966);
        t.exports = function(t, e, n) {
            var o, s;
            r(t);
            try {
                if (o = a(t, "return"),
                !o) {
                    if ("throw" === e)
                        throw n;
                    return n
                }
                o = i(o, t)
            } catch (c) {
                s = !0,
                o = c
            }
            if ("throw" === e)
                throw n;
            if (s)
                throw o;
            return r(o),
            n
        }
    },
    6198: function(t, e, n) {
        var i = n(8014);
        t.exports = function(t) {
            return i(t.length)
        }
    },
    283: function(t, e, n) {
        var i = n(9504)
          , r = n(9039)
          , a = n(4901)
          , o = n(9297)
          , s = n(3724)
          , c = n(350).CONFIGURABLE
          , l = n(3706)
          , u = n(1181)
          , h = u.enforce
          , d = u.get
          , p = String
          , f = Object.defineProperty
          , m = i("".slice)
          , g = i("".replace)
          , v = i([].join)
          , _ = s && !r((function() {
            return 8 !== f((function() {}
            ), "length", {
                value: 8
            }).length
        }
        ))
          , y = String(String).split("String")
          , x = t.exports = function(t, e, n) {
            "Symbol(" === m(p(e), 0, 7) && (e = "[" + g(p(e), /^Symbol\(([^)]*)\).*$/, "$1") + "]"),
            n && n.getter && (e = "get " + e),
            n && n.setter && (e = "set " + e),
            (!o(t, "name") || c && t.name !== e) && (s ? f(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e),
            _ && n && o(n, "arity") && t.length !== n.arity && f(t, "length", {
                value: n.arity
            });
            try {
                n && o(n, "constructor") && n.constructor ? s && f(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch (r) {}
            var i = h(t);
            return o(i, "source") || (i.source = v(y, "string" == typeof e ? e : "")),
            t
        }
        ;
        Function.prototype.toString = x((function() {
            return a(this) && d(this).source || l(this)
        }
        ), "toString")
    },
    741: function(t) {
        var e = Math.ceil
          , n = Math.floor;
        t.exports = Math.trunc || function(t) {
            var i = +t;
            return (i > 0 ? n : e)(i)
        }
    },
    4913: function(t, e, n) {
        var i = n(3724)
          , r = n(5917)
          , a = n(8686)
          , o = n(8551)
          , s = n(6969)
          , c = TypeError
          , l = Object.defineProperty
          , u = Object.getOwnPropertyDescriptor
          , h = "enumerable"
          , d = "configurable"
          , p = "writable";
        e.f = i ? a ? function(t, e, n) {
            if (o(t),
            e = s(e),
            o(n),
            "function" === typeof t && "prototype" === e && "value"in n && p in n && !n[p]) {
                var i = u(t, e);
                i && i[p] && (t[e] = n.value,
                n = {
                    configurable: d in n ? n[d] : i[d],
                    enumerable: h in n ? n[h] : i[h],
                    writable: !1
                })
            }
            return l(t, e, n)
        }
        : l : function(t, e, n) {
            if (o(t),
            e = s(e),
            o(n),
            r)
                try {
                    return l(t, e, n)
                } catch (i) {}
            if ("get"in n || "set"in n)
                throw new c("Accessors not supported");
            return "value"in n && (t[e] = n.value),
            t
        }
    },
    7347: function(t, e, n) {
        var i = n(3724)
          , r = n(9565)
          , a = n(8773)
          , o = n(6980)
          , s = n(5397)
          , c = n(6969)
          , l = n(9297)
          , u = n(5917)
          , h = Object.getOwnPropertyDescriptor;
        e.f = i ? h : function(t, e) {
            if (t = s(t),
            e = c(e),
            u)
                try {
                    return h(t, e)
                } catch (n) {}
            if (l(t, e))
                return o(!r(a.f, t, e), t[e])
        }
    },
    8480: function(t, e, n) {
        var i = n(1828)
          , r = n(8727)
          , a = r.concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return i(t, a)
        }
    },
    3717: function(t, e) {
        e.f = Object.getOwnPropertySymbols
    },
    2787: function(t, e, n) {
        var i = n(9297)
          , r = n(4901)
          , a = n(8981)
          , o = n(6119)
          , s = n(2211)
          , c = o("IE_PROTO")
          , l = Object
          , u = l.prototype;
        t.exports = s ? l.getPrototypeOf : function(t) {
            var e = a(t);
            if (i(e, c))
                return e[c];
            var n = e.constructor;
            return r(n) && e instanceof n ? n.prototype : e instanceof l ? u : null
        }
    },
    1625: function(t, e, n) {
        var i = n(9504);
        t.exports = i({}.isPrototypeOf)
    },
    1828: function(t, e, n) {
        var i = n(9504)
          , r = n(9297)
          , a = n(5397)
          , o = n(9617).indexOf
          , s = n(421)
          , c = i([].push);
        t.exports = function(t, e) {
            var n, i = a(t), l = 0, u = [];
            for (n in i)
                !r(s, n) && r(i, n) && c(u, n);
            while (e.length > l)
                r(i, n = e[l++]) && (~o(u, n) || c(u, n));
            return u
        }
    },
    8773: function(t, e) {
        var n = {}.propertyIsEnumerable
          , i = Object.getOwnPropertyDescriptor
          , r = i && !n.call({
            1: 2
        }, 1);
        e.f = r ? function(t) {
            var e = i(this, t);
            return !!e && e.enumerable
        }
        : n
    },
    2967: function(t, e, n) {
        var i = n(6706)
          , r = n(34)
          , a = n(7750)
          , o = n(3506);
        t.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
            var t, e = !1, n = {};
            try {
                t = i(Object.prototype, "__proto__", "set"),
                t(n, []),
                e = n instanceof Array
            } catch (s) {}
            return function(n, i) {
                return a(n),
                o(i),
                r(n) ? (e ? t(n, i) : n.__proto__ = i,
                n) : n
            }
        }() : void 0)
    },
    4270: function(t, e, n) {
        var i = n(9565)
          , r = n(4901)
          , a = n(34)
          , o = TypeError;
        t.exports = function(t, e) {
            var n, s;
            if ("string" === e && r(n = t.toString) && !a(s = i(n, t)))
                return s;
            if (r(n = t.valueOf) && !a(s = i(n, t)))
                return s;
            if ("string" !== e && r(n = t.toString) && !a(s = i(n, t)))
                return s;
            throw new o("Can't convert object to primitive value")
        }
    },
    5031: function(t, e, n) {
        var i = n(7751)
          , r = n(9504)
          , a = n(8480)
          , o = n(3717)
          , s = n(8551)
          , c = r([].concat);
        t.exports = i("Reflect", "ownKeys") || function(t) {
            var e = a.f(s(t))
              , n = o.f;
            return n ? c(e, n(t)) : e
        }
    },
    7750: function(t, e, n) {
        var i = n(4117)
          , r = TypeError;
        t.exports = function(t) {
            if (i(t))
                throw new r("Can't call method on " + t);
            return t
        }
    },
    9472: function(t, e, n) {
        var i = n(4475)
          , r = n(8745)
          , a = n(4901)
          , o = n(6763)
          , s = n(9392)
          , c = n(7680)
          , l = n(2812)
          , u = i.Function
          , h = /MSIE .\./.test(s) || o && function() {
            var t = i.Bun.version.split(".");
            return t.length < 3 || "0" === t[0] && (t[1] < 3 || "3" === t[1] && "0" === t[2])
        }();
        t.exports = function(t, e) {
            var n = e ? 2 : 1;
            return h ? function(i, o) {
                var s = l(arguments.length, 1) > n
                  , h = a(i) ? i : u(i)
                  , d = s ? c(arguments, n) : []
                  , p = s ? function() {
                    r(h, this, d)
                }
                : h;
                return e ? t(p, o) : t(p)
            }
            : t
        }
    },
    9286: function(t, e, n) {
        var i = n(4402)
          , r = n(8469)
          , a = i.Set
          , o = i.add;
        t.exports = function(t) {
            var e = new a;
            return r(t, (function(t) {
                o(e, t)
            }
            )),
            e
        }
    },
    3440: function(t, e, n) {
        var i = n(7080)
          , r = n(4402)
          , a = n(9286)
          , o = n(5170)
          , s = n(3789)
          , c = n(8469)
          , l = n(507)
          , u = r.has
          , h = r.remove;
        t.exports = function(t) {
            var e = i(this)
              , n = s(t)
              , r = a(e);
            return o(e) <= n.size ? c(e, (function(t) {
                n.includes(t) && h(r, t)
            }
            )) : l(n.getIterator(), (function(t) {
                u(e, t) && h(r, t)
            }
            )),
            r
        }
    },
    4402: function(t, e, n) {
        var i = n(9504)
          , r = Set.prototype;
        t.exports = {
            Set: Set,
            add: i(r.add),
            has: i(r.has),
            remove: i(r["delete"]),
            proto: r
        }
    },
    8750: function(t, e, n) {
        var i = n(7080)
          , r = n(4402)
          , a = n(5170)
          , o = n(3789)
          , s = n(8469)
          , c = n(507)
          , l = r.Set
          , u = r.add
          , h = r.has;
        t.exports = function(t) {
            var e = i(this)
              , n = o(t)
              , r = new l;
            return a(e) > n.size ? c(n.getIterator(), (function(t) {
                h(e, t) && u(r, t)
            }
            )) : s(e, (function(t) {
                n.includes(t) && u(r, t)
            }
            )),
            r
        }
    },
    4449: function(t, e, n) {
        var i = n(7080)
          , r = n(4402).has
          , a = n(5170)
          , o = n(3789)
          , s = n(8469)
          , c = n(507)
          , l = n(9539);
        t.exports = function(t) {
            var e = i(this)
              , n = o(t);
            if (a(e) <= n.size)
                return !1 !== s(e, (function(t) {
                    if (n.includes(t))
                        return !1
                }
                ), !0);
            var u = n.getIterator();
            return !1 !== c(u, (function(t) {
                if (r(e, t))
                    return l(u, "normal", !1)
            }
            ))
        }
    },
    3838: function(t, e, n) {
        var i = n(7080)
          , r = n(5170)
          , a = n(8469)
          , o = n(3789);
        t.exports = function(t) {
            var e = i(this)
              , n = o(t);
            return !(r(e) > n.size) && !1 !== a(e, (function(t) {
                if (!n.includes(t))
                    return !1
            }
            ), !0)
        }
    },
    8527: function(t, e, n) {
        var i = n(7080)
          , r = n(4402).has
          , a = n(5170)
          , o = n(3789)
          , s = n(507)
          , c = n(9539);
        t.exports = function(t) {
            var e = i(this)
              , n = o(t);
            if (a(e) < n.size)
                return !1;
            var l = n.getIterator();
            return !1 !== s(l, (function(t) {
                if (!r(e, t))
                    return c(l, "normal", !1)
            }
            ))
        }
    },
    8469: function(t, e, n) {
        var i = n(9504)
          , r = n(507)
          , a = n(4402)
          , o = a.Set
          , s = a.proto
          , c = i(s.forEach)
          , l = i(s.keys)
          , u = l(new o).next;
        t.exports = function(t, e, n) {
            return n ? r({
                iterator: l(t),
                next: u
            }, e) : c(t, e)
        }
    },
    4916: function(t, e, n) {
        var i = n(7751)
          , r = function(t) {
            return {
                size: t,
                has: function() {
                    return !1
                },
                keys: function() {
                    return {
                        next: function() {
                            return {
                                done: !0
                            }
                        }
                    }
                }
            }
        };
        t.exports = function(t) {
            var e = i("Set");
            try {
                (new e)[t](r(0));
                try {
                    return (new e)[t](r(-1)),
                    !1
                } catch (n) {
                    return !0
                }
            } catch (a) {
                return !1
            }
        }
    },
    5170: function(t, e, n) {
        var i = n(6706)
          , r = n(4402);
        t.exports = i(r.proto, "size", "get") || function(t) {
            return t.size
        }
    },
    3650: function(t, e, n) {
        var i = n(7080)
          , r = n(4402)
          , a = n(9286)
          , o = n(3789)
          , s = n(507)
          , c = r.add
          , l = r.has
          , u = r.remove;
        t.exports = function(t) {
            var e = i(this)
              , n = o(t).getIterator()
              , r = a(e);
            return s(n, (function(t) {
                l(e, t) ? u(r, t) : c(r, t)
            }
            )),
            r
        }
    },
    4204: function(t, e, n) {
        var i = n(7080)
          , r = n(4402).add
          , a = n(9286)
          , o = n(3789)
          , s = n(507);
        t.exports = function(t) {
            var e = i(this)
              , n = o(t).getIterator()
              , c = a(e);
            return s(n, (function(t) {
                r(c, t)
            }
            )),
            c
        }
    },
    6119: function(t, e, n) {
        var i = n(5745)
          , r = n(3392)
          , a = i("keys");
        t.exports = function(t) {
            return a[t] || (a[t] = r(t))
        }
    },
    7629: function(t, e, n) {
        var i = n(6395)
          , r = n(4475)
          , a = n(9433)
          , o = "__core-js_shared__"
          , s = t.exports = r[o] || a(o, {});
        (s.versions || (s.versions = [])).push({
            version: "3.37.1",
            mode: i ? "pure" : "global",
            copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
        })
    },
    5745: function(t, e, n) {
        var i = n(7629);
        t.exports = function(t, e) {
            return i[t] || (i[t] = e || {})
        }
    },
    1548: function(t, e, n) {
        var i = n(4475)
          , r = n(9039)
          , a = n(7388)
          , o = n(7290)
          , s = n(516)
          , c = n(9088)
          , l = i.structuredClone;
        t.exports = !!l && !r((function() {
            if (s && a > 92 || c && a > 94 || o && a > 97)
                return !1;
            var t = new ArrayBuffer(8)
              , e = l(t, {
                transfer: [t]
            });
            return 0 !== t.byteLength || 8 !== e.byteLength
        }
        ))
    },
    4495: function(t, e, n) {
        var i = n(7388)
          , r = n(9039)
          , a = n(4475)
          , o = a.String;
        t.exports = !!Object.getOwnPropertySymbols && !r((function() {
            var t = Symbol("symbol detection");
            return !o(t) || !(Object(t)instanceof Symbol) || !Symbol.sham && i && i < 41
        }
        ))
    },
    1606: function(t, e, n) {
        var i, r, a, o, s = n(4475), c = n(8745), l = n(6080), u = n(4901), h = n(9297), d = n(9039), p = n(397), f = n(7680), m = n(4055), g = n(2812), v = n(8119), _ = n(9088), y = s.setImmediate, x = s.clearImmediate, M = s.process, b = s.Dispatch, S = s.Function, E = s.MessageChannel, T = s.String, w = 0, A = {}, R = "onreadystatechange";
        d((function() {
            i = s.location
        }
        ));
        var C = function(t) {
            if (h(A, t)) {
                var e = A[t];
                delete A[t],
                e()
            }
        }
          , P = function(t) {
            return function() {
                C(t)
            }
        }
          , L = function(t) {
            C(t.data)
        }
          , I = function(t) {
            s.postMessage(T(t), i.protocol + "//" + i.host)
        };
        y && x || (y = function(t) {
            g(arguments.length, 1);
            var e = u(t) ? t : S(t)
              , n = f(arguments, 1);
            return A[++w] = function() {
                c(e, void 0, n)
            }
            ,
            r(w),
            w
        }
        ,
        x = function(t) {
            delete A[t]
        }
        ,
        _ ? r = function(t) {
            M.nextTick(P(t))
        }
        : b && b.now ? r = function(t) {
            b.now(P(t))
        }
        : E && !v ? (a = new E,
        o = a.port2,
        a.port1.onmessage = L,
        r = l(o.postMessage, o)) : s.addEventListener && u(s.postMessage) && !s.importScripts && i && "file:" !== i.protocol && !d(I) ? (r = I,
        s.addEventListener("message", L, !1)) : r = R in m("script") ? function(t) {
            p.appendChild(m("script"))[R] = function() {
                p.removeChild(this),
                C(t)
            }
        }
        : function(t) {
            setTimeout(P(t), 0)
        }
        ),
        t.exports = {
            set: y,
            clear: x
        }
    },
    5610: function(t, e, n) {
        var i = n(1291)
          , r = Math.max
          , a = Math.min;
        t.exports = function(t, e) {
            var n = i(t);
            return n < 0 ? r(n + e, 0) : a(n, e)
        }
    },
    5854: function(t, e, n) {
        var i = n(2777)
          , r = TypeError;
        t.exports = function(t) {
            var e = i(t, "number");
            if ("number" == typeof e)
                throw new r("Can't convert number to bigint");
            return BigInt(e)
        }
    },
    7696: function(t, e, n) {
        var i = n(1291)
          , r = n(8014)
          , a = RangeError;
        t.exports = function(t) {
            if (void 0 === t)
                return 0;
            var e = i(t)
              , n = r(e);
            if (e !== n)
                throw new a("Wrong length or index");
            return n
        }
    },
    5397: function(t, e, n) {
        var i = n(7055)
          , r = n(7750);
        t.exports = function(t) {
            return i(r(t))
        }
    },
    1291: function(t, e, n) {
        var i = n(741);
        t.exports = function(t) {
            var e = +t;
            return e !== e || 0 === e ? 0 : i(e)
        }
    },
    8014: function(t, e, n) {
        var i = n(1291)
          , r = Math.min;
        t.exports = function(t) {
            var e = i(t);
            return e > 0 ? r(e, 9007199254740991) : 0
        }
    },
    8981: function(t, e, n) {
        var i = n(7750)
          , r = Object;
        t.exports = function(t) {
            return r(i(t))
        }
    },
    2777: function(t, e, n) {
        var i = n(9565)
          , r = n(34)
          , a = n(757)
          , o = n(5966)
          , s = n(4270)
          , c = n(8227)
          , l = TypeError
          , u = c("toPrimitive");
        t.exports = function(t, e) {
            if (!r(t) || a(t))
                return t;
            var n, c = o(t, u);
            if (c) {
                if (void 0 === e && (e = "default"),
                n = i(c, t, e),
                !r(n) || a(n))
                    return n;
                throw new l("Can't convert object to primitive value")
            }
            return void 0 === e && (e = "number"),
            s(t, e)
        }
    },
    6969: function(t, e, n) {
        var i = n(2777)
          , r = n(757);
        t.exports = function(t) {
            var e = i(t, "string");
            return r(e) ? e : e + ""
        }
    },
    2140: function(t, e, n) {
        var i = n(8227)
          , r = i("toStringTag")
          , a = {};
        a[r] = "z",
        t.exports = "[object z]" === String(a)
    },
    9714: function(t, e, n) {
        var i = n(9088);
        t.exports = function(t) {
            try {
                if (i)
                    return Function('return require("' + t + '")')()
            } catch (e) {}
        }
    },
    6823: function(t) {
        var e = String;
        t.exports = function(t) {
            try {
                return e(t)
            } catch (n) {
                return "Object"
            }
        }
    },
    3392: function(t, e, n) {
        var i = n(9504)
          , r = 0
          , a = Math.random()
          , o = i(1..toString);
        t.exports = function(t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + a, 36)
        }
    },
    7040: function(t, e, n) {
        var i = n(4495);
        t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator
    },
    8686: function(t, e, n) {
        var i = n(3724)
          , r = n(9039);
        t.exports = i && r((function() {
            return 42 !== Object.defineProperty((function() {}
            ), "prototype", {
                value: 42,
                writable: !1
            }).prototype
        }
        ))
    },
    2812: function(t) {
        var e = TypeError;
        t.exports = function(t, n) {
            if (t < n)
                throw new e("Not enough arguments");
            return t
        }
    },
    8622: function(t, e, n) {
        var i = n(4475)
          , r = n(4901)
          , a = i.WeakMap;
        t.exports = r(a) && /native code/.test(String(a))
    },
    8227: function(t, e, n) {
        var i = n(4475)
          , r = n(5745)
          , a = n(9297)
          , o = n(3392)
          , s = n(4495)
          , c = n(7040)
          , l = i.Symbol
          , u = r("wks")
          , h = c ? l["for"] || l : l && l.withoutSetter || o;
        t.exports = function(t) {
            return a(u, t) || (u[t] = s && a(l, t) ? l[t] : h("Symbol." + t)),
            u[t]
        }
    },
    6573: function(t, e, n) {
        var i = n(3724)
          , r = n(2106)
          , a = n(3238)
          , o = ArrayBuffer.prototype;
        i && !("detached"in o) && r(o, "detached", {
            configurable: !0,
            get: function() {
                return a(this)
            }
        })
    },
    7936: function(t, e, n) {
        var i = n(6518)
          , r = n(5636);
        r && i({
            target: "ArrayBuffer",
            proto: !0
        }, {
            transferToFixedLength: function() {
                return r(this, arguments.length ? arguments[0] : void 0, !1)
            }
        })
    },
    8100: function(t, e, n) {
        var i = n(6518)
          , r = n(5636);
        r && i({
            target: "ArrayBuffer",
            proto: !0
        }, {
            transfer: function() {
                return r(this, arguments.length ? arguments[0] : void 0, !0)
            }
        })
    },
    4114: function(t, e, n) {
        var i = n(6518)
          , r = n(8981)
          , a = n(6198)
          , o = n(4527)
          , s = n(6837)
          , c = n(9039)
          , l = c((function() {
            return 4294967297 !== [].push.call({
                length: 4294967296
            }, 1)
        }
        ))
          , u = function() {
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).push()
            } catch (t) {
                return t instanceof TypeError
            }
        }
          , h = l || !u();
        i({
            target: "Array",
            proto: !0,
            arity: 1,
            forced: h
        }, {
            push: function(t) {
                var e = r(this)
                  , n = a(e)
                  , i = arguments.length;
                s(n + i);
                for (var c = 0; c < i; c++)
                    e[n] = arguments[c],
                    n++;
                return o(e, n),
                n
            }
        })
    },
    7642: function(t, e, n) {
        var i = n(6518)
          , r = n(3440)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("difference")
        }, {
            difference: r
        })
    },
    8004: function(t, e, n) {
        var i = n(6518)
          , r = n(9039)
          , a = n(8750)
          , o = n(4916)
          , s = !o("intersection") || r((function() {
            return "3,2" !== String(Array.from(new Set([1, 2, 3]).intersection(new Set([3, 2]))))
        }
        ));
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: s
        }, {
            intersection: a
        })
    },
    3853: function(t, e, n) {
        var i = n(6518)
          , r = n(4449)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("isDisjointFrom")
        }, {
            isDisjointFrom: r
        })
    },
    5876: function(t, e, n) {
        var i = n(6518)
          , r = n(3838)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("isSubsetOf")
        }, {
            isSubsetOf: r
        })
    },
    2475: function(t, e, n) {
        var i = n(6518)
          , r = n(8527)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("isSupersetOf")
        }, {
            isSupersetOf: r
        })
    },
    5024: function(t, e, n) {
        var i = n(6518)
          , r = n(3650)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("symmetricDifference")
        }, {
            symmetricDifference: r
        })
    },
    1698: function(t, e, n) {
        var i = n(6518)
          , r = n(4204)
          , a = n(4916);
        i({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !a("union")
        }, {
            union: r
        })
    },
    7467: function(t, e, n) {
        var i = n(7628)
          , r = n(4644)
          , a = r.aTypedArray
          , o = r.exportTypedArrayMethod
          , s = r.getTypedArrayConstructor;
        o("toReversed", (function() {
            return i(a(this), s(this))
        }
        ))
    },
    4732: function(t, e, n) {
        var i = n(4644)
          , r = n(9504)
          , a = n(9306)
          , o = n(5370)
          , s = i.aTypedArray
          , c = i.getTypedArrayConstructor
          , l = i.exportTypedArrayMethod
          , u = r(i.TypedArrayPrototype.sort);
        l("toSorted", (function(t) {
            void 0 !== t && a(t);
            var e = s(this)
              , n = o(c(e), e);
            return u(n, t)
        }
        ))
    },
    9577: function(t, e, n) {
        var i = n(9928)
          , r = n(4644)
          , a = n(1108)
          , o = n(1291)
          , s = n(5854)
          , c = r.aTypedArray
          , l = r.getTypedArrayConstructor
          , u = r.exportTypedArrayMethod
          , h = !!function() {
            try {
                new Int8Array(1)["with"](2, {
                    valueOf: function() {
                        throw 8
                    }
                })
            } catch (t) {
                return 8 === t
            }
        }();
        u("with", {
            with: function(t, e) {
                var n = c(this)
                  , r = o(t)
                  , u = a(n) ? s(e) : +e;
                return i(n, l(n), r, u)
            }
        }["with"], !h)
    },
    3375: function(t, e, n) {
        n(7642)
    },
    9225: function(t, e, n) {
        n(8004)
    },
    3972: function(t, e, n) {
        n(3853)
    },
    9209: function(t, e, n) {
        n(5876)
    },
    5714: function(t, e, n) {
        n(2475)
    },
    7561: function(t, e, n) {
        n(5024)
    },
    6197: function(t, e, n) {
        n(1698)
    },
    6368: function(t, e, n) {
        var i = n(6518)
          , r = n(4475)
          , a = n(1606).clear;
        i({
            global: !0,
            bind: !0,
            enumerable: !0,
            forced: r.clearImmediate !== a
        }, {
            clearImmediate: a
        })
    },
    9848: function(t, e, n) {
        n(6368),
        n(9309)
    },
    9309: function(t, e, n) {
        var i = n(6518)
          , r = n(4475)
          , a = n(1606).set
          , o = n(9472)
          , s = r.setImmediate ? o(a, !1) : a;
        i({
            global: !0,
            bind: !0,
            enumerable: !0,
            forced: r.setImmediate !== s
        }, {
            setImmediate: s
        })
    },
    9318: function(t, e, n) {
        n.d(e, {
            $p8: function() {
                return yd
            },
            BH$: function() {
                return Fh
            },
            DXC: function() {
                return Oh
            },
            I9Y: function() {
                return Ln
            },
            JeP: function() {
                return bh
            },
            LoY: function() {
                return Hr
            },
            O9p: function() {
                return Wi
            },
            ONl: function() {
                return Hh
            },
            PTz: function() {
                return ri
            },
            Pq0: function() {
                return ai
            },
            Q1f: function() {
                return Er
            },
            Qev: function() {
                return nn
            },
            RlV: function() {
                return Di
            },
            Y9S: function() {
                return hd
            },
            YHV: function() {
                return Id
            },
            YJl: function() {
                return hh
            },
            Z58: function() {
                return Sh
            },
            Zcv: function() {
                return La
            },
            ZyN: function() {
                return _d
            },
            aHM: function() {
                return cd
            },
            cj9: function() {
                return Pn
            },
            eaF: function() {
                return oa
            },
            imn: function() {
                return Ar
            },
            kBv: function() {
                return r
            },
            mrM: function() {
                return Eh
            },
            qtW: function() {
                return Dr
            },
            tXL: function() {
                return jh
            },
            ubm: function() {
                return ba
            },
            wtR: function() {
                return a
            }
        });
        n(4114),
        n(6573),
        n(8100),
        n(7936),
        n(7467),
        n(4732),
        n(9577),
        n(3375),
        n(9225),
        n(3972),
        n(9209),
        n(5714),
        n(7561),
        n(6197);
        /**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
        const i = "164"
          , r = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
          , a = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
          , o = 0
          , s = 1
          , c = 2
          , l = 1
          , u = 2
          , h = 3
          , d = 0
          , p = 1
          , f = 2
          , m = 0
          , g = 1
          , v = 2
          , _ = 3
          , y = 4
          , x = 5
          , M = 100
          , b = 101
          , S = 102
          , E = 103
          , T = 104
          , w = 200
          , A = 201
          , R = 202
          , C = 203
          , P = 204
          , L = 205
          , I = 206
          , U = 207
          , D = 208
          , N = 209
          , O = 210
          , F = 211
          , B = 212
          , k = 213
          , z = 214
          , V = 0
          , H = 1
          , G = 2
          , j = 3
          , W = 4
          , X = 5
          , q = 6
          , $ = 7
          , Y = 0
          , K = 1
          , Z = 2
          , J = 0
          , Q = 1
          , tt = 2
          , et = 3
          , nt = 4
          , it = 5
          , rt = 6
          , at = 7
          , ot = 300
          , st = 301
          , ct = 302
          , lt = 303
          , ut = 304
          , ht = 306
          , dt = 1e3
          , pt = 1001
          , ft = 1002
          , mt = 1003
          , gt = 1004
          , vt = 1005
          , _t = 1006
          , yt = 1007
          , xt = 1008
          , Mt = 1009
          , bt = 1010
          , St = 1011
          , Et = 1012
          , Tt = 1013
          , wt = 1014
          , At = 1015
          , Rt = 1016
          , Ct = 1017
          , Pt = 1018
          , Lt = 1020
          , It = 35902
          , Ut = 1021
          , Dt = 1022
          , Nt = 1023
          , Ot = 1024
          , Ft = 1025
          , Bt = 1026
          , kt = 1027
          , zt = 1028
          , Vt = 1029
          , Ht = 1030
          , Gt = 1031
          , jt = 1033
          , Wt = 33776
          , Xt = 33777
          , qt = 33778
          , $t = 33779
          , Yt = 35840
          , Kt = 35841
          , Zt = 35842
          , Jt = 35843
          , Qt = 36196
          , te = 37492
          , ee = 37496
          , ne = 37808
          , ie = 37809
          , re = 37810
          , ae = 37811
          , oe = 37812
          , se = 37813
          , ce = 37814
          , le = 37815
          , ue = 37816
          , he = 37817
          , de = 37818
          , pe = 37819
          , fe = 37820
          , me = 37821
          , ge = 36492
          , ve = 36494
          , _e = 36495
          , ye = 36283
          , xe = 36284
          , Me = 36285
          , be = 36286
          , Se = 2300
          , Ee = 2301
          , Te = 2302
          , we = 2400
          , Ae = 2401
          , Re = 2402
          , Ce = 3200
          , Pe = 3201
          , Le = 0
          , Ie = 1
          , Ue = ""
          , De = "srgb"
          , Ne = "srgb-linear"
          , Oe = "display-p3"
          , Fe = "display-p3-linear"
          , Be = "linear"
          , ke = "srgb"
          , ze = "rec709"
          , Ve = "p3"
          , He = 7680
          , Ge = 519
          , je = 512
          , We = 513
          , Xe = 514
          , qe = 515
          , $e = 516
          , Ye = 517
          , Ke = 518
          , Ze = 519
          , Je = 35044
          , Qe = "300 es"
          , tn = 2e3
          , en = 2001;
        class nn {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners
                  , i = n[t];
                if (void 0 !== i) {
                    const t = i.indexOf(e);
                    -1 !== t && i.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners
                  , n = e[t.type];
                if (void 0 !== n) {
                    t.target = this;
                    const e = n.slice(0);
                    for (let n = 0, i = e.length; n < i; n++)
                        e[n].call(this, t);
                    t.target = null
                }
            }
        }
        const rn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let an = 1234567;
        const on = Math.PI / 180
          , sn = 180 / Math.PI;
        function cn() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0
              , r = rn[255 & t] + rn[t >> 8 & 255] + rn[t >> 16 & 255] + rn[t >> 24 & 255] + "-" + rn[255 & e] + rn[e >> 8 & 255] + "-" + rn[e >> 16 & 15 | 64] + rn[e >> 24 & 255] + "-" + rn[63 & n | 128] + rn[n >> 8 & 255] + "-" + rn[n >> 16 & 255] + rn[n >> 24 & 255] + rn[255 & i] + rn[i >> 8 & 255] + rn[i >> 16 & 255] + rn[i >> 24 & 255];
            return r.toLowerCase()
        }
        function ln(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function un(t, e) {
            return (t % e + e) % e
        }
        function hn(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        }
        function dn(t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0
        }
        function pn(t, e, n) {
            return (1 - n) * t + n * e
        }
        function fn(t, e, n, i) {
            return pn(t, e, 1 - Math.exp(-n * i))
        }
        function mn(t, e=1) {
            return e - Math.abs(un(t, 2 * e) - e)
        }
        function gn(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
            t * t * (3 - 2 * t))
        }
        function vn(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
            t * t * t * (t * (6 * t - 15) + 10))
        }
        function _n(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        }
        function yn(t, e) {
            return t + Math.random() * (e - t)
        }
        function xn(t) {
            return t * (.5 - Math.random())
        }
        function Mn(t) {
            void 0 !== t && (an = t);
            let e = an += 1831565813;
            return e = Math.imul(e ^ e >>> 15, 1 | e),
            e ^= e + Math.imul(e ^ e >>> 7, 61 | e),
            ((e ^ e >>> 14) >>> 0) / 4294967296
        }
        function bn(t) {
            return t * on
        }
        function Sn(t) {
            return t * sn
        }
        function En(t) {
            return 0 === (t & t - 1) && 0 !== t
        }
        function Tn(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function wn(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        function An(t, e, n, i, r) {
            const a = Math.cos
              , o = Math.sin
              , s = a(n / 2)
              , c = o(n / 2)
              , l = a((e + i) / 2)
              , u = o((e + i) / 2)
              , h = a((e - i) / 2)
              , d = o((e - i) / 2)
              , p = a((i - e) / 2)
              , f = o((i - e) / 2);
            switch (r) {
            case "XYX":
                t.set(s * u, c * h, c * d, s * l);
                break;
            case "YZY":
                t.set(c * d, s * u, c * h, s * l);
                break;
            case "ZXZ":
                t.set(c * h, c * d, s * u, s * l);
                break;
            case "XZX":
                t.set(s * u, c * f, c * p, s * l);
                break;
            case "YXY":
                t.set(c * p, s * u, c * f, s * l);
                break;
            case "ZYZ":
                t.set(c * f, c * p, s * u, s * l);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
        function Rn(t, e) {
            switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return t / 4294967295;
            case Uint16Array:
                return t / 65535;
            case Uint8Array:
                return t / 255;
            case Int32Array:
                return Math.max(t / 2147483647, -1);
            case Int16Array:
                return Math.max(t / 32767, -1);
            case Int8Array:
                return Math.max(t / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function Cn(t, e) {
            switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return Math.round(4294967295 * t);
            case Uint16Array:
                return Math.round(65535 * t);
            case Uint8Array:
                return Math.round(255 * t);
            case Int32Array:
                return Math.round(2147483647 * t);
            case Int16Array:
                return Math.round(32767 * t);
            case Int8Array:
                return Math.round(127 * t);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const Pn = {
            DEG2RAD: on,
            RAD2DEG: sn,
            generateUUID: cn,
            clamp: ln,
            euclideanModulo: un,
            mapLinear: hn,
            inverseLerp: dn,
            lerp: pn,
            damp: fn,
            pingpong: mn,
            smoothstep: gn,
            smootherstep: vn,
            randInt: _n,
            randFloat: yn,
            randFloatSpread: xn,
            seededRandom: Mn,
            degToRad: bn,
            radToDeg: Sn,
            isPowerOfTwo: En,
            ceilPowerOfTwo: Tn,
            floorPowerOfTwo: wn,
            setQuaternionFromProperEuler: An,
            normalize: Cn,
            denormalize: Rn
        };
        class Ln {
            constructor(t=0, e=0) {
                Ln.prototype.isVector2 = !0,
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6],
                this.y = i[1] * e + i[4] * n + i[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                const t = Math.atan2(-this.y, -this.x) + Math.PI;
                return t
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(ln(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = this.x - t.x
                  , a = this.y - t.y;
                return this.x = r * n - a * i + t.x,
                this.y = r * i + a * n + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class In {
            constructor(t, e, n, i, r, a, o, s, c) {
                In.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== t && this.set(t, e, n, i, r, a, o, s, c)
            }
            set(t, e, n, i, r, a, o, s, c) {
                const l = this.elements;
                return l[0] = t,
                l[1] = i,
                l[2] = o,
                l[3] = e,
                l[4] = r,
                l[5] = s,
                l[6] = n,
                l[7] = a,
                l[8] = c,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , a = n[0]
                  , o = n[3]
                  , s = n[6]
                  , c = n[1]
                  , l = n[4]
                  , u = n[7]
                  , h = n[2]
                  , d = n[5]
                  , p = n[8]
                  , f = i[0]
                  , m = i[3]
                  , g = i[6]
                  , v = i[1]
                  , _ = i[4]
                  , y = i[7]
                  , x = i[2]
                  , M = i[5]
                  , b = i[8];
                return r[0] = a * f + o * v + s * x,
                r[3] = a * m + o * _ + s * M,
                r[6] = a * g + o * y + s * b,
                r[1] = c * f + l * v + u * x,
                r[4] = c * m + l * _ + u * M,
                r[7] = c * g + l * y + u * b,
                r[2] = h * f + d * v + p * x,
                r[5] = h * m + d * _ + p * M,
                r[8] = h * g + d * y + p * b,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , a = t[4]
                  , o = t[5]
                  , s = t[6]
                  , c = t[7]
                  , l = t[8];
                return e * a * l - e * o * c - n * r * l + n * o * s + i * r * c - i * a * s
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , a = t[4]
                  , o = t[5]
                  , s = t[6]
                  , c = t[7]
                  , l = t[8]
                  , u = l * a - o * c
                  , h = o * s - l * r
                  , d = c * r - a * s
                  , p = e * u + n * h + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f,
                t[1] = (i * c - l * n) * f,
                t[2] = (o * n - i * a) * f,
                t[3] = h * f,
                t[4] = (l * e - i * s) * f,
                t[5] = (i * r - o * e) * f,
                t[6] = d * f,
                t[7] = (n * s - c * e) * f,
                t[8] = (a * e - n * r) * f,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, n, i, r, a, o) {
                const s = Math.cos(r)
                  , c = Math.sin(r);
                return this.set(n * s, n * c, -n * (s * a + c * o) + a + t, -i * c, i * s, -i * (-c * a + s * o) + o + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                return this.premultiply(Un.makeScale(t, e)),
                this
            }
            rotate(t) {
                return this.premultiply(Un.makeRotation(-t)),
                this
            }
            translate(t, e) {
                return this.premultiply(Un.makeTranslation(t, e)),
                this
            }
            makeTranslation(t, e) {
                return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
                this
            }
            makeRotation(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, n, e, 0, 0, 0, 1),
                this
            }
            makeScale(t, e) {
                return this.set(t, 0, 0, 0, e, 0, 0, 0, 1),
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let i = 0; i < 9; i++)
                    if (e[i] !== n[i])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Un = new In;
        function Dn(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535)
                    return !0;
            return !1
        }
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        function Nn(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }
        function On() {
            const t = Nn("canvas");
            return t.style.display = "block",
            t
        }
        const Fn = {};
        function Bn(t) {
            t in Fn || (Fn[t] = !0,
            console.warn(t))
        }
        const kn = (new In).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , zn = (new In).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , Vn = {
            [Ne]: {
                transfer: Be,
                primaries: ze,
                toReference: t=>t,
                fromReference: t=>t
            },
            [De]: {
                transfer: ke,
                primaries: ze,
                toReference: t=>t.convertSRGBToLinear(),
                fromReference: t=>t.convertLinearToSRGB()
            },
            [Fe]: {
                transfer: Be,
                primaries: Ve,
                toReference: t=>t.applyMatrix3(zn),
                fromReference: t=>t.applyMatrix3(kn)
            },
            [Oe]: {
                transfer: ke,
                primaries: Ve,
                toReference: t=>t.convertSRGBToLinear().applyMatrix3(zn),
                fromReference: t=>t.applyMatrix3(kn).convertLinearToSRGB()
            }
        }
          , Hn = new Set([Ne, Fe])
          , Gn = {
            enabled: !0,
            _workingColorSpace: Ne,
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(t) {
                if (!Hn.has(t))
                    throw new Error(`Unsupported working color space, "${t}".`);
                this._workingColorSpace = t
            },
            convert: function(t, e, n) {
                if (!1 === this.enabled || e === n || !e || !n)
                    return t;
                const i = Vn[e].toReference
                  , r = Vn[n].fromReference;
                return r(i(t))
            },
            fromWorkingColorSpace: function(t, e) {
                return this.convert(t, this._workingColorSpace, e)
            },
            toWorkingColorSpace: function(t, e) {
                return this.convert(t, e, this._workingColorSpace)
            },
            getPrimaries: function(t) {
                return Vn[t].primaries
            },
            getTransfer: function(t) {
                return t === Ue ? Be : Vn[t].transfer
            }
        };
        function jn(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function Wn(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        let Xn;
        class qn {
            static getDataURL(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" === typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === Xn && (Xn = Nn("canvas")),
                    Xn.width = t.width,
                    Xn.height = t.height;
                    const n = Xn.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                    e = Xn
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Nn("canvas");
                    e.width = t.width,
                    e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height)
                      , r = i.data;
                    for (let t = 0; t < r.length; t++)
                        r[t] = 255 * jn(r[t] / 255);
                    return n.putImageData(i, 0, 0),
                    e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++)
                        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * jn(e[t] / 255)) : e[t] = jn(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                t
            }
        }
        let $n = 0;
        class Yn {
            constructor(t=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: $n++
                }),
                this.uuid = cn(),
                this.data = t,
                this.dataReady = !0,
                this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" === typeof t;
                if (!e && void 0 !== t.images[this.uuid])
                    return t.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , i = this.data;
                if (null !== i) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++)
                            i[e].isDataTexture ? t.push(Kn(i[e].image)) : t.push(Kn(i[e]))
                    } else
                        t = Kn(i);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n),
                n
            }
        }
        function Kn(t) {
            return "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap ? qn.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let Zn = 0;
        class Jn extends nn {
            constructor(t=Jn.DEFAULT_IMAGE, e=Jn.DEFAULT_MAPPING, n=pt, i=pt, r=_t, a=xt, o=Nt, s=Mt, c=Jn.DEFAULT_ANISOTROPY, l=Ue) {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: Zn++
                }),
                this.uuid = cn(),
                this.name = "",
                this.source = new Yn(t),
                this.mipmaps = [],
                this.mapping = e,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = a,
                this.anisotropy = c,
                this.format = o,
                this.internalFormat = null,
                this.type = s,
                this.offset = new Ln(0,0),
                this.repeat = new Ln(1,1),
                this.center = new Ln(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new In,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.colorSpace = l,
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.pmremVersion = 0
            }
            get image() {
                return this.source.data
            }
            set image(t=null) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.source = t.source,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.channel = t.channel,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.colorSpace = t.colorSpace,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" === typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                e || (t.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (this.mapping !== ot)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case dt:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case pt:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case ft:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                        break
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case dt:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case pt:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case ft:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                        break
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++,
                this.source.needsUpdate = !0)
            }
            set needsPMREMUpdate(t) {
                !0 === t && this.pmremVersion++
            }
        }
        Jn.DEFAULT_IMAGE = null,
        Jn.DEFAULT_MAPPING = ot,
        Jn.DEFAULT_ANISOTROPY = 1;
        class Qn {
            constructor(t=0, e=0, n=0, i=1) {
                Qn.prototype.isVector4 = !0,
                this.x = t,
                this.y = e,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t,
                this.y = e,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , a = t.elements;
                return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r,
                this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r,
                this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r,
                this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const a = .01
                  , o = .1
                  , s = t.elements
                  , c = s[0]
                  , l = s[4]
                  , u = s[8]
                  , h = s[1]
                  , d = s[5]
                  , p = s[9]
                  , f = s[2]
                  , m = s[6]
                  , g = s[10];
                if (Math.abs(l - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                    if (Math.abs(l + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(c + d + g - 3) < o)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (c + 1) / 2
                      , s = (d + 1) / 2
                      , v = (g + 1) / 2
                      , _ = (l + h) / 4
                      , y = (u + f) / 4
                      , x = (p + m) / 4;
                    return t > s && t > v ? t < a ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(t),
                    i = _ / n,
                    r = y / n) : s > v ? s < a ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(s),
                    n = _ / i,
                    r = x / i) : v < a ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(v),
                    n = y / r,
                    i = x / r),
                    this.set(n, i, r, e),
                    this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - p) / v,
                this.y = (u - f) / v,
                this.z = (h - l) / v,
                this.w = Math.acos((c + d + g - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this.w = t.w + (e.w - t.w) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class ti extends nn {
            constructor(t=1, e=1, n={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new Qn(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new Qn(0,0,t,e);
                const i = {
                    width: t,
                    height: e,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: _t,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    resolveDepthBuffer: !0,
                    resolveStencilBuffer: !0,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const r = new Jn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
                r.flipY = !1,
                r.generateMipmaps = n.generateMipmaps,
                r.internalFormat = n.internalFormat,
                this.textures = [];
                const a = n.count;
                for (let o = 0; o < a; o++)
                    this.textures[o] = r.clone(),
                    this.textures[o].isRenderTargetTexture = !0;
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.resolveDepthBuffer = n.resolveDepthBuffer,
                this.resolveStencilBuffer = n.resolveStencilBuffer,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            get texture() {
                return this.textures[0]
            }
            set texture(t) {
                this.textures[0] = t
            }
            setSize(t, e, n=1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t,
                    this.height = e,
                    this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++)
                        this.textures[i].image.width = t,
                        this.textures[i].image.height = e,
                        this.textures[i].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.scissor.copy(t.scissor),
                this.scissorTest = t.scissorTest,
                this.viewport.copy(t.viewport),
                this.textures.length = 0;
                for (let n = 0, i = t.textures.length; n < i; n++)
                    this.textures[n] = t.textures[n].clone(),
                    this.textures[n].isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new Yn(e),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.resolveDepthBuffer = t.resolveDepthBuffer,
                this.resolveStencilBuffer = t.resolveStencilBuffer,
                null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
                this.samples = t.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class ei extends ti {
            constructor(t=1, e=1, n={}) {
                super(t, e, n),
                this.isWebGLRenderTarget = !0
            }
        }
        class ni extends Jn {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = mt,
                this.minFilter = mt,
                this.wrapR = pt,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class ii extends Jn {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = mt,
                this.minFilter = mt,
                this.wrapR = pt,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class ri {
            constructor(t=0, e=0, n=0, i=1) {
                this.isQuaternion = !0,
                this._x = t,
                this._y = e,
                this._z = n,
                this._w = i
            }
            static slerpFlat(t, e, n, i, r, a, o) {
                let s = n[i + 0]
                  , c = n[i + 1]
                  , l = n[i + 2]
                  , u = n[i + 3];
                const h = r[a + 0]
                  , d = r[a + 1]
                  , p = r[a + 2]
                  , f = r[a + 3];
                if (0 === o)
                    return t[e + 0] = s,
                    t[e + 1] = c,
                    t[e + 2] = l,
                    void (t[e + 3] = u);
                if (1 === o)
                    return t[e + 0] = h,
                    t[e + 1] = d,
                    t[e + 2] = p,
                    void (t[e + 3] = f);
                if (u !== f || s !== h || c !== d || l !== p) {
                    let t = 1 - o;
                    const e = s * h + c * d + l * p + u * f
                      , n = e >= 0 ? 1 : -1
                      , i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , a = Math.atan2(r, e * n);
                        t = Math.sin(t * a) / r,
                        o = Math.sin(o * a) / r
                    }
                    const r = o * n;
                    if (s = s * t + h * r,
                    c = c * t + d * r,
                    l = l * t + p * r,
                    u = u * t + f * r,
                    t === 1 - o) {
                        const t = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                        s *= t,
                        c *= t,
                        l *= t,
                        u *= t
                    }
                }
                t[e] = s,
                t[e + 1] = c,
                t[e + 2] = l,
                t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, a) {
                const o = n[i]
                  , s = n[i + 1]
                  , c = n[i + 2]
                  , l = n[i + 3]
                  , u = r[a]
                  , h = r[a + 1]
                  , d = r[a + 2]
                  , p = r[a + 3];
                return t[e] = o * p + l * u + s * d - c * h,
                t[e + 1] = s * p + l * h + c * u - o * d,
                t[e + 2] = c * p + l * d + o * h - s * u,
                t[e + 3] = l * p - o * u - s * h - c * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e=!0) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , a = t._order
                  , o = Math.cos
                  , s = Math.sin
                  , c = o(n / 2)
                  , l = o(i / 2)
                  , u = o(r / 2)
                  , h = s(n / 2)
                  , d = s(i / 2)
                  , p = s(r / 2);
                switch (a) {
                case "XYZ":
                    this._x = h * l * u + c * d * p,
                    this._y = c * d * u - h * l * p,
                    this._z = c * l * p + h * d * u,
                    this._w = c * l * u - h * d * p;
                    break;
                case "YXZ":
                    this._x = h * l * u + c * d * p,
                    this._y = c * d * u - h * l * p,
                    this._z = c * l * p - h * d * u,
                    this._w = c * l * u + h * d * p;
                    break;
                case "ZXY":
                    this._x = h * l * u - c * d * p,
                    this._y = c * d * u + h * l * p,
                    this._z = c * l * p + h * d * u,
                    this._w = c * l * u - h * d * p;
                    break;
                case "ZYX":
                    this._x = h * l * u - c * d * p,
                    this._y = c * d * u + h * l * p,
                    this._z = c * l * p - h * d * u,
                    this._w = c * l * u + h * d * p;
                    break;
                case "YZX":
                    this._x = h * l * u + c * d * p,
                    this._y = c * d * u + h * l * p,
                    this._z = c * l * p - h * d * u,
                    this._w = c * l * u - h * d * p;
                    break;
                case "XZY":
                    this._x = h * l * u - c * d * p,
                    this._y = c * d * u - h * l * p,
                    this._z = c * l * p + h * d * u,
                    this._w = c * l * u + h * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                }
                return !0 === e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                  , i = Math.sin(n);
                return this._x = t.x * i,
                this._y = t.y * i,
                this._z = t.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , n = e[0]
                  , i = e[4]
                  , r = e[8]
                  , a = e[1]
                  , o = e[5]
                  , s = e[9]
                  , c = e[2]
                  , l = e[6]
                  , u = e[10]
                  , h = n + o + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t,
                    this._x = (l - s) * t,
                    this._y = (r - c) * t,
                    this._z = (a - i) * t
                } else if (n > o && n > u) {
                    const t = 2 * Math.sqrt(1 + n - o - u);
                    this._w = (l - s) / t,
                    this._x = .25 * t,
                    this._y = (i + a) / t,
                    this._z = (r + c) / t
                } else if (o > u) {
                    const t = 2 * Math.sqrt(1 + o - n - u);
                    this._w = (r - c) / t,
                    this._x = (i + a) / t,
                    this._y = .25 * t,
                    this._z = (s + l) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - o);
                    this._w = (a - i) / t,
                    this._x = (r + c) / t,
                    this._y = (s + l) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = n),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(ln(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , a = t._w
                  , o = e._x
                  , s = e._y
                  , c = e._z
                  , l = e._w;
                return this._x = n * l + a * o + i * c - r * s,
                this._y = i * l + a * s + r * o - n * c,
                this._z = r * l + a * c + n * s - i * o,
                this._w = a * l - n * o - i * s - r * c,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , a = this._w;
                let o = a * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                o = -o) : this.copy(t),
                o >= 1)
                    return this._w = a,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const s = 1 - o * o;
                if (s <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * a + e * this._w,
                    this._x = t * n + e * this._x,
                    this._y = t * i + e * this._y,
                    this._z = t * r + e * this._z,
                    this.normalize(),
                    this
                }
                const c = Math.sqrt(s)
                  , l = Math.atan2(c, o)
                  , u = Math.sin((1 - e) * l) / c
                  , h = Math.sin(e * l) / c;
                return this._w = a * u + this._w * h,
                this._x = n * u + this._x * h,
                this._y = i * u + this._y * h,
                this._z = r * u + this._z * h,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = 2 * Math.PI * Math.random()
                  , e = 2 * Math.PI * Math.random()
                  , n = Math.random()
                  , i = Math.sqrt(1 - n)
                  , r = Math.sqrt(n);
                return this.set(i * Math.sin(t), i * Math.cos(t), r * Math.sin(e), r * Math.cos(e))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this._onChangeCallback(),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class ai {
            constructor(t=0, e=0, n=0) {
                ai.prototype.isVector3 = !0,
                this.x = t,
                this.y = e,
                this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                this.x = t,
                this.y = e,
                this.z = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return this.applyQuaternion(si.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(si.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i,
                this.y = r[1] * e + r[4] * n + r[7] * i,
                this.z = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements
                  , a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a,
                this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a,
                this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.x
                  , a = t.y
                  , o = t.z
                  , s = t.w
                  , c = 2 * (a * i - o * n)
                  , l = 2 * (o * e - r * i)
                  , u = 2 * (r * n - a * e);
                return this.x = e + s * c + a * u - o * l,
                this.y = n + s * l + o * c - r * u,
                this.z = i + s * u + r * l - a * c,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i,
                this.y = r[1] * e + r[5] * n + r[9] * i,
                this.z = r[2] * e + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , a = e.x
                  , o = e.y
                  , s = e.z;
                return this.x = i * s - r * o,
                this.y = r * a - n * s,
                this.z = n * o - i * a,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return oi.copy(this).projectOnVector(t),
                this.sub(oi)
            }
            reflect(t) {
                return this.sub(oi.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(ln(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y
                  , i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(e) * t,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                this.y = n,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , n = this.setFromMatrixColumn(t, 1).length()
                  , i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x,
                this.y = t._y,
                this.z = t._z,
                this
            }
            setFromColor(t) {
                return this.x = t.r,
                this.y = t.g,
                this.z = t.b,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const t = Math.random() * Math.PI * 2
                  , e = 2 * Math.random() - 1
                  , n = Math.sqrt(1 - e * e);
                return this.x = n * Math.cos(t),
                this.y = e,
                this.z = n * Math.sin(t),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const oi = new ai
          , si = new ri;
        class ci {
            constructor(t=new ai(1 / 0,1 / 0,1 / 0), e=new ai(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e += 3)
                    this.expandByPoint(ui.fromArray(t, e));
                return this
            }
            setFromBufferAttribute(t) {
                this.makeEmpty();
                for (let e = 0, n = t.count; e < n; e++)
                    this.expandByPoint(ui.fromBufferAttribute(t, e));
                return this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = ui.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            setFromObject(t, e=!1) {
                return this.makeEmpty(),
                this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t, e=!1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
                        for (let e = 0, n = i.count; e < n; e++)
                            !0 === t.isMesh ? t.getVertexPosition(e, ui) : ui.fromBufferAttribute(i, e),
                            ui.applyMatrix4(t.matrixWorld),
                            this.expandByPoint(ui);
                    else
                        void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(),
                        hi.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                        hi.copy(n.boundingBox)),
                        hi.applyMatrix4(t.matrixWorld),
                        this.union(hi)
                }
                const i = t.children;
                for (let r = 0, a = i.length; r < a; r++)
                    this.expandByObject(i[r], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, ui),
                ui.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(_i),
                yi.subVectors(this.max, _i),
                di.subVectors(t.a, _i),
                pi.subVectors(t.b, _i),
                fi.subVectors(t.c, _i),
                mi.subVectors(pi, di),
                gi.subVectors(fi, pi),
                vi.subVectors(di, fi);
                let e = [0, -mi.z, mi.y, 0, -gi.z, gi.y, 0, -vi.z, vi.y, mi.z, 0, -mi.x, gi.z, 0, -gi.x, vi.z, 0, -vi.x, -mi.y, mi.x, 0, -gi.y, gi.x, 0, -vi.y, vi.x, 0];
                return !!bi(e, di, pi, fi, yi) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!bi(e, di, pi, fi, yi) && (xi.crossVectors(mi, gi),
                e = [xi.x, xi.y, xi.z],
                bi(e, di, pi, fi, yi)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return this.clampPoint(t, ui).distanceTo(t)
            }
            getBoundingSphere(t) {
                return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center),
                t.radius = .5 * this.getSize(ui).length()),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (li[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                li[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                li[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                li[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                li[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                li[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                li[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                li[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(li)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const li = [new ai, new ai, new ai, new ai, new ai, new ai, new ai, new ai]
          , ui = new ai
          , hi = new ci
          , di = new ai
          , pi = new ai
          , fi = new ai
          , mi = new ai
          , gi = new ai
          , vi = new ai
          , _i = new ai
          , yi = new ai
          , xi = new ai
          , Mi = new ai;
        function bi(t, e, n, i, r) {
            for (let a = 0, o = t.length - 3; a <= o; a += 3) {
                Mi.fromArray(t, a);
                const o = r.x * Math.abs(Mi.x) + r.y * Math.abs(Mi.y) + r.z * Math.abs(Mi.z)
                  , s = e.dot(Mi)
                  , c = n.dot(Mi)
                  , l = i.dot(Mi);
                if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > o)
                    return !1
            }
            return !0
        }
        const Si = new ci
          , Ei = new ai
          , Ti = new ai;
        class wi {
            constructor(t=new ai, e=-1) {
                this.isSphere = !0,
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Si.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let r = 0, a = t.length; r < a; r++)
                    i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            expandByPoint(t) {
                if (this.isEmpty())
                    return this.center.copy(t),
                    this.radius = 0,
                    this;
                Ei.subVectors(t, this.center);
                const e = Ei.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                      , n = .5 * (t - this.radius);
                    this.center.addScaledVector(Ei, n / t),
                    this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t),
                this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Ti.subVectors(t.center, this.center).setLength(t.radius),
                this.expandByPoint(Ei.copy(t.center).add(Ti)),
                this.expandByPoint(Ei.copy(t.center).sub(Ti))),
                this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ai = new ai
          , Ri = new ai
          , Ci = new ai
          , Pi = new ai
          , Li = new ai
          , Ii = new ai
          , Ui = new ai;
        class Di {
            constructor(t=new ai, e=new ai(0,0,-1)) {
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return e.copy(this.origin).addScaledVector(this.direction, t)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Ai)),
                this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Ai.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Ai.copy(this.origin).addScaledVector(this.direction, e),
                Ai.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Ri.copy(t).add(e).multiplyScalar(.5),
                Ci.copy(e).sub(t).normalize(),
                Pi.copy(this.origin).sub(Ri);
                const r = .5 * t.distanceTo(e)
                  , a = -this.direction.dot(Ci)
                  , o = Pi.dot(this.direction)
                  , s = -Pi.dot(Ci)
                  , c = Pi.lengthSq()
                  , l = Math.abs(1 - a * a);
                let u, h, d, p;
                if (l > 0)
                    if (u = a * s - o,
                    h = a * o - s,
                    p = r * l,
                    u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const t = 1 / l;
                                u *= t,
                                h *= t,
                                d = u * (u + a * h + 2 * o) + h * (a * u + h + 2 * s) + c
                            } else
                                h = r,
                                u = Math.max(0, -(a * h + o)),
                                d = -u * u + h * (h + 2 * s) + c;
                        else
                            h = -r,
                            u = Math.max(0, -(a * h + o)),
                            d = -u * u + h * (h + 2 * s) + c;
                    else
                        h <= -p ? (u = Math.max(0, -(-a * r + o)),
                        h = u > 0 ? -r : Math.min(Math.max(-r, -s), r),
                        d = -u * u + h * (h + 2 * s) + c) : h <= p ? (u = 0,
                        h = Math.min(Math.max(-r, -s), r),
                        d = h * (h + 2 * s) + c) : (u = Math.max(0, -(a * r + o)),
                        h = u > 0 ? r : Math.min(Math.max(-r, -s), r),
                        d = -u * u + h * (h + 2 * s) + c);
                else
                    h = a > 0 ? -r : r,
                    u = Math.max(0, -(a * h + o)),
                    d = -u * u + h * (h + 2 * s) + c;
                return n && n.copy(this.origin).addScaledVector(this.direction, u),
                i && i.copy(Ri).addScaledVector(Ci, h),
                d
            }
            intersectSphere(t, e) {
                Ai.subVectors(t.center, this.origin);
                const n = Ai.dot(this.direction)
                  , i = Ai.dot(Ai) - n * n
                  , r = t.radius * t.radius;
                if (i > r)
                    return null;
                const a = Math.sqrt(r - i)
                  , o = n - a
                  , s = n + a;
                return s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e)
                    return !0;
                const n = t.normal.dot(this.direction);
                return n * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, a, o, s;
                const c = 1 / this.direction.x
                  , l = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , h = this.origin;
                return c >= 0 ? (n = (t.min.x - h.x) * c,
                i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c,
                i = (t.min.x - h.x) * c),
                l >= 0 ? (r = (t.min.y - h.y) * l,
                a = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l,
                a = (t.min.y - h.y) * l),
                n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                (a < i || isNaN(i)) && (i = a),
                u >= 0 ? (o = (t.min.z - h.z) * u,
                s = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u,
                s = (t.min.z - h.z) * u),
                n > s || o > i ? null : ((o > n || n !== n) && (n = o),
                (s < i || i !== i) && (i = s),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Ai)
            }
            intersectTriangle(t, e, n, i, r) {
                Li.subVectors(e, t),
                Ii.subVectors(n, t),
                Ui.crossVectors(Li, Ii);
                let a, o = this.direction.dot(Ui);
                if (o > 0) {
                    if (i)
                        return null;
                    a = 1
                } else {
                    if (!(o < 0))
                        return null;
                    a = -1,
                    o = -o
                }
                Pi.subVectors(this.origin, t);
                const s = a * this.direction.dot(Ii.crossVectors(Pi, Ii));
                if (s < 0)
                    return null;
                const c = a * this.direction.dot(Li.cross(Pi));
                if (c < 0)
                    return null;
                if (s + c > o)
                    return null;
                const l = -a * Pi.dot(Ui);
                return l < 0 ? null : this.at(l / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ni {
            constructor(t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m) {
                Ni.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== t && this.set(t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m)
            }
            set(t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = a,
                g[9] = o,
                g[13] = s,
                g[2] = c,
                g[6] = l,
                g[10] = u,
                g[14] = h,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Ni).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , n = t.elements
                  , i = 1 / Oi.setFromMatrixColumn(t, 0).length()
                  , r = 1 / Oi.setFromMatrixColumn(t, 1).length()
                  , a = 1 / Oi.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i,
                e[1] = n[1] * i,
                e[2] = n[2] * i,
                e[3] = 0,
                e[4] = n[4] * r,
                e[5] = n[5] * r,
                e[6] = n[6] * r,
                e[7] = 0,
                e[8] = n[8] * a,
                e[9] = n[9] * a,
                e[10] = n[10] * a,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z
                  , a = Math.cos(n)
                  , o = Math.sin(n)
                  , s = Math.cos(i)
                  , c = Math.sin(i)
                  , l = Math.cos(r)
                  , u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = a * l
                      , n = a * u
                      , i = o * l
                      , r = o * u;
                    e[0] = s * l,
                    e[4] = -s * u,
                    e[8] = c,
                    e[1] = n + i * c,
                    e[5] = t - r * c,
                    e[9] = -o * s,
                    e[2] = r - t * c,
                    e[6] = i + n * c,
                    e[10] = a * s
                } else if ("YXZ" === t.order) {
                    const t = s * l
                      , n = s * u
                      , i = c * l
                      , r = c * u;
                    e[0] = t + r * o,
                    e[4] = i * o - n,
                    e[8] = a * c,
                    e[1] = a * u,
                    e[5] = a * l,
                    e[9] = -o,
                    e[2] = n * o - i,
                    e[6] = r + t * o,
                    e[10] = a * s
                } else if ("ZXY" === t.order) {
                    const t = s * l
                      , n = s * u
                      , i = c * l
                      , r = c * u;
                    e[0] = t - r * o,
                    e[4] = -a * u,
                    e[8] = i + n * o,
                    e[1] = n + i * o,
                    e[5] = a * l,
                    e[9] = r - t * o,
                    e[2] = -a * c,
                    e[6] = o,
                    e[10] = a * s
                } else if ("ZYX" === t.order) {
                    const t = a * l
                      , n = a * u
                      , i = o * l
                      , r = o * u;
                    e[0] = s * l,
                    e[4] = i * c - n,
                    e[8] = t * c + r,
                    e[1] = s * u,
                    e[5] = r * c + t,
                    e[9] = n * c - i,
                    e[2] = -c,
                    e[6] = o * s,
                    e[10] = a * s
                } else if ("YZX" === t.order) {
                    const t = a * s
                      , n = a * c
                      , i = o * s
                      , r = o * c;
                    e[0] = s * l,
                    e[4] = r - t * u,
                    e[8] = i * u + n,
                    e[1] = u,
                    e[5] = a * l,
                    e[9] = -o * l,
                    e[2] = -c * l,
                    e[6] = n * u + i,
                    e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = a * s
                      , n = a * c
                      , i = o * s
                      , r = o * c;
                    e[0] = s * l,
                    e[4] = -u,
                    e[8] = c * l,
                    e[1] = t * u + r,
                    e[5] = a * l,
                    e[9] = n * u - i,
                    e[2] = i * u - n,
                    e[6] = o * l,
                    e[10] = r * u + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Bi, t, ki)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return Hi.subVectors(t, e),
                0 === Hi.lengthSq() && (Hi.z = 1),
                Hi.normalize(),
                zi.crossVectors(n, Hi),
                0 === zi.lengthSq() && (1 === Math.abs(n.z) ? Hi.x += 1e-4 : Hi.z += 1e-4,
                Hi.normalize(),
                zi.crossVectors(n, Hi)),
                zi.normalize(),
                Vi.crossVectors(Hi, zi),
                i[0] = zi.x,
                i[4] = Vi.x,
                i[8] = Hi.x,
                i[1] = zi.y,
                i[5] = Vi.y,
                i[9] = Hi.y,
                i[2] = zi.z,
                i[6] = Vi.z,
                i[10] = Hi.z,
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , a = n[0]
                  , o = n[4]
                  , s = n[8]
                  , c = n[12]
                  , l = n[1]
                  , u = n[5]
                  , h = n[9]
                  , d = n[13]
                  , p = n[2]
                  , f = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , _ = n[7]
                  , y = n[11]
                  , x = n[15]
                  , M = i[0]
                  , b = i[4]
                  , S = i[8]
                  , E = i[12]
                  , T = i[1]
                  , w = i[5]
                  , A = i[9]
                  , R = i[13]
                  , C = i[2]
                  , P = i[6]
                  , L = i[10]
                  , I = i[14]
                  , U = i[3]
                  , D = i[7]
                  , N = i[11]
                  , O = i[15];
                return r[0] = a * M + o * T + s * C + c * U,
                r[4] = a * b + o * w + s * P + c * D,
                r[8] = a * S + o * A + s * L + c * N,
                r[12] = a * E + o * R + s * I + c * O,
                r[1] = l * M + u * T + h * C + d * U,
                r[5] = l * b + u * w + h * P + d * D,
                r[9] = l * S + u * A + h * L + d * N,
                r[13] = l * E + u * R + h * I + d * O,
                r[2] = p * M + f * T + m * C + g * U,
                r[6] = p * b + f * w + m * P + g * D,
                r[10] = p * S + f * A + m * L + g * N,
                r[14] = p * E + f * R + m * I + g * O,
                r[3] = v * M + _ * T + y * C + x * U,
                r[7] = v * b + _ * w + y * P + x * D,
                r[11] = v * S + _ * A + y * L + x * N,
                r[15] = v * E + _ * R + y * I + x * O,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[4]
                  , i = t[8]
                  , r = t[12]
                  , a = t[1]
                  , o = t[5]
                  , s = t[9]
                  , c = t[13]
                  , l = t[2]
                  , u = t[6]
                  , h = t[10]
                  , d = t[14]
                  , p = t[3]
                  , f = t[7]
                  , m = t[11]
                  , g = t[15];
                return p * (+r * s * u - i * c * u - r * o * h + n * c * h + i * o * d - n * s * d) + f * (+e * s * d - e * c * h + r * a * h - i * a * d + i * c * l - r * s * l) + m * (+e * c * u - e * o * d - r * a * u + n * a * d + r * o * l - n * c * l) + g * (-i * o * l - e * s * u + e * o * h + i * a * u - n * a * h + n * s * l)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z) : (i[12] = t,
                i[13] = e,
                i[14] = n),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , a = t[4]
                  , o = t[5]
                  , s = t[6]
                  , c = t[7]
                  , l = t[8]
                  , u = t[9]
                  , h = t[10]
                  , d = t[11]
                  , p = t[12]
                  , f = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = u * m * c - f * h * c + f * s * d - o * m * d - u * s * g + o * h * g
                  , _ = p * h * c - l * m * c - p * s * d + a * m * d + l * s * g - a * h * g
                  , y = l * f * c - p * u * c + p * o * d - a * f * d - l * o * g + a * u * g
                  , x = p * u * s - l * f * s - p * o * h + a * f * h + l * o * m - a * u * m
                  , M = e * v + n * _ + i * y + r * x;
                if (0 === M)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const b = 1 / M;
                return t[0] = v * b,
                t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * b,
                t[2] = (o * m * r - f * s * r + f * i * c - n * m * c - o * i * g + n * s * g) * b,
                t[3] = (u * s * r - o * h * r - u * i * c + n * h * c + o * i * d - n * s * d) * b,
                t[4] = _ * b,
                t[5] = (l * m * r - p * h * r + p * i * d - e * m * d - l * i * g + e * h * g) * b,
                t[6] = (p * s * r - a * m * r - p * i * c + e * m * c + a * i * g - e * s * g) * b,
                t[7] = (a * h * r - l * s * r + l * i * c - e * h * c - a * i * d + e * s * d) * b,
                t[8] = y * b,
                t[9] = (p * u * r - l * f * r - p * n * d + e * f * d + l * n * g - e * u * g) * b,
                t[10] = (a * f * r - p * o * r + p * n * c - e * f * c - a * n * g + e * o * g) * b,
                t[11] = (l * o * r - a * u * r - l * n * c + e * u * c + a * n * d - e * o * d) * b,
                t[12] = x * b,
                t[13] = (l * f * i - p * u * i + p * n * h - e * f * h - l * n * m + e * u * m) * b,
                t[14] = (p * o * i - a * f * i - p * n * s + e * f * s + a * n * m - e * o * m) * b,
                t[15] = (a * u * i - l * o * i + l * n * s - e * u * s - a * n * h + e * o * h) * b,
                this
            }
            scale(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z;
                return e[0] *= n,
                e[4] *= i,
                e[8] *= r,
                e[1] *= n,
                e[5] *= i,
                e[9] *= r,
                e[2] *= n,
                e[6] *= i,
                e[10] *= r,
                e[3] *= n,
                e[7] *= i,
                e[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = 1 - n
                  , a = t.x
                  , o = t.y
                  , s = t.z
                  , c = r * a
                  , l = r * o;
                return this.set(c * a + n, c * o - i * s, c * s + i * o, 0, c * o + i * s, l * o + n, l * s - i * a, 0, c * s - i * o, l * s + i * a, r * s * s + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, n, i, r, a) {
                return this.set(1, n, r, 0, t, 1, a, 0, e, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, n) {
                const i = this.elements
                  , r = e._x
                  , a = e._y
                  , o = e._z
                  , s = e._w
                  , c = r + r
                  , l = a + a
                  , u = o + o
                  , h = r * c
                  , d = r * l
                  , p = r * u
                  , f = a * l
                  , m = a * u
                  , g = o * u
                  , v = s * c
                  , _ = s * l
                  , y = s * u
                  , x = n.x
                  , M = n.y
                  , b = n.z;
                return i[0] = (1 - (f + g)) * x,
                i[1] = (d + y) * x,
                i[2] = (p - _) * x,
                i[3] = 0,
                i[4] = (d - y) * M,
                i[5] = (1 - (h + g)) * M,
                i[6] = (m + v) * M,
                i[7] = 0,
                i[8] = (p + _) * b,
                i[9] = (m - v) * b,
                i[10] = (1 - (h + f)) * b,
                i[11] = 0,
                i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z,
                i[15] = 1,
                this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Oi.set(i[0], i[1], i[2]).length();
                const a = Oi.set(i[4], i[5], i[6]).length()
                  , o = Oi.set(i[8], i[9], i[10]).length()
                  , s = this.determinant();
                s < 0 && (r = -r),
                t.x = i[12],
                t.y = i[13],
                t.z = i[14],
                Fi.copy(this);
                const c = 1 / r
                  , l = 1 / a
                  , u = 1 / o;
                return Fi.elements[0] *= c,
                Fi.elements[1] *= c,
                Fi.elements[2] *= c,
                Fi.elements[4] *= l,
                Fi.elements[5] *= l,
                Fi.elements[6] *= l,
                Fi.elements[8] *= u,
                Fi.elements[9] *= u,
                Fi.elements[10] *= u,
                e.setFromRotationMatrix(Fi),
                n.x = r,
                n.y = a,
                n.z = o,
                this
            }
            makePerspective(t, e, n, i, r, a, o=tn) {
                const s = this.elements
                  , c = 2 * r / (e - t)
                  , l = 2 * r / (n - i)
                  , u = (e + t) / (e - t)
                  , h = (n + i) / (n - i);
                let d, p;
                if (o === tn)
                    d = -(a + r) / (a - r),
                    p = -2 * a * r / (a - r);
                else {
                    if (o !== en)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
                    d = -a / (a - r),
                    p = -a * r / (a - r)
                }
                return s[0] = c,
                s[4] = 0,
                s[8] = u,
                s[12] = 0,
                s[1] = 0,
                s[5] = l,
                s[9] = h,
                s[13] = 0,
                s[2] = 0,
                s[6] = 0,
                s[10] = d,
                s[14] = p,
                s[3] = 0,
                s[7] = 0,
                s[11] = -1,
                s[15] = 0,
                this
            }
            makeOrthographic(t, e, n, i, r, a, o=tn) {
                const s = this.elements
                  , c = 1 / (e - t)
                  , l = 1 / (n - i)
                  , u = 1 / (a - r)
                  , h = (e + t) * c
                  , d = (n + i) * l;
                let p, f;
                if (o === tn)
                    p = (a + r) * u,
                    f = -2 * u;
                else {
                    if (o !== en)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
                    p = r * u,
                    f = -1 * u
                }
                return s[0] = 2 * c,
                s[4] = 0,
                s[8] = 0,
                s[12] = -h,
                s[1] = 0,
                s[5] = 2 * l,
                s[9] = 0,
                s[13] = -d,
                s[2] = 0,
                s[6] = 0,
                s[10] = f,
                s[14] = -p,
                s[3] = 0,
                s[7] = 0,
                s[11] = 0,
                s[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let i = 0; i < 16; i++)
                    if (e[i] !== n[i])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        }
        const Oi = new ai
          , Fi = new Ni
          , Bi = new ai(0,0,0)
          , ki = new ai(1,1,1)
          , zi = new ai
          , Vi = new ai
          , Hi = new ai
          , Gi = new Ni
          , ji = new ri;
        class Wi {
            constructor(t=0, e=0, n=0, i=Wi.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = t,
                this._y = e,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, n, i=this._order) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t, e=this._order, n=!0) {
                const i = t.elements
                  , r = i[0]
                  , a = i[4]
                  , o = i[8]
                  , s = i[1]
                  , c = i[5]
                  , l = i[9]
                  , u = i[2]
                  , h = i[6]
                  , d = i[10];
                switch (e) {
                case "XYZ":
                    this._y = Math.asin(ln(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-l, d),
                    this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(h, c),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-ln(l, -1, 1)),
                    Math.abs(l) < .9999999 ? (this._y = Math.atan2(o, d),
                    this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-u, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(ln(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d),
                    this._z = Math.atan2(-a, c)) : (this._y = 0,
                    this._z = Math.atan2(s, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-ln(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d),
                    this._z = Math.atan2(s, r)) : (this._x = 0,
                    this._z = Math.atan2(-a, c));
                    break;
                case "YZX":
                    this._z = Math.asin(ln(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, c),
                    this._y = Math.atan2(-u, r)) : (this._x = 0,
                    this._y = Math.atan2(o, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-ln(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(h, c),
                    this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-l, d),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, n) {
                return Gi.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(Gi, e, n)
            }
            setFromVector3(t, e=this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return ji.setFromEuler(this),
                this.setFromQuaternion(ji, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        Wi.DEFAULT_ORDER = "XYZ";
        class Xi {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t >>> 0
            }
            enable(t) {
                this.mask |= 1 << t
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t
            }
            disable(t) {
                this.mask &= ~(1 << t)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 !== (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 !== (this.mask & 1 << t)
            }
        }
        let qi = 0;
        const $i = new ai
          , Yi = new ri
          , Ki = new Ni
          , Zi = new ai
          , Ji = new ai
          , Qi = new ai
          , tr = new ri
          , er = new ai(1,0,0)
          , nr = new ai(0,1,0)
          , ir = new ai(0,0,1)
          , rr = {
            type: "added"
        }
          , ar = {
            type: "removed"
        }
          , or = {
            type: "childadded",
            child: null
        }
          , sr = {
            type: "childremoved",
            child: null
        };
        class cr extends nn {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: qi++
                }),
                this.uuid = cn(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = cr.DEFAULT_UP.clone();
                const t = new ai
                  , e = new Wi
                  , n = new ri
                  , i = new ai(1,1,1);
                function r() {
                    n.setFromEuler(e, !1)
                }
                function a() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                e._onChange(r),
                n._onChange(a),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ni
                    },
                    normalMatrix: {
                        value: new In
                    }
                }),
                this.matrix = new Ni,
                this.matrixWorld = new Ni,
                this.matrixAutoUpdate = cr.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldAutoUpdate = cr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Xi,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t),
                this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return Yi.setFromAxisAngle(t, e),
                this.quaternion.multiply(Yi),
                this
            }
            rotateOnWorldAxis(t, e) {
                return Yi.setFromAxisAngle(t, e),
                this.quaternion.premultiply(Yi),
                this
            }
            rotateX(t) {
                return this.rotateOnAxis(er, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(nr, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(ir, t)
            }
            translateOnAxis(t, e) {
                return $i.copy(t).applyQuaternion(this.quaternion),
                this.position.add($i.multiplyScalar(e)),
                this
            }
            translateX(t) {
                return this.translateOnAxis(er, t)
            }
            translateY(t) {
                return this.translateOnAxis(nr, t)
            }
            translateZ(t) {
                return this.translateOnAxis(ir, t)
            }
            localToWorld(t) {
                return this.updateWorldMatrix(!0, !1),
                t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return this.updateWorldMatrix(!0, !1),
                t.applyMatrix4(Ki.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? Zi.copy(t) : Zi.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                Ji.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Ki.lookAt(Ji, Zi, this.up) : Ki.lookAt(Zi, Ji, this.up),
                this.quaternion.setFromRotationMatrix(Ki),
                i && (Ki.extractRotation(i.matrixWorld),
                Yi.setFromRotationMatrix(Ki),
                this.quaternion.premultiply(Yi.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (t.removeFromParent(),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent(rr),
                or.child = t,
                this.dispatchEvent(or),
                or.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(ar),
                sr.child = t,
                this.dispatchEvent(sr),
                sr.child = null),
                this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1),
                Ki.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                Ki.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(Ki),
                t.removeFromParent(),
                t.parent = this,
                this.children.push(t),
                t.updateWorldMatrix(!1, !0),
                t.dispatchEvent(rr),
                or.child = t,
                this.dispatchEvent(or),
                or.child = null,
                this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n]
                      , r = i.getObjectByProperty(t, e);
                    if (void 0 !== r)
                        return r
                }
            }
            getObjectsByProperty(t, e, n=[]) {
                this[t] === e && n.push(this);
                const i = this.children;
                for (let r = 0, a = i.length; r < a; r++)
                    i[r].getObjectsByProperty(t, e, n);
                return n
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Ji, t, Qi),
                t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Ji, tr, t),
                t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" === typeof t
                  , n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                i.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isBatchedMesh && (i.type = "BatchedMesh",
                i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                i.sortObjects = this.sortObjects,
                i.drawRanges = this._drawRanges,
                i.reservedRanges = this._reservedRanges,
                i.visibility = this._visibility,
                i.active = this._active,
                i.bounds = this._bounds.map((t=>({
                    boxInitialized: t.boxInitialized,
                    boxMin: t.box.min.toArray(),
                    boxMax: t.box.max.toArray(),
                    sphereInitialized: t.sphereInitialized,
                    sphereRadius: t.sphere.radius,
                    sphereCenter: t.sphere.center.toArray()
                }))),
                i.maxGeometryCount = this._maxGeometryCount,
                i.maxVertexCount = this._maxVertexCount,
                i.maxIndexCount = this._maxIndexCount,
                i.geometryInitialized = this._geometryInitialized,
                i.geometryCount = this._geometryCount,
                i.matricesTexture = this._matricesTexture.toJSON(t),
                null !== this.boundingSphere && (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius
                }),
                null !== this.boundingBox && (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray()
                })),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            }
                        else
                            r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else
                        i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = a(t.geometries)
                      , i = a(t.materials)
                      , r = a(t.textures)
                      , o = a(t.images)
                      , s = a(t.shapes)
                      , c = a(t.skeletons)
                      , l = a(t.animations)
                      , u = a(t.nodes);
                    e.length > 0 && (n.geometries = e),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    o.length > 0 && (n.images = o),
                    s.length > 0 && (n.shapes = s),
                    c.length > 0 && (n.skeletons = c),
                    l.length > 0 && (n.animations = l),
                    u.length > 0 && (n.nodes = u)
                }
                return n.object = i,
                n;
                function a(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e=!0) {
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.animations = t.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let n = 0; n < t.children.length; n++) {
                        const e = t.children[n];
                        this.add(e.clone())
                    }
                return this
            }
        }
        cr.DEFAULT_UP = new ai(0,1,0),
        cr.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        cr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const lr = new ai
          , ur = new ai
          , hr = new ai
          , dr = new ai
          , pr = new ai
          , fr = new ai
          , mr = new ai
          , gr = new ai
          , vr = new ai
          , _r = new ai;
        class yr {
            constructor(t=new ai, e=new ai, n=new ai) {
                this.a = t,
                this.b = e,
                this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e),
                lr.subVectors(t, e),
                i.cross(lr);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                lr.subVectors(i, e),
                ur.subVectors(n, e),
                hr.subVectors(t, e);
                const a = lr.dot(lr)
                  , o = lr.dot(ur)
                  , s = lr.dot(hr)
                  , c = ur.dot(ur)
                  , l = ur.dot(hr)
                  , u = a * c - o * o;
                if (0 === u)
                    return r.set(0, 0, 0),
                    null;
                const h = 1 / u
                  , d = (c * s - o * l) * h
                  , p = (a * l - o * s) * h;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return null !== this.getBarycoord(t, e, n, i, dr) && (dr.x >= 0 && dr.y >= 0 && dr.x + dr.y <= 1)
            }
            static getInterpolation(t, e, n, i, r, a, o, s) {
                return null === this.getBarycoord(t, e, n, i, dr) ? (s.x = 0,
                s.y = 0,
                "z"in s && (s.z = 0),
                "w"in s && (s.w = 0),
                null) : (s.setScalar(0),
                s.addScaledVector(r, dr.x),
                s.addScaledVector(a, dr.y),
                s.addScaledVector(o, dr.z),
                s)
            }
            static isFrontFacing(t, e, n, i) {
                return lr.subVectors(n, e),
                ur.subVectors(t, e),
                lr.cross(ur).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[i]),
                this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e),
                this.b.fromBufferAttribute(t, n),
                this.c.fromBufferAttribute(t, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return lr.subVectors(this.c, this.b),
                ur.subVectors(this.a, this.b),
                .5 * lr.cross(ur).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return yr.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return yr.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getInterpolation(t, e, n, i, r) {
                return yr.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return yr.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return yr.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let a, o;
                pr.subVectors(i, n),
                fr.subVectors(r, n),
                gr.subVectors(t, n);
                const s = pr.dot(gr)
                  , c = fr.dot(gr);
                if (s <= 0 && c <= 0)
                    return e.copy(n);
                vr.subVectors(t, i);
                const l = pr.dot(vr)
                  , u = fr.dot(vr);
                if (l >= 0 && u <= l)
                    return e.copy(i);
                const h = s * u - l * c;
                if (h <= 0 && s >= 0 && l <= 0)
                    return a = s / (s - l),
                    e.copy(n).addScaledVector(pr, a);
                _r.subVectors(t, r);
                const d = pr.dot(_r)
                  , p = fr.dot(_r);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * c - s * p;
                if (f <= 0 && c >= 0 && p <= 0)
                    return o = c / (c - p),
                    e.copy(n).addScaledVector(fr, o);
                const m = l * p - d * u;
                if (m <= 0 && u - l >= 0 && d - p >= 0)
                    return mr.subVectors(r, i),
                    o = (u - l) / (u - l + (d - p)),
                    e.copy(i).addScaledVector(mr, o);
                const g = 1 / (m + f + h);
                return a = f * g,
                o = h * g,
                e.copy(n).addScaledVector(pr, a).addScaledVector(fr, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        const xr = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Mr = {
            h: 0,
            s: 0,
            l: 0
        }
          , br = {
            h: 0,
            s: 0,
            l: 0
        };
        function Sr(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        class Er {
            constructor(t, e, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(t, e, n)
            }
            set(t, e, n) {
                if (void 0 === e && void 0 === n) {
                    const e = t;
                    e && e.isColor ? this.copy(e) : "number" === typeof e ? this.setHex(e) : "string" === typeof e && this.setStyle(e)
                } else
                    this.setRGB(t, e, n);
                return this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t, e=De) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                Gn.toWorkingColorSpace(this, e),
                this
            }
            setRGB(t, e, n, i=Gn.workingColorSpace) {
                return this.r = t,
                this.g = e,
                this.b = n,
                Gn.toWorkingColorSpace(this, i),
                this
            }
            setHSL(t, e, n, i=Gn.workingColorSpace) {
                if (t = un(t, 1),
                e = ln(e, 0, 1),
                n = ln(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e
                      , r = 2 * n - i;
                    this.r = Sr(r, i, t + 1 / 3),
                    this.g = Sr(r, i, t),
                    this.b = Sr(r, i, t - 1 / 3)
                }
                return Gn.toWorkingColorSpace(this, i),
                this
            }
            setStyle(t, e=De) {
                function n(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                    let r;
                    const a = i[1]
                      , o = i[2];
                    switch (a) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return n(r[4]),
                            this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return n(r[4]),
                            this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return n(r[4]),
                            this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + t)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const n = i[1]
                      , r = n.length;
                    if (3 === r)
                        return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
                    if (6 === r)
                        return this.setHex(parseInt(n, 16), e);
                    console.warn("THREE.Color: Invalid hex color " + t)
                } else if (t && t.length > 0)
                    return this.setColorName(t, e);
                return this
            }
            setColorName(t, e=De) {
                const n = xr[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copySRGBToLinear(t) {
                return this.r = jn(t.r),
                this.g = jn(t.g),
                this.b = jn(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = Wn(t.r),
                this.g = Wn(t.g),
                this.b = Wn(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(t=De) {
                return Gn.fromWorkingColorSpace(Tr.copy(this), t),
                65536 * Math.round(ln(255 * Tr.r, 0, 255)) + 256 * Math.round(ln(255 * Tr.g, 0, 255)) + Math.round(ln(255 * Tr.b, 0, 255))
            }
            getHexString(t=De) {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e=Gn.workingColorSpace) {
                Gn.fromWorkingColorSpace(Tr.copy(this), e);
                const n = Tr.r
                  , i = Tr.g
                  , r = Tr.b
                  , a = Math.max(n, i, r)
                  , o = Math.min(n, i, r);
                let s, c;
                const l = (o + a) / 2;
                if (o === a)
                    s = 0,
                    c = 0;
                else {
                    const t = a - o;
                    switch (c = l <= .5 ? t / (a + o) : t / (2 - a - o),
                    a) {
                    case n:
                        s = (i - r) / t + (i < r ? 6 : 0);
                        break;
                    case i:
                        s = (r - n) / t + 2;
                        break;
                    case r:
                        s = (n - i) / t + 4;
                        break
                    }
                    s /= 6
                }
                return t.h = s,
                t.s = c,
                t.l = l,
                t
            }
            getRGB(t, e=Gn.workingColorSpace) {
                return Gn.fromWorkingColorSpace(Tr.copy(this), e),
                t.r = Tr.r,
                t.g = Tr.g,
                t.b = Tr.b,
                t
            }
            getStyle(t=De) {
                Gn.fromWorkingColorSpace(Tr.copy(this), t);
                const e = Tr.r
                  , n = Tr.g
                  , i = Tr.b;
                return t !== De ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(Mr),
                this.setHSL(Mr.h + t, Mr.s + e, Mr.l + n)
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                this.g = t.g + (e.g - t.g) * n,
                this.b = t.b + (e.b - t.b) * n,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(Mr),
                t.getHSL(br);
                const n = pn(Mr.h, br.h, e)
                  , i = pn(Mr.s, br.s, e)
                  , r = pn(Mr.l, br.l, e);
                return this.setHSL(n, i, r),
                this
            }
            setFromVector3(t) {
                return this.r = t.x,
                this.g = t.y,
                this.b = t.z,
                this
            }
            applyMatrix3(t) {
                const e = this.r
                  , n = this.g
                  , i = this.b
                  , r = t.elements;
                return this.r = r[0] * e + r[3] * n + r[6] * i,
                this.g = r[1] * e + r[4] * n + r[7] * i,
                this.b = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const Tr = new Er;
        Er.NAMES = xr;
        let wr = 0;
        class Ar extends nn {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: wr++
                }),
                this.uuid = cn(),
                this.name = "",
                this.type = "Material",
                this.blending = g,
                this.side = d,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = P,
                this.blendDst = L,
                this.blendEquation = M,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.blendColor = new Er(0,0,0),
                this.blendAlpha = 0,
                this.depthFunc = j,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = Ge,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = He,
                this.stencilZFail = He,
                this.stencilZPass = He,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 !== t > 0 && this.version++,
                this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" === typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.dispersion && (n.dispersion = this.dispersion),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== g && (n.blending = this.blending),
                this.side !== d && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                this.blendSrc !== P && (n.blendSrc = this.blendSrc),
                this.blendDst !== L && (n.blendDst = this.blendDst),
                this.blendEquation !== M && (n.blendEquation = this.blendEquation),
                null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                this.depthFunc !== j && (n.depthFunc = this.depthFunc),
                !1 === this.depthTest && (n.depthTest = this.depthTest),
                !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                this.stencilFunc !== Ge && (n.stencilFunc = this.stencilFunc),
                0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                this.stencilFail !== He && (n.stencilFail = this.stencilFail),
                this.stencilZFail !== He && (n.stencilZFail = this.stencilZFail),
                this.stencilZPass !== He && (n.stencilZPass = this.stencilZPass),
                !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                e) {
                    const e = i(t.textures)
                      , r = i(t.images);
                    e.length > 0 && (n.textures = e),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.blendColor.copy(t.blendColor),
                this.blendAlpha = t.blendAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.alphaHash = t.alphaHash,
                this.alphaToCoverage = t.alphaToCoverage,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.forceSinglePass = t.forceSinglePass,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        class Rr extends Ar {
            constructor(t) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new Er(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new Wi,
                this.combine = Y,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapRotation.copy(t.envMapRotation),
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.fog = t.fog,
                this
            }
        }
        const Cr = new ai
          , Pr = new Ln;
        class Lr {
            constructor(t, e, n=!1) {
                if (Array.isArray(t))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = n,
                this.usage = Je,
                this._updateRange = {
                    offset: 0,
                    count: -1
                },
                this.updateRanges = [],
                this.gpuType = At,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            get updateRange() {
                return Bn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
                this._updateRange
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            addUpdateRange(t, e) {
                this.updateRanges.push({
                    start: t,
                    count: e
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this.gpuType = t.gpuType,
                this
            }
            copyAt(t, e, n) {
                t *= this.itemSize,
                n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t),
                this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        Pr.fromBufferAttribute(this, e),
                        Pr.applyMatrix3(t),
                        this.setXY(e, Pr.x, Pr.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        Cr.fromBufferAttribute(this, e),
                        Cr.applyMatrix3(t),
                        this.setXYZ(e, Cr.x, Cr.y, Cr.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Cr.fromBufferAttribute(this, e),
                    Cr.applyMatrix4(t),
                    this.setXYZ(e, Cr.x, Cr.y, Cr.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Cr.fromBufferAttribute(this, e),
                    Cr.applyNormalMatrix(t),
                    this.setXYZ(e, Cr.x, Cr.y, Cr.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Cr.fromBufferAttribute(this, e),
                    Cr.transformDirection(t),
                    this.setXYZ(e, Cr.x, Cr.y, Cr.z);
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            getComponent(t, e) {
                let n = this.array[t * this.itemSize + e];
                return this.normalized && (n = Rn(n, this.array)),
                n
            }
            setComponent(t, e, n) {
                return this.normalized && (n = Cn(n, this.array)),
                this.array[t * this.itemSize + e] = n,
                this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = Rn(e, this.array)),
                e
            }
            setX(t, e) {
                return this.normalized && (e = Cn(e, this.array)),
                this.array[t * this.itemSize] = e,
                this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = Rn(e, this.array)),
                e
            }
            setY(t, e) {
                return this.normalized && (e = Cn(e, this.array)),
                this.array[t * this.itemSize + 1] = e,
                this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = Rn(e, this.array)),
                e
            }
            setZ(t, e) {
                return this.normalized && (e = Cn(e, this.array)),
                this.array[t * this.itemSize + 2] = e,
                this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = Rn(e, this.array)),
                e
            }
            setW(t, e) {
                return this.normalized && (e = Cn(e, this.array)),
                this.array[t * this.itemSize + 3] = e,
                this
            }
            setXY(t, e, n) {
                return t *= this.itemSize,
                this.normalized && (e = Cn(e, this.array),
                n = Cn(n, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize,
                this.normalized && (e = Cn(e, this.array),
                n = Cn(n, this.array),
                i = Cn(i, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize,
                this.normalized && (e = Cn(e, this.array),
                n = Cn(n, this.array),
                i = Cn(i, this.array),
                r = Cn(r, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this.array[t + 3] = r,
                this
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name),
                this.usage !== Je && (t.usage = this.usage),
                t
            }
        }
        class Ir extends Lr {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Ur extends Lr {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Dr extends Lr {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let Nr = 0;
        const Or = new Ni
          , Fr = new cr
          , Br = new ai
          , kr = new ci
          , zr = new ci
          , Vr = new ai;
        class Hr extends nn {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: Nr++
                }),
                this.uuid = cn(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new (Dn(t) ? Ur : Ir)(t,1) : this.index = t,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e,
                this
            }
            deleteAttribute(t) {
                return delete this.attributes[t],
                this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new In).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(t) {
                return Or.makeRotationFromQuaternion(t),
                this.applyMatrix4(Or),
                this
            }
            rotateX(t) {
                return Or.makeRotationX(t),
                this.applyMatrix4(Or),
                this
            }
            rotateY(t) {
                return Or.makeRotationY(t),
                this.applyMatrix4(Or),
                this
            }
            rotateZ(t) {
                return Or.makeRotationZ(t),
                this.applyMatrix4(Or),
                this
            }
            translate(t, e, n) {
                return Or.makeTranslation(t, e, n),
                this.applyMatrix4(Or),
                this
            }
            scale(t, e, n) {
                return Or.makeScale(t, e, n),
                this.applyMatrix4(Or),
                this
            }
            lookAt(t) {
                return Fr.lookAt(t),
                Fr.updateMatrix(),
                this.applyMatrix4(Fr.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Br).negate(),
                this.translate(Br.x, Br.y, Br.z),
                this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Dr(e,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new ci);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                    void this.boundingBox.set(new ai(-1 / 0,-1 / 0,-1 / 0), new ai(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let n = 0, i = e.length; n < i; n++) {
                            const t = e[n];
                            kr.setFromBufferAttribute(t),
                            this.morphTargetsRelative ? (Vr.addVectors(this.boundingBox.min, kr.min),
                            this.boundingBox.expandByPoint(Vr),
                            Vr.addVectors(this.boundingBox.max, kr.max),
                            this.boundingBox.expandByPoint(Vr)) : (this.boundingBox.expandByPoint(kr.min),
                            this.boundingBox.expandByPoint(kr.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new wi);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                    void this.boundingSphere.set(new ai, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (kr.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, r = e.length; t < r; t++) {
                            const n = e[t];
                            zr.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Vr.addVectors(kr.min, zr.min),
                            kr.expandByPoint(Vr),
                            Vr.addVectors(kr.max, zr.max),
                            kr.expandByPoint(Vr)) : (kr.expandByPoint(zr.min),
                            kr.expandByPoint(zr.max))
                        }
                    kr.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        Vr.fromBufferAttribute(t, e),
                        i = Math.max(i, n.distanceToSquared(Vr));
                    if (e)
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r]
                              , o = this.morphTargetsRelative;
                            for (let e = 0, r = a.count; e < r; e++)
                                Vr.fromBufferAttribute(a, e),
                                o && (Br.fromBufferAttribute(t, e),
                                Vr.add(Br)),
                                i = Math.max(i, n.distanceToSquared(Vr))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.position
                  , i = e.normal
                  , r = e.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Lr(new Float32Array(4 * n.count),4));
                const a = this.getAttribute("tangent")
                  , o = []
                  , s = [];
                for (let S = 0; S < n.count; S++)
                    o[S] = new ai,
                    s[S] = new ai;
                const c = new ai
                  , l = new ai
                  , u = new ai
                  , h = new Ln
                  , d = new Ln
                  , p = new Ln
                  , f = new ai
                  , m = new ai;
                function g(t, e, i) {
                    c.fromBufferAttribute(n, t),
                    l.fromBufferAttribute(n, e),
                    u.fromBufferAttribute(n, i),
                    h.fromBufferAttribute(r, t),
                    d.fromBufferAttribute(r, e),
                    p.fromBufferAttribute(r, i),
                    l.sub(c),
                    u.sub(c),
                    d.sub(h),
                    p.sub(h);
                    const a = 1 / (d.x * p.y - p.x * d.y);
                    isFinite(a) && (f.copy(l).multiplyScalar(p.y).addScaledVector(u, -d.y).multiplyScalar(a),
                    m.copy(u).multiplyScalar(d.x).addScaledVector(l, -p.x).multiplyScalar(a),
                    o[t].add(f),
                    o[e].add(f),
                    o[i].add(f),
                    s[t].add(m),
                    s[e].add(m),
                    s[i].add(m))
                }
                let v = this.groups;
                0 === v.length && (v = [{
                    start: 0,
                    count: t.count
                }]);
                for (let S = 0, E = v.length; S < E; ++S) {
                    const e = v[S]
                      , n = e.start
                      , i = e.count;
                    for (let r = n, a = n + i; r < a; r += 3)
                        g(t.getX(r + 0), t.getX(r + 1), t.getX(r + 2))
                }
                const _ = new ai
                  , y = new ai
                  , x = new ai
                  , M = new ai;
                function b(t) {
                    x.fromBufferAttribute(i, t),
                    M.copy(x);
                    const e = o[t];
                    _.copy(e),
                    _.sub(x.multiplyScalar(x.dot(e))).normalize(),
                    y.crossVectors(M, e);
                    const n = y.dot(s[t])
                      , r = n < 0 ? -1 : 1;
                    a.setXYZW(t, _.x, _.y, _.z, r)
                }
                for (let S = 0, E = v.length; S < E; ++S) {
                    const e = v[S]
                      , n = e.start
                      , i = e.count;
                    for (let r = n, a = n + i; r < a; r += 3)
                        b(t.getX(r + 0)),
                        b(t.getX(r + 1)),
                        b(t.getX(r + 2))
                }
            }
            computeVertexNormals() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Lr(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new ai
                      , r = new ai
                      , a = new ai
                      , o = new ai
                      , s = new ai
                      , c = new ai
                      , l = new ai
                      , u = new ai;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0)
                              , p = t.getX(h + 1)
                              , f = t.getX(h + 2);
                            i.fromBufferAttribute(e, d),
                            r.fromBufferAttribute(e, p),
                            a.fromBufferAttribute(e, f),
                            l.subVectors(a, r),
                            u.subVectors(i, r),
                            l.cross(u),
                            o.fromBufferAttribute(n, d),
                            s.fromBufferAttribute(n, p),
                            c.fromBufferAttribute(n, f),
                            o.add(l),
                            s.add(l),
                            c.add(l),
                            n.setXYZ(d, o.x, o.y, o.z),
                            n.setXYZ(p, s.x, s.y, s.z),
                            n.setXYZ(f, c.x, c.y, c.z)
                        }
                    else
                        for (let t = 0, h = e.count; t < h; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                            r.fromBufferAttribute(e, t + 1),
                            a.fromBufferAttribute(e, t + 2),
                            l.subVectors(a, r),
                            u.subVectors(i, r),
                            l.cross(u),
                            n.setXYZ(t + 0, l.x, l.y, l.z),
                            n.setXYZ(t + 1, l.x, l.y, l.z),
                            n.setXYZ(t + 2, l.x, l.y, l.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    Vr.fromBufferAttribute(t, e),
                    Vr.normalize(),
                    t.setXYZ(e, Vr.x, Vr.y, Vr.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array
                      , i = t.itemSize
                      , r = t.normalized
                      , a = new n.constructor(e.length * i);
                    let o = 0
                      , s = 0;
                    for (let c = 0, l = e.length; c < l; c++) {
                        o = t.isInterleavedBufferAttribute ? e[c] * t.data.stride + t.offset : e[c] * i;
                        for (let t = 0; t < i; t++)
                            a[s++] = n[o++]
                    }
                    return new Lr(a,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new Hr
                  , n = this.index.array
                  , i = this.attributes;
                for (const o in i) {
                    const r = i[o]
                      , a = t(r, n);
                    e.setAttribute(o, a)
                }
                const r = this.morphAttributes;
                for (const o in r) {
                    const i = []
                      , a = r[o];
                    for (let e = 0, r = a.length; e < r; e++) {
                        const r = a[e]
                          , o = t(r, n);
                        i.push(o)
                    }
                    e.morphAttributes[o] = i
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const a = this.groups;
                for (let o = 0, s = a.length; o < s; o++) {
                    const t = a[o];
                    e.addGroup(t.start, t.count, t.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const s in n) {
                    const e = n[s];
                    t.data.attributes[s] = e.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const s in this.morphAttributes) {
                    const e = this.morphAttributes[s]
                      , n = [];
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i];
                        n.push(r.toJSON(t.data))
                    }
                    n.length > 0 && (i[s] = n,
                    r = !0)
                }
                r && (t.data.morphAttributes = i,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const a = this.groups;
                a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }),
                t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const c in i) {
                    const t = i[c];
                    this.setAttribute(c, t.clone(e))
                }
                const r = t.morphAttributes;
                for (const c in r) {
                    const t = []
                      , n = r[c];
                    for (let i = 0, r = n.length; i < r; i++)
                        t.push(n[i].clone(e));
                    this.morphAttributes[c] = t
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const a = t.groups;
                for (let c = 0, l = a.length; c < l; c++) {
                    const t = a[c];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const s = t.boundingSphere;
                return null !== s && (this.boundingSphere = s.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Gr = new Ni
          , jr = new Di
          , Wr = new wi
          , Xr = new ai
          , qr = new ai
          , $r = new ai
          , Yr = new ai
          , Kr = new ai
          , Zr = new ai
          , Jr = new Ln
          , Qr = new Ln
          , ta = new Ln
          , ea = new ai
          , na = new ai
          , ia = new ai
          , ra = new ai
          , aa = new ai;
        class oa extends cr {
            constructor(t=new Hr, e=new Rr) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            updateMorphTargets() {
                const t = this.geometry
                  , e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            }
            getVertexPosition(t, e) {
                const n = this.geometry
                  , i = n.attributes.position
                  , r = n.morphAttributes.position
                  , a = n.morphTargetsRelative;
                e.fromBufferAttribute(i, t);
                const o = this.morphTargetInfluences;
                if (r && o) {
                    Zr.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = o[n]
                          , s = r[n];
                        0 !== i && (Kr.fromBufferAttribute(s, t),
                        a ? Zr.addScaledVector(Kr, i) : Zr.addScaledVector(Kr.sub(e), i))
                    }
                    e.add(Zr)
                }
                return e
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Wr.copy(n.boundingSphere),
                    Wr.applyMatrix4(r),
                    jr.copy(t.ray).recast(t.near),
                    !1 === Wr.containsPoint(jr.origin)) {
                        if (null === jr.intersectSphere(Wr, Xr))
                            return;
                        if (jr.origin.distanceToSquared(Xr) > (t.far - t.near) ** 2)
                            return
                    }
                    Gr.copy(r).invert(),
                    jr.copy(t.ray).applyMatrix4(Gr),
                    null !== n.boundingBox && !1 === jr.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, jr)
                }
            }
            _computeIntersections(t, e, n) {
                let i;
                const r = this.geometry
                  , a = this.material
                  , o = r.index
                  , s = r.attributes.position
                  , c = r.attributes.uv
                  , l = r.attributes.uv1
                  , u = r.attributes.normal
                  , h = r.groups
                  , d = r.drawRange;
                if (null !== o)
                    if (Array.isArray(a))
                        for (let p = 0, f = h.length; p < f; p++) {
                            const r = h[p]
                              , s = a[r.materialIndex]
                              , f = Math.max(r.start, d.start)
                              , m = Math.min(o.count, Math.min(r.start + r.count, d.start + d.count));
                            for (let a = f, h = m; a < h; a += 3) {
                                const h = o.getX(a)
                                  , d = o.getX(a + 1)
                                  , p = o.getX(a + 2);
                                i = ca(this, s, t, n, c, l, u, h, d, p),
                                i && (i.faceIndex = Math.floor(a / 3),
                                i.face.materialIndex = r.materialIndex,
                                e.push(i))
                            }
                        }
                    else {
                        const r = Math.max(0, d.start)
                          , s = Math.min(o.count, d.start + d.count);
                        for (let h = r, d = s; h < d; h += 3) {
                            const r = o.getX(h)
                              , s = o.getX(h + 1)
                              , d = o.getX(h + 2);
                            i = ca(this, a, t, n, c, l, u, r, s, d),
                            i && (i.faceIndex = Math.floor(h / 3),
                            e.push(i))
                        }
                    }
                else if (void 0 !== s)
                    if (Array.isArray(a))
                        for (let p = 0, f = h.length; p < f; p++) {
                            const r = h[p]
                              , o = a[r.materialIndex]
                              , f = Math.max(r.start, d.start)
                              , m = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count));
                            for (let a = f, s = m; a < s; a += 3) {
                                const s = a
                                  , h = a + 1
                                  , d = a + 2;
                                i = ca(this, o, t, n, c, l, u, s, h, d),
                                i && (i.faceIndex = Math.floor(a / 3),
                                i.face.materialIndex = r.materialIndex,
                                e.push(i))
                            }
                        }
                    else {
                        const r = Math.max(0, d.start)
                          , o = Math.min(s.count, d.start + d.count);
                        for (let s = r, h = o; s < h; s += 3) {
                            const r = s
                              , o = s + 1
                              , h = s + 2;
                            i = ca(this, a, t, n, c, l, u, r, o, h),
                            i && (i.faceIndex = Math.floor(s / 3),
                            e.push(i))
                        }
                    }
            }
        }
        function sa(t, e, n, i, r, a, o, s) {
            let c;
            if (c = e.side === p ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, e.side === d, s),
            null === c)
                return null;
            aa.copy(s),
            aa.applyMatrix4(t.matrixWorld);
            const l = n.ray.origin.distanceTo(aa);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: aa.clone(),
                object: t
            }
        }
        function ca(t, e, n, i, r, a, o, s, c, l) {
            t.getVertexPosition(s, qr),
            t.getVertexPosition(c, $r),
            t.getVertexPosition(l, Yr);
            const u = sa(t, e, n, i, qr, $r, Yr, ra);
            if (u) {
                r && (Jr.fromBufferAttribute(r, s),
                Qr.fromBufferAttribute(r, c),
                ta.fromBufferAttribute(r, l),
                u.uv = yr.getInterpolation(ra, qr, $r, Yr, Jr, Qr, ta, new Ln)),
                a && (Jr.fromBufferAttribute(a, s),
                Qr.fromBufferAttribute(a, c),
                ta.fromBufferAttribute(a, l),
                u.uv1 = yr.getInterpolation(ra, qr, $r, Yr, Jr, Qr, ta, new Ln)),
                o && (ea.fromBufferAttribute(o, s),
                na.fromBufferAttribute(o, c),
                ia.fromBufferAttribute(o, l),
                u.normal = yr.getInterpolation(ra, qr, $r, Yr, ea, na, ia, new ai),
                u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
                const t = {
                    a: s,
                    b: c,
                    c: l,
                    normal: new ai,
                    materialIndex: 0
                };
                yr.getNormal(qr, $r, Yr, t.normal),
                u.face = t
            }
            return u
        }
        class la extends Hr {
            constructor(t=1, e=1, n=1, i=1, r=1, a=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                const o = this;
                i = Math.floor(i),
                r = Math.floor(r),
                a = Math.floor(a);
                const s = []
                  , c = []
                  , l = []
                  , u = [];
                let h = 0
                  , d = 0;
                function p(t, e, n, i, r, a, p, f, m, g, v) {
                    const _ = a / m
                      , y = p / g
                      , x = a / 2
                      , M = p / 2
                      , b = f / 2
                      , S = m + 1
                      , E = g + 1;
                    let T = 0
                      , w = 0;
                    const A = new ai;
                    for (let o = 0; o < E; o++) {
                        const a = o * y - M;
                        for (let s = 0; s < S; s++) {
                            const h = s * _ - x;
                            A[t] = h * i,
                            A[e] = a * r,
                            A[n] = b,
                            c.push(A.x, A.y, A.z),
                            A[t] = 0,
                            A[e] = 0,
                            A[n] = f > 0 ? 1 : -1,
                            l.push(A.x, A.y, A.z),
                            u.push(s / m),
                            u.push(1 - o / g),
                            T += 1
                        }
                    }
                    for (let o = 0; o < g; o++)
                        for (let t = 0; t < m; t++) {
                            const e = h + t + S * o
                              , n = h + t + S * (o + 1)
                              , i = h + (t + 1) + S * (o + 1)
                              , r = h + (t + 1) + S * o;
                            s.push(e, n, r),
                            s.push(n, i, r),
                            w += 6
                        }
                    o.addGroup(d, w, v),
                    d += w,
                    h += T
                }
                p("z", "y", "x", -1, -1, n, e, t, a, r, 0),
                p("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
                p("x", "z", "y", 1, 1, t, n, e, i, a, 2),
                p("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
                p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                this.setIndex(s),
                this.setAttribute("position", new Dr(c,3)),
                this.setAttribute("normal", new Dr(l,3)),
                this.setAttribute("uv", new Dr(u,2))
            }
            copy(t) {
                return super.copy(t),
                this.parameters = Object.assign({}, t.parameters),
                this
            }
            static fromJSON(t) {
                return new la(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
            }
        }
        function ua(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
        function ha(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = ua(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        function da(t) {
            const e = [];
            for (let n = 0; n < t.length; n++)
                e.push(t[n].clone());
            return e
        }
        function pa(t) {
            const e = t.getRenderTarget();
            return null === e ? t.outputColorSpace : !0 === e.isXRRenderTarget ? e.texture.colorSpace : Gn.workingColorSpace
        }
        const fa = {
            clone: ua,
            merge: ha
        };
        var ma = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
          , ga = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        class va extends Ar {
            constructor(t) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = ma,
                this.fragmentShader = ga,
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    clipCullDistance: !1,
                    multiDraw: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.fragmentShader = t.fragmentShader,
                this.vertexShader = t.vertexShader,
                this.uniforms = ua(t.uniforms),
                this.uniformsGroups = da(t.uniformsGroups),
                this.defines = Object.assign({}, t.defines),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.fog = t.fog,
                this.lights = t.lights,
                this.clipping = t.clipping,
                this.extensions = Object.assign({}, t.extensions),
                this.glslVersion = t.glslVersion,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion,
                e.uniforms = {};
                for (const i in this.uniforms) {
                    const n = this.uniforms[i]
                      , r = n.value;
                    r && r.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[i] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[i] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader,
                e.lights = this.lights,
                e.clipping = this.clipping;
                const n = {};
                for (const i in this.extensions)
                    !0 === this.extensions[i] && (n[i] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                e
            }
        }
        class _a extends cr {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Ni,
                this.projectionMatrix = new Ni,
                this.projectionMatrixInverse = new Ni,
                this.coordinateSystem = tn
            }
            copy(t, e) {
                return super.copy(t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this.coordinateSystem = t.coordinateSystem,
                this
            }
            getWorldDirection(t) {
                return super.getWorldDirection(t).negate()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const ya = new ai
          , xa = new Ln
          , Ma = new Ln;
        class ba extends _a {
            constructor(t=50, e=1, n=.1, i=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * sn * Math.atan(e),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * on * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * sn * Math.atan(Math.tan(.5 * on * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(t, e, n) {
                ya.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                e.set(ya.x, ya.y).multiplyScalar(-t / ya.z),
                ya.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                n.set(ya.x, ya.y).multiplyScalar(-t / ya.z)
            }
            getViewSize(t, e) {
                return this.getViewBounds(t, xa, Ma),
                e.subVectors(Ma, xa)
            }
            setViewOffset(t, e, n, i, r, a) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * on * this.fov) / this.zoom
                  , n = 2 * e
                  , i = this.aspect * n
                  , r = -.5 * i;
                const a = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = a.fullWidth
                      , o = a.fullHeight;
                    r += a.offsetX * i / t,
                    e -= a.offsetY * n / o,
                    i *= a.width / t,
                    n *= a.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        }
        const Sa = -90
          , Ea = 1;
        class Ta extends cr {
            constructor(t, e, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const i = new ba(Sa,Ea,t,e);
                i.layers = this.layers,
                this.add(i);
                const r = new ba(Sa,Ea,t,e);
                r.layers = this.layers,
                this.add(r);
                const a = new ba(Sa,Ea,t,e);
                a.layers = this.layers,
                this.add(a);
                const o = new ba(Sa,Ea,t,e);
                o.layers = this.layers,
                this.add(o);
                const s = new ba(Sa,Ea,t,e);
                s.layers = this.layers,
                this.add(s);
                const c = new ba(Sa,Ea,t,e);
                c.layers = this.layers,
                this.add(c)
            }
            updateCoordinateSystem() {
                const t = this.coordinateSystem
                  , e = this.children.concat()
                  , [n,i,r,a,o,s] = e;
                for (const c of e)
                    this.remove(c);
                if (t === tn)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    i.up.set(0, 1, 0),
                    i.lookAt(-1, 0, 0),
                    r.up.set(0, 0, -1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, 1),
                    a.lookAt(0, -1, 0),
                    o.up.set(0, 1, 0),
                    o.lookAt(0, 0, 1),
                    s.up.set(0, 1, 0),
                    s.lookAt(0, 0, -1);
                else {
                    if (t !== en)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    i.up.set(0, -1, 0),
                    i.lookAt(1, 0, 0),
                    r.up.set(0, 0, 1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, -1),
                    a.lookAt(0, -1, 0),
                    o.up.set(0, -1, 0),
                    o.lookAt(0, 0, 1),
                    s.up.set(0, -1, 0),
                    s.lookAt(0, 0, -1)
                }
                for (const c of e)
                    this.add(c),
                    c.updateMatrixWorld()
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: i} = this;
                this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem,
                this.updateCoordinateSystem());
                const [r,a,o,s,c,l] = this.children
                  , u = t.getRenderTarget()
                  , h = t.getActiveCubeFace()
                  , d = t.getActiveMipmapLevel()
                  , p = t.xr.enabled;
                t.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                t.setRenderTarget(n, 0, i),
                t.render(e, r),
                t.setRenderTarget(n, 1, i),
                t.render(e, a),
                t.setRenderTarget(n, 2, i),
                t.render(e, o),
                t.setRenderTarget(n, 3, i),
                t.render(e, s),
                t.setRenderTarget(n, 4, i),
                t.render(e, c),
                n.texture.generateMipmaps = f,
                t.setRenderTarget(n, 5, i),
                t.render(e, l),
                t.setRenderTarget(u, h, d),
                t.xr.enabled = p,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class wa extends Jn {
            constructor(t, e, n, i, r, a, o, s, c, l) {
                t = void 0 !== t ? t : [],
                e = void 0 !== e ? e : st,
                super(t, e, n, i, r, a, o, s, c, l),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class Aa extends ei {
            constructor(t=1, e={}) {
                super(t, t, e),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: t,
                    height: t,
                    depth: 1
                }
                  , i = [n, n, n, n, n, n];
                this.texture = new wa(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : _t
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.colorSpace = e.colorSpace,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new la(5,5,5)
                  , r = new va({
                    name: "CubemapFromEquirect",
                    uniforms: ua(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: p,
                    blending: m
                });
                r.uniforms.tEquirect.value = e;
                const a = new oa(i,r)
                  , o = e.minFilter;
                e.minFilter === xt && (e.minFilter = _t);
                const s = new Ta(1,10,this);
                return s.update(t, a),
                e.minFilter = o,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let a = 0; a < 6; a++)
                    t.setRenderTarget(this, a),
                    t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        const Ra = new ai
          , Ca = new ai
          , Pa = new In;
        class La {
            constructor(t=new ai(1,0,0), e=0) {
                this.isPlane = !0,
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = Ra.subVectors(n, e).cross(Ca.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
            }
            intersectLine(t, e) {
                const n = t.delta(Ra)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Pa.getNormalMatrix(t)
                  , i = this.coplanarPoint(Ra).applyMatrix4(t)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ia = new wi
          , Ua = new ai;
        class Da {
            constructor(t=new La, e=new La, n=new La, i=new La, r=new La, a=new La) {
                this.planes = [t, e, n, i, r, a]
            }
            set(t, e, n, i, r, a) {
                const o = this.planes;
                return o[0].copy(t),
                o[1].copy(e),
                o[2].copy(n),
                o[3].copy(i),
                o[4].copy(r),
                o[5].copy(a),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t, e=tn) {
                const n = this.planes
                  , i = t.elements
                  , r = i[0]
                  , a = i[1]
                  , o = i[2]
                  , s = i[3]
                  , c = i[4]
                  , l = i[5]
                  , u = i[6]
                  , h = i[7]
                  , d = i[8]
                  , p = i[9]
                  , f = i[10]
                  , m = i[11]
                  , g = i[12]
                  , v = i[13]
                  , _ = i[14]
                  , y = i[15];
                if (n[0].setComponents(s - r, h - c, m - d, y - g).normalize(),
                n[1].setComponents(s + r, h + c, m + d, y + g).normalize(),
                n[2].setComponents(s + a, h + l, m + p, y + v).normalize(),
                n[3].setComponents(s - a, h - l, m - p, y - v).normalize(),
                n[4].setComponents(s - o, h - u, m - f, y - _).normalize(),
                e === tn)
                    n[5].setComponents(s + o, h + u, m + f, y + _).normalize();
                else {
                    if (e !== en)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    n[5].setComponents(o, u, f, _).normalize()
                }
                return this
            }
            intersectsObject(t) {
                if (void 0 !== t.boundingSphere)
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Ia.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                else {
                    const e = t.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Ia.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                }
                return this.intersectsSphere(Ia)
            }
            intersectsSprite(t) {
                return Ia.center.set(0, 0, 0),
                Ia.radius = .7071067811865476,
                Ia.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(Ia)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , n = t.center
                  , i = -t.radius;
                for (let r = 0; r < 6; r++) {
                    const t = e[r].distanceToPoint(n);
                    if (t < i)
                        return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Ua.x = i.normal.x > 0 ? t.max.x : t.min.x,
                    Ua.y = i.normal.y > 0 ? t.max.y : t.min.y,
                    Ua.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint(Ua) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function Na() {
            let t = null
              , e = !1
              , n = null
              , i = null;
            function r(e, a) {
                n(e, a),
                i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function Oa(t) {
            const e = new WeakMap;
            function n(e, n) {
                const i = e.array
                  , r = e.usage
                  , a = i.byteLength
                  , o = t.createBuffer();
                let s;
                if (t.bindBuffer(n, o),
                t.bufferData(n, i, r),
                e.onUploadCallback(),
                i instanceof Float32Array)
                    s = t.FLOAT;
                else if (i instanceof Uint16Array)
                    s = e.isFloat16BufferAttribute ? t.HALF_FLOAT : t.UNSIGNED_SHORT;
                else if (i instanceof Int16Array)
                    s = t.SHORT;
                else if (i instanceof Uint32Array)
                    s = t.UNSIGNED_INT;
                else if (i instanceof Int32Array)
                    s = t.INT;
                else if (i instanceof Int8Array)
                    s = t.BYTE;
                else if (i instanceof Uint8Array)
                    s = t.UNSIGNED_BYTE;
                else {
                    if (!(i instanceof Uint8ClampedArray))
                        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                    s = t.UNSIGNED_BYTE
                }
                return {
                    buffer: o,
                    type: s,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: e.version,
                    size: a
                }
            }
            function i(e, n, i) {
                const r = n.array
                  , a = n._updateRange
                  , o = n.updateRanges;
                if (t.bindBuffer(i, e),
                -1 === a.count && 0 === o.length && t.bufferSubData(i, 0, r),
                0 !== o.length) {
                    for (let e = 0, n = o.length; e < n; e++) {
                        const n = o[e];
                        t.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                    }
                    n.clearUpdateRanges()
                }
                -1 !== a.count && (t.bufferSubData(i, a.offset * r.BYTES_PER_ELEMENT, r, a.offset, a.count),
                a.count = -1),
                n.onUploadCallback()
            }
            function r(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                e.get(t)
            }
            function a(n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                const i = e.get(n);
                i && (t.deleteBuffer(i.buffer),
                e.delete(n))
            }
            function o(t, r) {
                if (t.isGLBufferAttribute) {
                    const n = e.get(t);
                    return void ((!n || n.version < t.version) && e.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }))
                }
                t.isInterleavedBufferAttribute && (t = t.data);
                const a = e.get(t);
                if (void 0 === a)
                    e.set(t, n(t, r));
                else if (a.version < t.version) {
                    if (a.size !== t.array.byteLength)
                        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                    i(a.buffer, t, r),
                    a.version = t.version
                }
            }
            return {
                get: r,
                remove: a,
                update: o
            }
        }
        class Fa extends Hr {
            constructor(t=1, e=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2
                  , a = e / 2
                  , o = Math.floor(n)
                  , s = Math.floor(i)
                  , c = o + 1
                  , l = s + 1
                  , u = t / o
                  , h = e / s
                  , d = []
                  , p = []
                  , f = []
                  , m = [];
                for (let g = 0; g < l; g++) {
                    const t = g * h - a;
                    for (let e = 0; e < c; e++) {
                        const n = e * u - r;
                        p.push(n, -t, 0),
                        f.push(0, 0, 1),
                        m.push(e / o),
                        m.push(1 - g / s)
                    }
                }
                for (let g = 0; g < s; g++)
                    for (let t = 0; t < o; t++) {
                        const e = t + c * g
                          , n = t + c * (g + 1)
                          , i = t + 1 + c * (g + 1)
                          , r = t + 1 + c * g;
                        d.push(e, n, r),
                        d.push(n, i, r)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Dr(p,3)),
                this.setAttribute("normal", new Dr(f,3)),
                this.setAttribute("uv", new Dr(m,2))
            }
            copy(t) {
                return super.copy(t),
                this.parameters = Object.assign({}, t.parameters),
                this
            }
            static fromJSON(t) {
                return new Fa(t.width,t.height,t.widthSegments,t.heightSegments)
            }
        }
        var Ba = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif"
          , ka = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif"
          , za = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif"
          , Va = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
          , Ha = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif"
          , Ga = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif"
          , ja = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif"
          , Wa = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"
          , Xa = "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif"
          , qa = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif"
          , $a = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif"
          , Ya = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif"
          , Ka = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated"
          , Za = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif"
          , Ja = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif"
          , Qa = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif"
          , to = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif"
          , eo = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif"
          , no = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif"
          , io = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif"
          , ro = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif"
          , ao = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif"
          , oo = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif"
          , so = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated"
          , co = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif"
          , lo = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif"
          , uo = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif"
          , ho = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif"
          , po = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif"
          , fo = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif"
          , mo = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
          , go = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}"
          , vo = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif"
          , _o = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif"
          , yo = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif"
          , xo = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif"
          , Mo = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif"
          , bo = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif"
          , So = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif"
          , Eo = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif"
          , To = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"
          , wo = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}"
          , Ao = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
          , Ro = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;"
          , Co = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert"
          , Po = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif"
          , Lo = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif"
          , Io = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;"
          , Uo = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon"
          , Do = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;"
          , No = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong"
          , Oo = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif"
          , Fo = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}"
          , Bo = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif"
          , ko = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif"
          , zo = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif"
          , Vo = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif"
          , Ho = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif"
          , Go = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif"
          , jo = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif"
          , Wo = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif"
          , Xo = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif"
          , qo = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif"
          , $o = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
          , Yo = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif"
          , Ko = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"
          , Zo = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif"
          , Jo = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif"
          , Qo = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif"
          , ts = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif"
          , es = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif"
          , ns = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;"
          , is = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif"
          , rs = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif"
          , as = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif"
          , os = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif"
          , ss = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif"
          , cs = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif"
          , ls = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif"
          , us = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif"
          , hs = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif"
          , ds = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );"
          , ps = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}"
          , fs = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif"
          , ms = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;"
          , gs = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif"
          , vs = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif"
          , _s = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif"
          , ys = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
          , xs = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif"
          , Ms = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif"
          , bs = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif"
          , Ss = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}"
          , Es = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
          , Ts = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif"
          , ws = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif"
          , As = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif"
          , Rs = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"
          , Cs = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"
          , Ps = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif"
          , Ls = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }"
          , Is = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif"
          , Us = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif"
          , Ds = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif"
          , Ns = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif"
          , Os = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif"
          , Fs = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
        const Bs = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}"
          , ks = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"
          , zs = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}"
          , Vs = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"
          , Hs = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}"
          , Gs = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"
          , js = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}"
          , Ws = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}"
          , Xs = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}"
          , qs = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}"
          , $s = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}"
          , Ys = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"
          , Ks = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
          , Zs = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
          , Js = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}"
          , Qs = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , tc = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
          , ec = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , nc = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}"
          , ic = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , rc = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}"
          , ac = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}"
          , oc = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
          , sc = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , cc = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}"
          , lc = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , uc = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
          , hc = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
          , dc = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}"
          , pc = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
          , fc = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
          , mc = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
          , gc = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
          , vc = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
          , _c = {
            alphahash_fragment: Ba,
            alphahash_pars_fragment: ka,
            alphamap_fragment: za,
            alphamap_pars_fragment: Va,
            alphatest_fragment: Ha,
            alphatest_pars_fragment: Ga,
            aomap_fragment: ja,
            aomap_pars_fragment: Wa,
            batching_pars_vertex: Xa,
            batching_vertex: qa,
            begin_vertex: $a,
            beginnormal_vertex: Ya,
            bsdfs: Ka,
            iridescence_fragment: Za,
            bumpmap_pars_fragment: Ja,
            clipping_planes_fragment: Qa,
            clipping_planes_pars_fragment: to,
            clipping_planes_pars_vertex: eo,
            clipping_planes_vertex: no,
            color_fragment: io,
            color_pars_fragment: ro,
            color_pars_vertex: ao,
            color_vertex: oo,
            common: so,
            cube_uv_reflection_fragment: co,
            defaultnormal_vertex: lo,
            displacementmap_pars_vertex: uo,
            displacementmap_vertex: ho,
            emissivemap_fragment: po,
            emissivemap_pars_fragment: fo,
            colorspace_fragment: mo,
            colorspace_pars_fragment: go,
            envmap_fragment: vo,
            envmap_common_pars_fragment: _o,
            envmap_pars_fragment: yo,
            envmap_pars_vertex: xo,
            envmap_physical_pars_fragment: Lo,
            envmap_vertex: Mo,
            fog_vertex: bo,
            fog_pars_vertex: So,
            fog_fragment: Eo,
            fog_pars_fragment: To,
            gradientmap_pars_fragment: wo,
            lightmap_pars_fragment: Ao,
            lights_lambert_fragment: Ro,
            lights_lambert_pars_fragment: Co,
            lights_pars_begin: Po,
            lights_toon_fragment: Io,
            lights_toon_pars_fragment: Uo,
            lights_phong_fragment: Do,
            lights_phong_pars_fragment: No,
            lights_physical_fragment: Oo,
            lights_physical_pars_fragment: Fo,
            lights_fragment_begin: Bo,
            lights_fragment_maps: ko,
            lights_fragment_end: zo,
            logdepthbuf_fragment: Vo,
            logdepthbuf_pars_fragment: Ho,
            logdepthbuf_pars_vertex: Go,
            logdepthbuf_vertex: jo,
            map_fragment: Wo,
            map_pars_fragment: Xo,
            map_particle_fragment: qo,
            map_particle_pars_fragment: $o,
            metalnessmap_fragment: Yo,
            metalnessmap_pars_fragment: Ko,
            morphinstance_vertex: Zo,
            morphcolor_vertex: Jo,
            morphnormal_vertex: Qo,
            morphtarget_pars_vertex: ts,
            morphtarget_vertex: es,
            normal_fragment_begin: ns,
            normal_fragment_maps: is,
            normal_pars_fragment: rs,
            normal_pars_vertex: as,
            normal_vertex: os,
            normalmap_pars_fragment: ss,
            clearcoat_normal_fragment_begin: cs,
            clearcoat_normal_fragment_maps: ls,
            clearcoat_pars_fragment: us,
            iridescence_pars_fragment: hs,
            opaque_fragment: ds,
            packing: ps,
            premultiplied_alpha_fragment: fs,
            project_vertex: ms,
            dithering_fragment: gs,
            dithering_pars_fragment: vs,
            roughnessmap_fragment: _s,
            roughnessmap_pars_fragment: ys,
            shadowmap_pars_fragment: xs,
            shadowmap_pars_vertex: Ms,
            shadowmap_vertex: bs,
            shadowmask_pars_fragment: Ss,
            skinbase_vertex: Es,
            skinning_pars_vertex: Ts,
            skinning_vertex: ws,
            skinnormal_vertex: As,
            specularmap_fragment: Rs,
            specularmap_pars_fragment: Cs,
            tonemapping_fragment: Ps,
            tonemapping_pars_fragment: Ls,
            transmission_fragment: Is,
            transmission_pars_fragment: Us,
            uv_pars_fragment: Ds,
            uv_pars_vertex: Ns,
            uv_vertex: Os,
            worldpos_vertex: Fs,
            background_vert: Bs,
            background_frag: ks,
            backgroundCube_vert: zs,
            backgroundCube_frag: Vs,
            cube_vert: Hs,
            cube_frag: Gs,
            depth_vert: js,
            depth_frag: Ws,
            distanceRGBA_vert: Xs,
            distanceRGBA_frag: qs,
            equirect_vert: $s,
            equirect_frag: Ys,
            linedashed_vert: Ks,
            linedashed_frag: Zs,
            meshbasic_vert: Js,
            meshbasic_frag: Qs,
            meshlambert_vert: tc,
            meshlambert_frag: ec,
            meshmatcap_vert: nc,
            meshmatcap_frag: ic,
            meshnormal_vert: rc,
            meshnormal_frag: ac,
            meshphong_vert: oc,
            meshphong_frag: sc,
            meshphysical_vert: cc,
            meshphysical_frag: lc,
            meshtoon_vert: uc,
            meshtoon_frag: hc,
            points_vert: dc,
            points_frag: pc,
            shadow_vert: fc,
            shadow_frag: mc,
            sprite_vert: gc,
            sprite_frag: vc
        }
          , yc = {
            common: {
                diffuse: {
                    value: new Er(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new In
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new In
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new In
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new In
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new In
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new In
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new In
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new In
                },
                normalScale: {
                    value: new Ln(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new In
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new In
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new In
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new In
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Er(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Er(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new In
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new In
                }
            },
            sprite: {
                diffuse: {
                    value: new Er(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Ln(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new In
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new In
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , xc = {
            basic: {
                uniforms: ha([yc.common, yc.specularmap, yc.envmap, yc.aomap, yc.lightmap, yc.fog]),
                vertexShader: _c.meshbasic_vert,
                fragmentShader: _c.meshbasic_frag
            },
            lambert: {
                uniforms: ha([yc.common, yc.specularmap, yc.envmap, yc.aomap, yc.lightmap, yc.emissivemap, yc.bumpmap, yc.normalmap, yc.displacementmap, yc.fog, yc.lights, {
                    emissive: {
                        value: new Er(0)
                    }
                }]),
                vertexShader: _c.meshlambert_vert,
                fragmentShader: _c.meshlambert_frag
            },
            phong: {
                uniforms: ha([yc.common, yc.specularmap, yc.envmap, yc.aomap, yc.lightmap, yc.emissivemap, yc.bumpmap, yc.normalmap, yc.displacementmap, yc.fog, yc.lights, {
                    emissive: {
                        value: new Er(0)
                    },
                    specular: {
                        value: new Er(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: _c.meshphong_vert,
                fragmentShader: _c.meshphong_frag
            },
            standard: {
                uniforms: ha([yc.common, yc.envmap, yc.aomap, yc.lightmap, yc.emissivemap, yc.bumpmap, yc.normalmap, yc.displacementmap, yc.roughnessmap, yc.metalnessmap, yc.fog, yc.lights, {
                    emissive: {
                        value: new Er(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: _c.meshphysical_vert,
                fragmentShader: _c.meshphysical_frag
            },
            toon: {
                uniforms: ha([yc.common, yc.aomap, yc.lightmap, yc.emissivemap, yc.bumpmap, yc.normalmap, yc.displacementmap, yc.gradientmap, yc.fog, yc.lights, {
                    emissive: {
                        value: new Er(0)
                    }
                }]),
                vertexShader: _c.meshtoon_vert,
                fragmentShader: _c.meshtoon_frag
            },
            matcap: {
                uniforms: ha([yc.common, yc.bumpmap, yc.normalmap, yc.displacementmap, yc.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: _c.meshmatcap_vert,
                fragmentShader: _c.meshmatcap_frag
            },
            points: {
                uniforms: ha([yc.points, yc.fog]),
                vertexShader: _c.points_vert,
                fragmentShader: _c.points_frag
            },
            dashed: {
                uniforms: ha([yc.common, yc.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: _c.linedashed_vert,
                fragmentShader: _c.linedashed_frag
            },
            depth: {
                uniforms: ha([yc.common, yc.displacementmap]),
                vertexShader: _c.depth_vert,
                fragmentShader: _c.depth_frag
            },
            normal: {
                uniforms: ha([yc.common, yc.bumpmap, yc.normalmap, yc.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: _c.meshnormal_vert,
                fragmentShader: _c.meshnormal_frag
            },
            sprite: {
                uniforms: ha([yc.sprite, yc.fog]),
                vertexShader: _c.sprite_vert,
                fragmentShader: _c.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new In
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: _c.background_vert,
                fragmentShader: _c.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new In
                    }
                },
                vertexShader: _c.backgroundCube_vert,
                fragmentShader: _c.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: _c.cube_vert,
                fragmentShader: _c.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: _c.equirect_vert,
                fragmentShader: _c.equirect_frag
            },
            distanceRGBA: {
                uniforms: ha([yc.common, yc.displacementmap, {
                    referencePosition: {
                        value: new ai
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: _c.distanceRGBA_vert,
                fragmentShader: _c.distanceRGBA_frag
            },
            shadow: {
                uniforms: ha([yc.lights, yc.fog, {
                    color: {
                        value: new Er(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: _c.shadow_vert,
                fragmentShader: _c.shadow_frag
            }
        };
        xc.physical = {
            uniforms: ha([xc.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new In
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new In
                },
                clearcoatNormalScale: {
                    value: new Ln(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new In
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new In
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new In
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Er(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new In
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new In
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new In
                },
                transmissionSamplerSize: {
                    value: new Ln
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new In
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Er(0)
                },
                specularColor: {
                    value: new Er(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new In
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new In
                },
                anisotropyVector: {
                    value: new Ln
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new In
                }
            }]),
            vertexShader: _c.meshphysical_vert,
            fragmentShader: _c.meshphysical_frag
        };
        const Mc = {
            r: 0,
            b: 0,
            g: 0
        }
          , bc = new Wi
          , Sc = new Ni;
        function Ec(t, e, n, i, r, a, o) {
            const s = new Er(0);
            let c, l, u = !0 === a ? 0 : 1, h = null, f = 0, m = null;
            function g(t) {
                let i = !0 === t.isScene ? t.background : null;
                if (i && i.isTexture) {
                    const r = t.backgroundBlurriness > 0;
                    i = (r ? n : e).get(i)
                }
                return i
            }
            function v(e) {
                let n = !1;
                const r = g(e);
                null === r ? y(s, u) : r && r.isColor && (y(r, 1),
                n = !0);
                const a = t.xr.getEnvironmentBlendMode();
                "additive" === a ? i.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === a && i.buffers.color.setClear(0, 0, 0, 0, o),
                (t.autoClear || n) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil)
            }
            function _(e, n) {
                const i = g(n);
                i && (i.isCubeTexture || i.mapping === ht) ? (void 0 === l && (l = new oa(new la(1,1,1),new va({
                    name: "BackgroundCubeMaterial",
                    uniforms: ua(xc.backgroundCube.uniforms),
                    vertexShader: xc.backgroundCube.vertexShader,
                    fragmentShader: xc.backgroundCube.fragmentShader,
                    side: p,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                l.geometry.deleteAttribute("normal"),
                l.geometry.deleteAttribute("uv"),
                l.onBeforeRender = function(t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }
                ,
                Object.defineProperty(l.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                r.update(l)),
                bc.copy(n.backgroundRotation),
                bc.x *= -1,
                bc.y *= -1,
                bc.z *= -1,
                i.isCubeTexture && !1 === i.isRenderTargetTexture && (bc.y *= -1,
                bc.z *= -1),
                l.material.uniforms.envMap.value = i,
                l.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                l.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness,
                l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                l.material.uniforms.backgroundRotation.value.setFromMatrix4(Sc.makeRotationFromEuler(bc)),
                l.material.toneMapped = Gn.getTransfer(i.colorSpace) !== ke,
                h === i && f === i.version && m === t.toneMapping || (l.material.needsUpdate = !0,
                h = i,
                f = i.version,
                m = t.toneMapping),
                l.layers.enableAll(),
                e.unshift(l, l.geometry, l.material, 0, 0, null)) : i && i.isTexture && (void 0 === c && (c = new oa(new Fa(2,2),new va({
                    name: "BackgroundMaterial",
                    uniforms: ua(xc.background.uniforms),
                    vertexShader: xc.background.vertexShader,
                    fragmentShader: xc.background.fragmentShader,
                    side: d,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                c.geometry.deleteAttribute("normal"),
                Object.defineProperty(c.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                r.update(c)),
                c.material.uniforms.t2D.value = i,
                c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                c.material.toneMapped = Gn.getTransfer(i.colorSpace) !== ke,
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                c.material.uniforms.uvTransform.value.copy(i.matrix),
                h === i && f === i.version && m === t.toneMapping || (c.material.needsUpdate = !0,
                h = i,
                f = i.version,
                m = t.toneMapping),
                c.layers.enableAll(),
                e.unshift(c, c.geometry, c.material, 0, 0, null))
            }
            function y(e, n) {
                e.getRGB(Mc, pa(t)),
                i.buffers.color.setClear(Mc.r, Mc.g, Mc.b, n, o)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(t, e=1) {
                    s.set(t),
                    u = e,
                    y(s, u)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(t) {
                    u = t,
                    y(s, u)
                },
                render: v,
                addToRenderList: _
            }
        }
        function Tc(t, e) {
            const n = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , i = {}
              , r = d(null);
            let a = r
              , o = !1;
            function s(n, i, r, s, c) {
                let u = !1;
                const d = h(s, r, i);
                a !== d && (a = d,
                l(a.object)),
                u = p(n, s, r, c),
                u && f(n, s, r, c),
                null !== c && e.update(c, t.ELEMENT_ARRAY_BUFFER),
                (u || o) && (o = !1,
                x(n, i, r, s),
                null !== c && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(c).buffer))
            }
            function c() {
                return t.createVertexArray()
            }
            function l(e) {
                return t.bindVertexArray(e)
            }
            function u(e) {
                return t.deleteVertexArray(e)
            }
            function h(t, e, n) {
                const r = !0 === n.wireframe;
                let a = i[t.id];
                void 0 === a && (a = {},
                i[t.id] = a);
                let o = a[e.id];
                void 0 === o && (o = {},
                a[e.id] = o);
                let s = o[r];
                return void 0 === s && (s = d(c()),
                o[r] = s),
                s
            }
            function d(t) {
                const e = []
                  , i = []
                  , r = [];
                for (let a = 0; a < n; a++)
                    e[a] = 0,
                    i[a] = 0,
                    r[a] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: i,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function p(t, e, n, i) {
                const r = a.attributes
                  , o = e.attributes;
                let s = 0;
                const c = n.getAttributes();
                for (const a in c) {
                    const e = c[a];
                    if (e.location >= 0) {
                        const e = r[a];
                        let n = o[a];
                        if (void 0 === n && ("instanceMatrix" === a && t.instanceMatrix && (n = t.instanceMatrix),
                        "instanceColor" === a && t.instanceColor && (n = t.instanceColor)),
                        void 0 === e)
                            return !0;
                        if (e.attribute !== n)
                            return !0;
                        if (n && e.data !== n.data)
                            return !0;
                        s++
                    }
                }
                return a.attributesNum !== s || a.index !== i
            }
            function f(t, e, n, i) {
                const r = {}
                  , o = e.attributes;
                let s = 0;
                const c = n.getAttributes();
                for (const a in c) {
                    const e = c[a];
                    if (e.location >= 0) {
                        let e = o[a];
                        void 0 === e && ("instanceMatrix" === a && t.instanceMatrix && (e = t.instanceMatrix),
                        "instanceColor" === a && t.instanceColor && (e = t.instanceColor));
                        const n = {};
                        n.attribute = e,
                        e && e.data && (n.data = e.data),
                        r[a] = n,
                        s++
                    }
                }
                a.attributes = r,
                a.attributesNum = s,
                a.index = i
            }
            function m() {
                const t = a.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function g(t) {
                v(t, 0)
            }
            function v(e, n) {
                const i = a.newAttributes
                  , r = a.enabledAttributes
                  , o = a.attributeDivisors;
                i[e] = 1,
                0 === r[e] && (t.enableVertexAttribArray(e),
                r[e] = 1),
                o[e] !== n && (t.vertexAttribDivisor(e, n),
                o[e] = n)
            }
            function _() {
                const e = a.newAttributes
                  , n = a.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== e[i] && (t.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function y(e, n, i, r, a, o, s) {
                !0 === s ? t.vertexAttribIPointer(e, n, i, a, o) : t.vertexAttribPointer(e, n, i, r, a, o)
            }
            function x(n, i, r, a) {
                m();
                const o = a.attributes
                  , s = r.getAttributes()
                  , c = i.defaultAttributeValues;
                for (const l in s) {
                    const i = s[l];
                    if (i.location >= 0) {
                        let r = o[l];
                        if (void 0 === r && ("instanceMatrix" === l && n.instanceMatrix && (r = n.instanceMatrix),
                        "instanceColor" === l && n.instanceColor && (r = n.instanceColor)),
                        void 0 !== r) {
                            const o = r.normalized
                              , s = r.itemSize
                              , c = e.get(r);
                            if (void 0 === c)
                                continue;
                            const l = c.buffer
                              , u = c.type
                              , h = c.bytesPerElement
                              , d = u === t.INT || u === t.UNSIGNED_INT || r.gpuType === Tt;
                            if (r.isInterleavedBufferAttribute) {
                                const e = r.data
                                  , c = e.stride
                                  , p = r.offset;
                                if (e.isInstancedInterleavedBuffer) {
                                    for (let t = 0; t < i.locationSize; t++)
                                        v(i.location + t, e.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = e.meshPerAttribute * e.count)
                                } else
                                    for (let t = 0; t < i.locationSize; t++)
                                        g(i.location + t);
                                t.bindBuffer(t.ARRAY_BUFFER, l);
                                for (let t = 0; t < i.locationSize; t++)
                                    y(i.location + t, s / i.locationSize, u, o, c * h, (p + s / i.locationSize * t) * h, d)
                            } else {
                                if (r.isInstancedBufferAttribute) {
                                    for (let t = 0; t < i.locationSize; t++)
                                        v(i.location + t, r.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = r.meshPerAttribute * r.count)
                                } else
                                    for (let t = 0; t < i.locationSize; t++)
                                        g(i.location + t);
                                t.bindBuffer(t.ARRAY_BUFFER, l);
                                for (let t = 0; t < i.locationSize; t++)
                                    y(i.location + t, s / i.locationSize, u, o, s * h, s / i.locationSize * t * h, d)
                            }
                        } else if (void 0 !== c) {
                            const e = c[l];
                            if (void 0 !== e)
                                switch (e.length) {
                                case 2:
                                    t.vertexAttrib2fv(i.location, e);
                                    break;
                                case 3:
                                    t.vertexAttrib3fv(i.location, e);
                                    break;
                                case 4:
                                    t.vertexAttrib4fv(i.location, e);
                                    break;
                                default:
                                    t.vertexAttrib1fv(i.location, e)
                                }
                        }
                    }
                }
                _()
            }
            function M() {
                E();
                for (const t in i) {
                    const e = i[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            u(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete i[t]
                }
            }
            function b(t) {
                if (void 0 === i[t.id])
                    return;
                const e = i[t.id];
                for (const n in e) {
                    const t = e[n];
                    for (const e in t)
                        u(t[e].object),
                        delete t[e];
                    delete e[n]
                }
                delete i[t.id]
            }
            function S(t) {
                for (const e in i) {
                    const n = i[e];
                    if (void 0 === n[t.id])
                        continue;
                    const r = n[t.id];
                    for (const t in r)
                        u(r[t].object),
                        delete r[t];
                    delete n[t.id]
                }
            }
            function E() {
                T(),
                o = !0,
                a !== r && (a = r,
                l(a.object))
            }
            function T() {
                r.geometry = null,
                r.program = null,
                r.wireframe = !1
            }
            return {
                setup: s,
                reset: E,
                resetDefaultState: T,
                dispose: M,
                releaseStatesOfGeometry: b,
                releaseStatesOfProgram: S,
                initAttributes: m,
                enableAttribute: g,
                disableUnusedAttributes: _
            }
        }
        function wc(t, e, n) {
            let i;
            function r(t) {
                i = t
            }
            function a(e, r) {
                t.drawArrays(i, e, r),
                n.update(r, i, 1)
            }
            function o(e, r, a) {
                0 !== a && (t.drawArraysInstanced(i, e, r, a),
                n.update(r, i, a))
            }
            function s(t, r, a) {
                if (0 === a)
                    return;
                const o = e.get("WEBGL_multi_draw");
                if (null === o)
                    for (let e = 0; e < a; e++)
                        this.render(t[e], r[e]);
                else {
                    o.multiDrawArraysWEBGL(i, t, 0, r, 0, a);
                    let e = 0;
                    for (let t = 0; t < a; t++)
                        e += r[t];
                    n.update(e, i, 1)
                }
            }
            function c(t, r, a, s) {
                if (0 === a)
                    return;
                const c = e.get("WEBGL_multi_draw");
                if (null === c)
                    for (let e = 0; e < t.length; e++)
                        o(t[e], r[e], s[e]);
                else {
                    c.multiDrawArraysInstancedWEBGL(i, t, 0, r, 0, s, 0, a);
                    let e = 0;
                    for (let t = 0; t < a; t++)
                        e += r[t];
                    for (let t = 0; t < s.length; t++)
                        n.update(e, i, s[t])
                }
            }
            this.setMode = r,
            this.render = a,
            this.renderInstances = o,
            this.renderMultiDraw = s,
            this.renderMultiDrawInstances = c
        }
        function Ac(t, e, n, i) {
            let r;
            function a() {
                if (void 0 !== r)
                    return r;
                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                    const n = e.get("EXT_texture_filter_anisotropic");
                    r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    r = 0;
                return r
            }
            function o(e) {
                return e === Nt || i.convert(e) === t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
            }
            function s(n) {
                const r = n === Rt && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
                return !(n !== Mt && i.convert(n) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && n !== At && !r)
            }
            function c(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            let l = void 0 !== n.precision ? n.precision : "highp";
            const u = c(l);
            u !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", u, "instead."),
            l = u);
            const h = !0 === n.logarithmicDepthBuffer
              , d = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
              , p = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , f = t.getParameter(t.MAX_TEXTURE_SIZE)
              , m = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
              , g = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , v = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
              , _ = t.getParameter(t.MAX_VARYING_VECTORS)
              , y = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
              , x = p > 0
              , M = t.getParameter(t.MAX_SAMPLES);
            return {
                isWebGL2: !0,
                getMaxAnisotropy: a,
                getMaxPrecision: c,
                textureFormatReadable: o,
                textureTypeReadable: s,
                precision: l,
                logarithmicDepthBuffer: h,
                maxTextures: d,
                maxVertexTextures: p,
                maxTextureSize: f,
                maxCubemapSize: m,
                maxAttributes: g,
                maxVertexUniforms: v,
                maxVaryings: _,
                maxFragmentUniforms: y,
                vertexTextures: x,
                maxSamples: M
            }
        }
        function Rc(t) {
            const e = this;
            let n = null
              , i = 0
              , r = !1
              , a = !1;
            const o = new La
              , s = new In
              , c = {
                value: null,
                needsUpdate: !1
            };
            function l() {
                c.value !== n && (c.value = n,
                c.needsUpdate = i > 0),
                e.numPlanes = i,
                e.numIntersection = 0
            }
            function u(t, n, i, r) {
                const a = null !== t ? t.length : 0;
                let l = null;
                if (0 !== a) {
                    if (l = c.value,
                    !0 !== r || null === l) {
                        const e = i + 4 * a
                          , r = n.matrixWorldInverse;
                        s.getNormalMatrix(r),
                        (null === l || l.length < e) && (l = new Float32Array(e));
                        for (let n = 0, c = i; n !== a; ++n,
                        c += 4)
                            o.copy(t[n]).applyMatrix4(r, s),
                            o.normal.toArray(l, c),
                            l[c + 3] = o.constant
                    }
                    c.value = l,
                    c.needsUpdate = !0
                }
                return e.numPlanes = a,
                e.numIntersection = 0,
                l
            }
            this.uniform = c,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e) {
                const n = 0 !== t.length || e || 0 !== i || r;
                return r = e,
                i = t.length,
                n
            }
            ,
            this.beginShadows = function() {
                a = !0,
                u(null)
            }
            ,
            this.endShadows = function() {
                a = !1
            }
            ,
            this.setGlobalState = function(t, e) {
                n = u(t, e, 0)
            }
            ,
            this.setState = function(e, o, s) {
                const h = e.clippingPlanes
                  , d = e.clipIntersection
                  , p = e.clipShadows
                  , f = t.get(e);
                if (!r || null === h || 0 === h.length || a && !p)
                    a ? u(null) : l();
                else {
                    const t = a ? 0 : i
                      , e = 4 * t;
                    let r = f.clippingState || null;
                    c.value = r,
                    r = u(h, o, e, s);
                    for (let i = 0; i !== e; ++i)
                        r[i] = n[i];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        function Cc(t) {
            let e = new WeakMap;
            function n(t, e) {
                return e === lt ? t.mapping = st : e === ut && (t.mapping = ct),
                t
            }
            function i(i) {
                if (i && i.isTexture) {
                    const a = i.mapping;
                    if (a === lt || a === ut) {
                        if (e.has(i)) {
                            const t = e.get(i).texture;
                            return n(t, i.mapping)
                        }
                        {
                            const a = i.image;
                            if (a && a.height > 0) {
                                const o = new Aa(a.height);
                                return o.fromEquirectangularTexture(t, i),
                                e.set(i, o),
                                i.addEventListener("dispose", r),
                                n(o.texture, i.mapping)
                            }
                            return null
                        }
                    }
                }
                return i
            }
            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n),
                i.dispose())
            }
            function a() {
                e = new WeakMap
            }
            return {
                get: i,
                dispose: a
            }
        }
        class Pc extends _a {
            constructor(t=-1, e=1, n=1, i=-1, r=.1, a=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = a,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, n, i, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - t
                  , a = n + t
                  , o = i + e
                  , s = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                    a = r + t * this.view.width,
                    o -= e * this.view.offsetY,
                    s = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        const Lc = 4
          , Ic = [.125, .215, .35, .446, .526, .582]
          , Uc = 20
          , Dc = new Pc
          , Nc = new Er;
        let Oc = null
          , Fc = 0
          , Bc = 0
          , kc = !1;
        const zc = (1 + Math.sqrt(5)) / 2
          , Vc = 1 / zc
          , Hc = [new ai(-zc,Vc,0), new ai(zc,Vc,0), new ai(-Vc,0,zc), new ai(Vc,0,zc), new ai(0,zc,-Vc), new ai(0,zc,Vc), new ai(-1,1,-1), new ai(1,1,-1), new ai(-1,1,1), new ai(1,1,1)];
        class Gc {
            constructor(t) {
                this._renderer = t,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e=0, n=.1, i=100) {
                Oc = this._renderer.getRenderTarget(),
                Fc = this._renderer.getActiveCubeFace(),
                Bc = this._renderer.getActiveMipmapLevel(),
                kc = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1,
                this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0,
                this._sceneToCubeUV(t, n, i, r),
                e > 0 && this._blur(r, 0, 0, e),
                this._applyPMREM(r),
                this._cleanup(r),
                r
            }
            fromEquirectangular(t, e=null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e=null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Yc(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = $c(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++)
                    this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(Oc, Fc, Bc),
                this._renderer.xr.enabled = kc,
                t.scissorTest = !1,
                Xc(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === st || t.mapping === ct ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4),
                Oc = this._renderer.getRenderTarget(),
                Fc = this._renderer.getActiveCubeFace(),
                Bc = this._renderer.getActiveMipmapLevel(),
                kc = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1;
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112)
                  , e = 4 * this._cubeSize
                  , n = {
                    magFilter: _t,
                    minFilter: _t,
                    generateMipmaps: !1,
                    type: Rt,
                    format: Nt,
                    colorSpace: Ne,
                    depthBuffer: !1
                }
                  , i = Wc(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = Wc(t, e, n);
                    const {_lodMax: i} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = jc(i)),
                    this._blurMaterial = qc(i, t, e)
                }
                return i
            }
            _compileMaterial(t) {
                const e = new oa(this._lodPlanes[0],t);
                this._renderer.compile(e, Dc)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = 90
                  , a = 1
                  , o = new ba(r,a,e,n)
                  , s = [1, -1, 1, 1, 1, 1]
                  , c = [1, 1, 1, -1, -1, -1]
                  , l = this._renderer
                  , u = l.autoClear
                  , h = l.toneMapping;
                l.getClearColor(Nc),
                l.toneMapping = J,
                l.autoClear = !1;
                const d = new Rr({
                    name: "PMREM.Background",
                    side: p,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , f = new oa(new la,d);
                let m = !1;
                const g = t.background;
                g ? g.isColor && (d.color.copy(g),
                t.background = null,
                m = !0) : (d.color.copy(Nc),
                m = !0);
                for (let p = 0; p < 6; p++) {
                    const e = p % 3;
                    0 === e ? (o.up.set(0, s[p], 0),
                    o.lookAt(c[p], 0, 0)) : 1 === e ? (o.up.set(0, 0, s[p]),
                    o.lookAt(0, c[p], 0)) : (o.up.set(0, s[p], 0),
                    o.lookAt(0, 0, c[p]));
                    const n = this._cubeSize;
                    Xc(i, e * n, p > 2 ? n : 0, n, n),
                    l.setRenderTarget(i),
                    m && l.render(f, o),
                    l.render(t, o)
                }
                f.geometry.dispose(),
                f.material.dispose(),
                l.toneMapping = h,
                l.autoClear = u,
                t.background = g
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer
                  , i = t.mapping === st || t.mapping === ct;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Yc()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = $c());
                const r = i ? this._cubemapMaterial : this._equirectMaterial
                  , a = new oa(this._lodPlanes[0],r)
                  , o = r.uniforms;
                o["envMap"].value = t;
                const s = this._cubeSize;
                Xc(e, 0, 0, 3 * s, 2 * s),
                n.setRenderTarget(e),
                n.render(a, Dc)
            }
            _applyPMREM(t) {
                const e = this._renderer
                  , n = e.autoClear;
                e.autoClear = !1;
                const i = this._lodPlanes.length;
                for (let r = 1; r < i; r++) {
                    const e = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
                      , n = Hc[(i - r - 1) % Hc.length];
                    this._blur(t, r - 1, r, e, n)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const a = this._pingPongRenderTarget;
                this._halfBlur(t, a, e, n, i, "latitudinal", r),
                this._halfBlur(a, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, a, o) {
                const s = this._renderer
                  , c = this._blurMaterial;
                "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                const l = 3
                  , u = new oa(this._lodPlanes[i],c)
                  , h = c.uniforms
                  , d = this._sizeLods[n] - 1
                  , p = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Uc - 1)
                  , f = r / p
                  , m = isFinite(r) ? 1 + Math.floor(l * f) : Uc;
                m > Uc && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Uc}`);
                const g = [];
                let v = 0;
                for (let b = 0; b < Uc; ++b) {
                    const t = b / f
                      , e = Math.exp(-t * t / 2);
                    g.push(e),
                    0 === b ? v += e : b < m && (v += 2 * e)
                }
                for (let b = 0; b < g.length; b++)
                    g[b] = g[b] / v;
                h["envMap"].value = t.texture,
                h["samples"].value = m,
                h["weights"].value = g,
                h["latitudinal"].value = "latitudinal" === a,
                o && (h["poleAxis"].value = o);
                const {_lodMax: _} = this;
                h["dTheta"].value = p,
                h["mipInt"].value = _ - n;
                const y = this._sizeLods[i]
                  , x = 3 * y * (i > _ - Lc ? i - _ + Lc : 0)
                  , M = 4 * (this._cubeSize - y);
                Xc(e, x, M, 3 * y, 2 * y),
                s.setRenderTarget(e),
                s.render(u, Dc)
            }
        }
        function jc(t) {
            const e = []
              , n = []
              , i = [];
            let r = t;
            const a = t - Lc + 1 + Ic.length;
            for (let o = 0; o < a; o++) {
                const a = Math.pow(2, r);
                n.push(a);
                let s = 1 / a;
                o > t - Lc ? s = Ic[o - t + Lc - 1] : 0 === o && (s = 0),
                i.push(s);
                const c = 1 / (a - 2)
                  , l = -c
                  , u = 1 + c
                  , h = [l, l, u, l, u, u, l, l, u, u, l, u]
                  , d = 6
                  , p = 6
                  , f = 3
                  , m = 2
                  , g = 1
                  , v = new Float32Array(f * p * d)
                  , _ = new Float32Array(m * p * d)
                  , y = new Float32Array(g * p * d);
                for (let t = 0; t < d; t++) {
                    const e = t % 3 * 2 / 3 - 1
                      , n = t > 2 ? 0 : -1
                      , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    v.set(i, f * p * t),
                    _.set(h, m * p * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, g * p * t)
                }
                const x = new Hr;
                x.setAttribute("position", new Lr(v,f)),
                x.setAttribute("uv", new Lr(_,m)),
                x.setAttribute("faceIndex", new Lr(y,g)),
                e.push(x),
                r > Lc && r--
            }
            return {
                lodPlanes: e,
                sizeLods: n,
                sigmas: i
            }
        }
        function Wc(t, e, n) {
            const i = new ei(t,e,n);
            return i.texture.mapping = ht,
            i.texture.name = "PMREM.cubeUv",
            i.scissorTest = !0,
            i
        }
        function Xc(t, e, n, i, r) {
            t.viewport.set(e, n, i, r),
            t.scissor.set(e, n, i, r)
        }
        function qc(t, e, n) {
            const i = new Float32Array(Uc)
              , r = new ai(0,1,0)
              , a = new va({
                name: "SphericalGaussianBlur",
                defines: {
                    n: Uc,
                    CUBEUV_TEXEL_WIDTH: 1 / e,
                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                    CUBEUV_MAX_MIP: `${t}.0`
                },
                uniforms: {
                    envMap: {
                        value: null
                    },
                    samples: {
                        value: 1
                    },
                    weights: {
                        value: i
                    },
                    latitudinal: {
                        value: !1
                    },
                    dTheta: {
                        value: 0
                    },
                    mipInt: {
                        value: 0
                    },
                    poleAxis: {
                        value: r
                    }
                },
                vertexShader: Kc(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: m,
                depthTest: !1,
                depthWrite: !1
            });
            return a
        }
        function $c() {
            return new va({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: Kc(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: m,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Yc() {
            return new va({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: Kc(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: m,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Kc() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function Zc(t) {
            let e = new WeakMap
              , n = null;
            function i(i) {
                if (i && i.isTexture) {
                    const o = i.mapping
                      , s = o === lt || o === ut
                      , c = o === st || o === ct;
                    if (s || c) {
                        let o = e.get(i);
                        const l = void 0 !== o ? o.texture.pmremVersion : 0;
                        if (i.isRenderTargetTexture && i.pmremVersion !== l)
                            return null === n && (n = new Gc(t)),
                            o = s ? n.fromEquirectangular(i, o) : n.fromCubemap(i, o),
                            o.texture.pmremVersion = i.pmremVersion,
                            e.set(i, o),
                            o.texture;
                        if (void 0 !== o)
                            return o.texture;
                        {
                            const l = i.image;
                            return s && l && l.height > 0 || c && l && r(l) ? (null === n && (n = new Gc(t)),
                            o = s ? n.fromEquirectangular(i) : n.fromCubemap(i),
                            o.texture.pmremVersion = i.pmremVersion,
                            e.set(i, o),
                            i.addEventListener("dispose", a),
                            o.texture) : null
                        }
                    }
                }
                return i
            }
            function r(t) {
                let e = 0;
                const n = 6;
                for (let i = 0; i < n; i++)
                    void 0 !== t[i] && e++;
                return e === n
            }
            function a(t) {
                const n = t.target;
                n.removeEventListener("dispose", a);
                const i = e.get(n);
                void 0 !== i && (e.delete(n),
                i.dispose())
            }
            function o() {
                e = new WeakMap,
                null !== n && (n.dispose(),
                n = null)
            }
            return {
                get: i,
                dispose: o
            }
        }
        function Jc(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function() {
                    n("EXT_color_buffer_float"),
                    n("WEBGL_clip_cull_distance"),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture"),
                    n("WEBGL_render_shared_exponent")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        function Qc(t, e, n, i) {
            const r = {}
              , a = new WeakMap;
            function o(t) {
                const s = t.target;
                null !== s.index && e.remove(s.index);
                for (const n in s.attributes)
                    e.remove(s.attributes[n]);
                for (const n in s.morphAttributes) {
                    const t = s.morphAttributes[n];
                    for (let n = 0, i = t.length; n < i; n++)
                        e.remove(t[n])
                }
                s.removeEventListener("dispose", o),
                delete r[s.id];
                const c = a.get(s);
                c && (e.remove(c),
                a.delete(s)),
                i.releaseStatesOfGeometry(s),
                !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
                n.memory.geometries--
            }
            function s(t, e) {
                return !0 === r[e.id] || (e.addEventListener("dispose", o),
                r[e.id] = !0,
                n.memory.geometries++),
                e
            }
            function c(n) {
                const i = n.attributes;
                for (const a in i)
                    e.update(i[a], t.ARRAY_BUFFER);
                const r = n.morphAttributes;
                for (const a in r) {
                    const n = r[a];
                    for (let i = 0, r = n.length; i < r; i++)
                        e.update(n[i], t.ARRAY_BUFFER)
                }
            }
            function l(t) {
                const n = []
                  , i = t.index
                  , r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0]
                          , r = t[e + 1]
                          , a = t[e + 2];
                        n.push(i, r, r, a, a, i)
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const t = r.array;
                        o = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0
                              , i = e + 1
                              , r = e + 2;
                            n.push(t, i, i, r, r, t)
                        }
                    }
                }
                const s = new (Dn(n) ? Ur : Ir)(n,1);
                s.version = o;
                const c = a.get(t);
                c && e.remove(c),
                a.set(t, s)
            }
            function u(t) {
                const e = a.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && l(t)
                } else
                    l(t);
                return a.get(t)
            }
            return {
                get: s,
                update: c,
                getWireframeAttribute: u
            }
        }
        function tl(t, e, n) {
            let i, r, a;
            function o(t) {
                i = t
            }
            function s(t) {
                r = t.type,
                a = t.bytesPerElement
            }
            function c(e, o) {
                t.drawElements(i, o, r, e * a),
                n.update(o, i, 1)
            }
            function l(e, o, s) {
                0 !== s && (t.drawElementsInstanced(i, o, r, e * a, s),
                n.update(o, i, s))
            }
            function u(t, o, s) {
                if (0 === s)
                    return;
                const c = e.get("WEBGL_multi_draw");
                if (null === c)
                    for (let e = 0; e < s; e++)
                        this.render(t[e] / a, o[e]);
                else {
                    c.multiDrawElementsWEBGL(i, o, 0, r, t, 0, s);
                    let e = 0;
                    for (let t = 0; t < s; t++)
                        e += o[t];
                    n.update(e, i, 1)
                }
            }
            function h(t, o, s, c) {
                if (0 === s)
                    return;
                const u = e.get("WEBGL_multi_draw");
                if (null === u)
                    for (let e = 0; e < t.length; e++)
                        l(t[e] / a, o[e], c[e]);
                else {
                    u.multiDrawElementsInstancedWEBGL(i, o, 0, r, t, 0, c, 0, s);
                    let e = 0;
                    for (let t = 0; t < s; t++)
                        e += o[t];
                    for (let t = 0; t < c.length; t++)
                        n.update(e, i, c[t])
                }
            }
            this.setMode = o,
            this.setIndex = s,
            this.render = c,
            this.renderInstances = l,
            this.renderMultiDraw = u,
            this.renderMultiDrawInstances = h
        }
        function el(t) {
            const e = {
                geometries: 0,
                textures: 0
            }
              , n = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            function i(e, i, r) {
                switch (n.calls++,
                i) {
                case t.TRIANGLES:
                    n.triangles += r * (e / 3);
                    break;
                case t.LINES:
                    n.lines += r * (e / 2);
                    break;
                case t.LINE_STRIP:
                    n.lines += r * (e - 1);
                    break;
                case t.LINE_LOOP:
                    n.lines += r * e;
                    break;
                case t.POINTS:
                    n.points += r * e;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", i);
                    break
                }
            }
            function r() {
                n.calls = 0,
                n.triangles = 0,
                n.points = 0,
                n.lines = 0
            }
            return {
                memory: e,
                render: n,
                programs: null,
                autoReset: !0,
                reset: r,
                update: i
            }
        }
        function nl(t, e, n) {
            const i = new WeakMap
              , r = new Qn;
            function a(a, o, s) {
                const c = a.morphTargetInfluences
                  , l = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color
                  , u = void 0 !== l ? l.length : 0;
                let h = i.get(o);
                if (void 0 === h || h.count !== u) {
                    void 0 !== h && h.texture.dispose();
                    const d = void 0 !== o.morphAttributes.position
                      , p = void 0 !== o.morphAttributes.normal
                      , f = void 0 !== o.morphAttributes.color
                      , m = o.morphAttributes.position || []
                      , g = o.morphAttributes.normal || []
                      , v = o.morphAttributes.color || [];
                    let _ = 0;
                    !0 === d && (_ = 1),
                    !0 === p && (_ = 2),
                    !0 === f && (_ = 3);
                    let y = o.attributes.position.count * _
                      , x = 1;
                    y > e.maxTextureSize && (x = Math.ceil(y / e.maxTextureSize),
                    y = e.maxTextureSize);
                    const M = new Float32Array(y * x * 4 * u)
                      , b = new ni(M,y,x,u);
                    b.type = At,
                    b.needsUpdate = !0;
                    const S = 4 * _;
                    for (let T = 0; T < u; T++) {
                        const w = m[T]
                          , A = g[T]
                          , R = v[T]
                          , C = y * x * 4 * T;
                        for (let P = 0; P < w.count; P++) {
                            const L = P * S;
                            !0 === d && (r.fromBufferAttribute(w, P),
                            M[C + L + 0] = r.x,
                            M[C + L + 1] = r.y,
                            M[C + L + 2] = r.z,
                            M[C + L + 3] = 0),
                            !0 === p && (r.fromBufferAttribute(A, P),
                            M[C + L + 4] = r.x,
                            M[C + L + 5] = r.y,
                            M[C + L + 6] = r.z,
                            M[C + L + 7] = 0),
                            !0 === f && (r.fromBufferAttribute(R, P),
                            M[C + L + 8] = r.x,
                            M[C + L + 9] = r.y,
                            M[C + L + 10] = r.z,
                            M[C + L + 11] = 4 === R.itemSize ? r.w : 1)
                        }
                    }
                    function E() {
                        b.dispose(),
                        i.delete(o),
                        o.removeEventListener("dispose", E)
                    }
                    h = {
                        count: u,
                        texture: b,
                        size: new Ln(y,x)
                    },
                    i.set(o, h),
                    o.addEventListener("dispose", E)
                }
                if (!0 === a.isInstancedMesh && null !== a.morphTexture)
                    s.getUniforms().setValue(t, "morphTexture", a.morphTexture, n);
                else {
                    let I = 0;
                    for (let D = 0; D < c.length; D++)
                        I += c[D];
                    const U = o.morphTargetsRelative ? 1 : 1 - I;
                    s.getUniforms().setValue(t, "morphTargetBaseInfluence", U),
                    s.getUniforms().setValue(t, "morphTargetInfluences", c)
                }
                s.getUniforms().setValue(t, "morphTargetsTexture", h.texture, n),
                s.getUniforms().setValue(t, "morphTargetsTextureSize", h.size)
            }
            return {
                update: a
            }
        }
        function il(t, e, n, i) {
            let r = new WeakMap;
            function a(a) {
                const o = i.render.frame
                  , c = a.geometry
                  , l = e.get(a, c);
                if (r.get(l) !== o && (e.update(l),
                r.set(l, o)),
                a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
                r.get(a) !== o && (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
                null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER),
                r.set(a, o))),
                a.isSkinnedMesh) {
                    const t = a.skeleton;
                    r.get(t) !== o && (t.update(),
                    r.set(t, o))
                }
                return l
            }
            function o() {
                r = new WeakMap
            }
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: a,
                dispose: o
            }
        }
        class rl extends Jn {
            constructor(t, e, n, i, r, a, o, s, c, l) {
                if (l = void 0 !== l ? l : Bt,
                l !== Bt && l !== kt)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Bt && (n = wt),
                void 0 === n && l === kt && (n = Lt),
                super(null, i, r, a, o, s, l, n, c),
                this.isDepthTexture = !0,
                this.image = {
                    width: t,
                    height: e
                },
                this.magFilter = void 0 !== o ? o : mt,
                this.minFilter = void 0 !== s ? s : mt,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(t) {
                return super.copy(t),
                this.compareFunction = t.compareFunction,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction),
                e
            }
        }
        const al = new Jn
          , ol = new rl(1,1);
        ol.compareFunction = qe;
        const sl = new ni
          , cl = new ii
          , ll = new wa
          , ul = []
          , hl = []
          , dl = new Float32Array(16)
          , pl = new Float32Array(9)
          , fl = new Float32Array(4);
        function ml(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0)
                return t;
            const r = e * n;
            let a = ul[r];
            if (void 0 === a && (a = new Float32Array(r),
            ul[r] = a),
            0 !== e) {
                i.toArray(a, 0);
                for (let i = 1, r = 0; i !== e; ++i)
                    r += n,
                    t[i].toArray(a, r)
            }
            return a
        }
        function gl(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function vl(t, e) {
            for (let n = 0, i = e.length; n < i; n++)
                t[n] = e[n]
        }
        function _l(t, e) {
            let n = hl[e];
            void 0 === n && (n = new Int32Array(e),
            hl[e] = n);
            for (let i = 0; i !== e; ++i)
                n[i] = t.allocateTextureUnit();
            return n
        }
        function yl(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
            n[0] = e)
        }
        function xl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (gl(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                vl(n, e)
            }
        }
        function Ml(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                n[0] = e.r,
                n[1] = e.g,
                n[2] = e.b);
            else {
                if (gl(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                vl(n, e)
            }
        }
        function bl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (gl(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                vl(n, e)
            }
        }
        function Sl(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (gl(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                vl(n, e)
            } else {
                if (gl(n, i))
                    return;
                fl.set(i),
                t.uniformMatrix2fv(this.addr, !1, fl),
                vl(n, i)
            }
        }
        function El(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (gl(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                vl(n, e)
            } else {
                if (gl(n, i))
                    return;
                pl.set(i),
                t.uniformMatrix3fv(this.addr, !1, pl),
                vl(n, i)
            }
        }
        function Tl(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (gl(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                vl(n, e)
            } else {
                if (gl(n, i))
                    return;
                dl.set(i),
                t.uniformMatrix4fv(this.addr, !1, dl),
                vl(n, i)
            }
        }
        function wl(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
            n[0] = e)
        }
        function Al(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (gl(n, e))
                    return;
                t.uniform2iv(this.addr, e),
                vl(n, e)
            }
        }
        function Rl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else {
                if (gl(n, e))
                    return;
                t.uniform3iv(this.addr, e),
                vl(n, e)
            }
        }
        function Cl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (gl(n, e))
                    return;
                t.uniform4iv(this.addr, e),
                vl(n, e)
            }
        }
        function Pl(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
            n[0] = e)
        }
        function Ll(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (gl(n, e))
                    return;
                t.uniform2uiv(this.addr, e),
                vl(n, e)
            }
        }
        function Il(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else {
                if (gl(n, e))
                    return;
                t.uniform3uiv(this.addr, e),
                vl(n, e)
            }
        }
        function Ul(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (gl(n, e))
                    return;
                t.uniform4uiv(this.addr, e),
                vl(n, e)
            }
        }
        function Dl(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r);
            const a = this.type === t.SAMPLER_2D_SHADOW ? ol : al;
            n.setTexture2D(e || a, r)
        }
        function Nl(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(e || cl, r)
        }
        function Ol(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTextureCube(e || ll, r)
        }
        function Fl(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(e || sl, r)
        }
        function Bl(t) {
            switch (t) {
            case 5126:
                return yl;
            case 35664:
                return xl;
            case 35665:
                return Ml;
            case 35666:
                return bl;
            case 35674:
                return Sl;
            case 35675:
                return El;
            case 35676:
                return Tl;
            case 5124:
            case 35670:
                return wl;
            case 35667:
            case 35671:
                return Al;
            case 35668:
            case 35672:
                return Rl;
            case 35669:
            case 35673:
                return Cl;
            case 5125:
                return Pl;
            case 36294:
                return Ll;
            case 36295:
                return Il;
            case 36296:
                return Ul;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Dl;
            case 35679:
            case 36299:
            case 36307:
                return Nl;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Ol;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Fl
            }
        }
        function kl(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function zl(t, e) {
            const n = ml(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function Vl(t, e) {
            const n = ml(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function Hl(t, e) {
            const n = ml(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function Gl(t, e) {
            const n = ml(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function jl(t, e) {
            const n = ml(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function Wl(t, e) {
            const n = ml(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function Xl(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function ql(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function $l(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function Yl(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function Kl(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function Zl(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function Jl(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function Ql(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function tu(t, e, n) {
            const i = this.cache
              , r = e.length
              , a = _l(n, r);
            gl(i, a) || (t.uniform1iv(this.addr, a),
            vl(i, a));
            for (let o = 0; o !== r; ++o)
                n.setTexture2D(e[o] || al, a[o])
        }
        function eu(t, e, n) {
            const i = this.cache
              , r = e.length
              , a = _l(n, r);
            gl(i, a) || (t.uniform1iv(this.addr, a),
            vl(i, a));
            for (let o = 0; o !== r; ++o)
                n.setTexture3D(e[o] || cl, a[o])
        }
        function nu(t, e, n) {
            const i = this.cache
              , r = e.length
              , a = _l(n, r);
            gl(i, a) || (t.uniform1iv(this.addr, a),
            vl(i, a));
            for (let o = 0; o !== r; ++o)
                n.setTextureCube(e[o] || ll, a[o])
        }
        function iu(t, e, n) {
            const i = this.cache
              , r = e.length
              , a = _l(n, r);
            gl(i, a) || (t.uniform1iv(this.addr, a),
            vl(i, a));
            for (let o = 0; o !== r; ++o)
                n.setTexture2DArray(e[o] || sl, a[o])
        }
        function ru(t) {
            switch (t) {
            case 5126:
                return kl;
            case 35664:
                return zl;
            case 35665:
                return Vl;
            case 35666:
                return Hl;
            case 35674:
                return Gl;
            case 35675:
                return jl;
            case 35676:
                return Wl;
            case 5124:
            case 35670:
                return Xl;
            case 35667:
            case 35671:
                return ql;
            case 35668:
            case 35672:
                return $l;
            case 35669:
            case 35673:
                return Yl;
            case 5125:
                return Kl;
            case 36294:
                return Zl;
            case 36295:
                return Jl;
            case 36296:
                return Ql;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return tu;
            case 35679:
            case 36299:
            case 36307:
                return eu;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return nu;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return iu
            }
        }
        class au {
            constructor(t, e, n) {
                this.id = t,
                this.addr = n,
                this.cache = [],
                this.type = e.type,
                this.setValue = Bl(e.type)
            }
        }
        class ou {
            constructor(t, e, n) {
                this.id = t,
                this.addr = n,
                this.cache = [],
                this.type = e.type,
                this.size = e.size,
                this.setValue = ru(e.type)
            }
        }
        class su {
            constructor(t) {
                this.id = t,
                this.seq = [],
                this.map = {}
            }
            setValue(t, e, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(t, e[a.id], n)
                }
            }
        }
        const cu = /(\w+)(\])?(\[|\.)?/g;
        function lu(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function uu(t, e, n) {
            const i = t.name
              , r = i.length;
            cu.lastIndex = 0;
            while (1) {
                const a = cu.exec(i)
                  , o = cu.lastIndex;
                let s = a[1];
                const c = "]" === a[2]
                  , l = a[3];
                if (c && (s |= 0),
                void 0 === l || "[" === l && o + 2 === r) {
                    lu(n, void 0 === l ? new au(s,t,e) : new ou(s,t,e));
                    break
                }
                {
                    const t = n.map;
                    let e = t[s];
                    void 0 === e && (e = new su(s),
                    lu(n, e)),
                    n = e
                }
            }
        }
        class hu {
            constructor(t, e) {
                this.seq = [],
                this.map = {};
                const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i)
                      , r = t.getUniformLocation(e, n.name);
                    uu(n, r, this)
                }
            }
            setValue(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }
            setOptional(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            static upload(t, e, n, i) {
                for (let r = 0, a = e.length; r !== a; ++r) {
                    const a = e[r]
                      , o = n[a.id];
                    !1 !== o.needsUpdate && a.setValue(t, o.value, i)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        }
        function du(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n),
            t.compileShader(i),
            i
        }
        const pu = 37297;
        let fu = 0;
        function mu(t, e) {
            const n = t.split("\n")
              , i = []
              , r = Math.max(e - 6, 0)
              , a = Math.min(e + 6, n.length);
            for (let o = r; o < a; o++) {
                const t = o + 1;
                i.push(`${t === e ? ">" : " "} ${t}: ${n[o]}`)
            }
            return i.join("\n")
        }
        function gu(t) {
            const e = Gn.getPrimaries(Gn.workingColorSpace)
              , n = Gn.getPrimaries(t);
            let i;
            switch (e === n ? i = "" : e === Ve && n === ze ? i = "LinearDisplayP3ToLinearSRGB" : e === ze && n === Ve && (i = "LinearSRGBToLinearDisplayP3"),
            t) {
            case Ne:
            case Fe:
                return [i, "LinearTransferOETF"];
            case De:
            case Oe:
                return [i, "sRGBTransferOETF"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space:", t),
                [i, "LinearTransferOETF"]
            }
        }
        function vu(t, e, n) {
            const i = t.getShaderParameter(e, t.COMPILE_STATUS)
              , r = t.getShaderInfoLog(e).trim();
            if (i && "" === r)
                return "";
            const a = /ERROR: 0:(\d+)/.exec(r);
            if (a) {
                const i = parseInt(a[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + mu(t.getShaderSource(e), i)
            }
            return r
        }
        function _u(t, e) {
            const n = gu(e);
            return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }
        function yu(t, e) {
            let n;
            switch (e) {
            case Q:
                n = "Linear";
                break;
            case tt:
                n = "Reinhard";
                break;
            case et:
                n = "OptimizedCineon";
                break;
            case nt:
                n = "ACESFilmic";
                break;
            case rt:
                n = "AgX";
                break;
            case at:
                n = "Neutral";
                break;
            case it:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function xu(t) {
            const e = [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""];
            return e.filter(Su).join("\n")
        }
        function Mu(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i)
            }
            return e.join("\n")
        }
        function bu(t, e) {
            const n = {}
              , i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
            for (let r = 0; r < i; r++) {
                const i = t.getActiveAttrib(e, r)
                  , a = i.name;
                let o = 1;
                i.type === t.FLOAT_MAT2 && (o = 2),
                i.type === t.FLOAT_MAT3 && (o = 3),
                i.type === t.FLOAT_MAT4 && (o = 4),
                n[a] = {
                    type: i.type,
                    location: t.getAttribLocation(e, a),
                    locationSize: o
                }
            }
            return n
        }
        function Su(t) {
            return "" !== t
        }
        function Eu(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function Tu(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const wu = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Au(t) {
            return t.replace(wu, Cu)
        }
        const Ru = new Map;
        function Cu(t, e) {
            let n = _c[e];
            if (void 0 === n) {
                const t = Ru.get(e);
                if (void 0 === t)
                    throw new Error("Can not resolve #include <" + e + ">");
                n = _c[t],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
            }
            return Au(n)
        }
        const Pu = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Lu(t) {
            return t.replace(Pu, Iu)
        }
        function Iu(t, e, n, i) {
            let r = "";
            for (let a = parseInt(e); a < parseInt(n); a++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
            return r
        }
        function Uu(t) {
            let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function Du(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"),
            e
        }
        function Nu(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
                switch (t.envMapMode) {
                case st:
                case ct:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case ht:
                    e = "ENVMAP_TYPE_CUBE_UV";
                    break
                }
            return e
        }
        function Ou(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
                switch (t.envMapMode) {
                case ct:
                    e = "ENVMAP_MODE_REFRACTION";
                    break
                }
            return e
        }
        function Fu(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
                switch (t.combine) {
                case Y:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case K:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case Z:
                    e = "ENVMAP_BLENDING_ADD";
                    break
                }
            return e
        }
        function Bu(t) {
            const e = t.envMapCubeUVHeight;
            if (null === e)
                return null;
            const n = Math.log2(e) - 2
              , i = 1 / e
              , r = 1 / (3 * Math.max(Math.pow(2, n), 112));
            return {
                texelWidth: r,
                texelHeight: i,
                maxMip: n
            }
        }
        function ku(t, e, n, i) {
            const r = t.getContext()
              , a = n.defines;
            let o = n.vertexShader
              , s = n.fragmentShader;
            const c = Du(n)
              , l = Nu(n)
              , u = Ou(n)
              , h = Fu(n)
              , d = Bu(n)
              , p = xu(n)
              , f = Mu(a)
              , m = r.createProgram();
            let g, v, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Su).join("\n"),
            g.length > 0 && (g += "\n"),
            v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Su).join("\n"),
            v.length > 0 && (v += "\n")) : (g = [Uu(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Su).join("\n"),
            v = [Uu(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== J ? "#define TONE_MAPPING" : "", n.toneMapping !== J ? _c["tonemapping_pars_fragment"] : "", n.toneMapping !== J ? yu("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", _c["colorspace_pars_fragment"], _u("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Su).join("\n")),
            o = Au(o),
            o = Eu(o, n),
            o = Tu(o, n),
            s = Au(s),
            s = Eu(s, n),
            s = Tu(s, n),
            o = Lu(o),
            s = Lu(s),
            !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n",
            g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            v = ["#define varying in", n.glslVersion === Qe ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Qe ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const y = _ + g + o
              , x = _ + v + s
              , M = du(r, r.VERTEX_SHADER, y)
              , b = du(r, r.FRAGMENT_SHADER, x);
            function S(e) {
                if (t.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(m).trim()
                      , i = r.getShaderInfoLog(M).trim()
                      , a = r.getShaderInfoLog(b).trim();
                    let o = !0
                      , s = !0;
                    if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                        if (o = !1,
                        "function" === typeof t.debug.onShaderError)
                            t.debug.onShaderError(r, m, M, b);
                        else {
                            const t = vu(r, M, "vertex")
                              , i = vu(r, b, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + n + "\n" + t + "\n" + i)
                        }
                    else
                        "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== a || (s = !1);
                    s && (e.diagnostics = {
                        runnable: o,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: g
                        },
                        fragmentShader: {
                            log: a,
                            prefix: v
                        }
                    })
                }
                r.deleteShader(M),
                r.deleteShader(b),
                E = new hu(r,m),
                T = bu(r, m)
            }
            let E, T;
            r.attachShader(m, M),
            r.attachShader(m, b),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            this.getUniforms = function() {
                return void 0 === E && S(this),
                E
            }
            ,
            this.getAttributes = function() {
                return void 0 === T && S(this),
                T
            }
            ;
            let w = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === w && (w = r.getProgramParameter(m, pu)),
                w
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = fu++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = M,
            this.fragmentShader = b,
            this
        }
        let zu = 0;
        class Vu {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader
                  , n = t.fragmentShader
                  , i = this._getShaderStage(e)
                  , r = this._getShaderStage(n)
                  , a = this._getShaderCacheForMaterial(t);
                return !1 === a.has(i) && (a.add(i),
                i.usedTimes++),
                !1 === a.has(r) && (a.add(r),
                r.usedTimes++),
                this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const n of e)
                    n.usedTimes--,
                    0 === n.usedTimes && this.shaderCache.delete(n.code);
                return this.materialCache.delete(t),
                this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set,
                e.set(t, n)),
                n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new Hu(t),
                e.set(t, n)),
                n
            }
        }
        class Hu {
            constructor(t) {
                this.id = zu++,
                this.code = t,
                this.usedTimes = 0
            }
        }
        function Gu(t, e, n, i, r, a, o) {
            const s = new Xi
              , c = new Vu
              , l = new Set
              , u = []
              , h = r.logarithmicDepthBuffer
              , d = r.vertexTextures;
            let m = r.precision;
            const v = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function _(t) {
                return l.add(t),
                0 === t ? "uv" : `uv${t}`
            }
            function y(a, s, u, y, x) {
                const M = y.fog
                  , b = x.geometry
                  , S = a.isMeshStandardMaterial ? y.environment : null
                  , E = (a.isMeshStandardMaterial ? n : e).get(a.envMap || S)
                  , T = E && E.mapping === ht ? E.image.height : null
                  , w = v[a.type];
                null !== a.precision && (m = r.getMaxPrecision(a.precision),
                m !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead."));
                const A = b.morphAttributes.position || b.morphAttributes.normal || b.morphAttributes.color
                  , R = void 0 !== A ? A.length : 0;
                let C, P, L, I, U = 0;
                if (void 0 !== b.morphAttributes.position && (U = 1),
                void 0 !== b.morphAttributes.normal && (U = 2),
                void 0 !== b.morphAttributes.color && (U = 3),
                w) {
                    const t = xc[w];
                    C = t.vertexShader,
                    P = t.fragmentShader
                } else
                    C = a.vertexShader,
                    P = a.fragmentShader,
                    c.update(a),
                    L = c.getVertexShaderID(a),
                    I = c.getFragmentShaderID(a);
                const D = t.getRenderTarget()
                  , N = !0 === x.isInstancedMesh
                  , O = !0 === x.isBatchedMesh
                  , F = !!a.map
                  , B = !!a.matcap
                  , k = !!E
                  , z = !!a.aoMap
                  , V = !!a.lightMap
                  , H = !!a.bumpMap
                  , G = !!a.normalMap
                  , j = !!a.displacementMap
                  , W = !!a.emissiveMap
                  , X = !!a.metalnessMap
                  , q = !!a.roughnessMap
                  , $ = a.anisotropy > 0
                  , Y = a.clearcoat > 0
                  , K = a.dispersion > 0
                  , Z = a.iridescence > 0
                  , Q = a.sheen > 0
                  , tt = a.transmission > 0
                  , et = $ && !!a.anisotropyMap
                  , nt = Y && !!a.clearcoatMap
                  , it = Y && !!a.clearcoatNormalMap
                  , rt = Y && !!a.clearcoatRoughnessMap
                  , at = Z && !!a.iridescenceMap
                  , ot = Z && !!a.iridescenceThicknessMap
                  , st = Q && !!a.sheenColorMap
                  , ct = Q && !!a.sheenRoughnessMap
                  , lt = !!a.specularMap
                  , ut = !!a.specularColorMap
                  , dt = !!a.specularIntensityMap
                  , pt = tt && !!a.transmissionMap
                  , ft = tt && !!a.thicknessMap
                  , mt = !!a.gradientMap
                  , gt = !!a.alphaMap
                  , vt = a.alphaTest > 0
                  , _t = !!a.alphaHash
                  , yt = !!a.extensions;
                let xt = J;
                a.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (xt = t.toneMapping));
                const Mt = {
                    shaderID: w,
                    shaderType: a.type,
                    shaderName: a.name,
                    vertexShader: C,
                    fragmentShader: P,
                    defines: a.defines,
                    customVertexShaderID: L,
                    customFragmentShaderID: I,
                    isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                    glslVersion: a.glslVersion,
                    precision: m,
                    batching: O,
                    instancing: N,
                    instancingColor: N && null !== x.instanceColor,
                    instancingMorph: N && null !== x.morphTexture,
                    supportsVertexTextures: d,
                    outputColorSpace: null === D ? t.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : Ne,
                    alphaToCoverage: !!a.alphaToCoverage,
                    map: F,
                    matcap: B,
                    envMap: k,
                    envMapMode: k && E.mapping,
                    envMapCubeUVHeight: T,
                    aoMap: z,
                    lightMap: V,
                    bumpMap: H,
                    normalMap: G,
                    displacementMap: d && j,
                    emissiveMap: W,
                    normalMapObjectSpace: G && a.normalMapType === Ie,
                    normalMapTangentSpace: G && a.normalMapType === Le,
                    metalnessMap: X,
                    roughnessMap: q,
                    anisotropy: $,
                    anisotropyMap: et,
                    clearcoat: Y,
                    clearcoatMap: nt,
                    clearcoatNormalMap: it,
                    clearcoatRoughnessMap: rt,
                    dispersion: K,
                    iridescence: Z,
                    iridescenceMap: at,
                    iridescenceThicknessMap: ot,
                    sheen: Q,
                    sheenColorMap: st,
                    sheenRoughnessMap: ct,
                    specularMap: lt,
                    specularColorMap: ut,
                    specularIntensityMap: dt,
                    transmission: tt,
                    transmissionMap: pt,
                    thicknessMap: ft,
                    gradientMap: mt,
                    opaque: !1 === a.transparent && a.blending === g && !1 === a.alphaToCoverage,
                    alphaMap: gt,
                    alphaTest: vt,
                    alphaHash: _t,
                    combine: a.combine,
                    mapUv: F && _(a.map.channel),
                    aoMapUv: z && _(a.aoMap.channel),
                    lightMapUv: V && _(a.lightMap.channel),
                    bumpMapUv: H && _(a.bumpMap.channel),
                    normalMapUv: G && _(a.normalMap.channel),
                    displacementMapUv: j && _(a.displacementMap.channel),
                    emissiveMapUv: W && _(a.emissiveMap.channel),
                    metalnessMapUv: X && _(a.metalnessMap.channel),
                    roughnessMapUv: q && _(a.roughnessMap.channel),
                    anisotropyMapUv: et && _(a.anisotropyMap.channel),
                    clearcoatMapUv: nt && _(a.clearcoatMap.channel),
                    clearcoatNormalMapUv: it && _(a.clearcoatNormalMap.channel),
                    clearcoatRoughnessMapUv: rt && _(a.clearcoatRoughnessMap.channel),
                    iridescenceMapUv: at && _(a.iridescenceMap.channel),
                    iridescenceThicknessMapUv: ot && _(a.iridescenceThicknessMap.channel),
                    sheenColorMapUv: st && _(a.sheenColorMap.channel),
                    sheenRoughnessMapUv: ct && _(a.sheenRoughnessMap.channel),
                    specularMapUv: lt && _(a.specularMap.channel),
                    specularColorMapUv: ut && _(a.specularColorMap.channel),
                    specularIntensityMapUv: dt && _(a.specularIntensityMap.channel),
                    transmissionMapUv: pt && _(a.transmissionMap.channel),
                    thicknessMapUv: ft && _(a.thicknessMap.channel),
                    alphaMapUv: gt && _(a.alphaMap.channel),
                    vertexTangents: !!b.attributes.tangent && (G || $),
                    vertexColors: a.vertexColors,
                    vertexAlphas: !0 === a.vertexColors && !!b.attributes.color && 4 === b.attributes.color.itemSize,
                    pointsUvs: !0 === x.isPoints && !!b.attributes.uv && (F || gt),
                    fog: !!M,
                    useFog: !0 === a.fog,
                    fogExp2: !!M && M.isFogExp2,
                    flatShading: !0 === a.flatShading,
                    sizeAttenuation: !0 === a.sizeAttenuation,
                    logarithmicDepthBuffer: h,
                    skinning: !0 === x.isSkinnedMesh,
                    morphTargets: void 0 !== b.morphAttributes.position,
                    morphNormals: void 0 !== b.morphAttributes.normal,
                    morphColors: void 0 !== b.morphAttributes.color,
                    morphTargetsCount: R,
                    morphTextureStride: U,
                    numDirLights: s.directional.length,
                    numPointLights: s.point.length,
                    numSpotLights: s.spot.length,
                    numSpotLightMaps: s.spotLightMap.length,
                    numRectAreaLights: s.rectArea.length,
                    numHemiLights: s.hemi.length,
                    numDirLightShadows: s.directionalShadowMap.length,
                    numPointLightShadows: s.pointShadowMap.length,
                    numSpotLightShadows: s.spotShadowMap.length,
                    numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                    numLightProbes: s.numLightProbes,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    dithering: a.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: xt,
                    useLegacyLights: t._useLegacyLights,
                    decodeVideoTexture: F && !0 === a.map.isVideoTexture && Gn.getTransfer(a.map.colorSpace) === ke,
                    premultipliedAlpha: a.premultipliedAlpha,
                    doubleSided: a.side === f,
                    flipSided: a.side === p,
                    useDepthPacking: a.depthPacking >= 0,
                    depthPacking: a.depthPacking || 0,
                    index0AttributeName: a.index0AttributeName,
                    extensionClipCullDistance: yt && !0 === a.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                    extensionMultiDraw: yt && !0 === a.extensions.multiDraw && i.has("WEBGL_multi_draw"),
                    rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                    customProgramCacheKey: a.customProgramCacheKey()
                };
                return Mt.vertexUv1s = l.has(1),
                Mt.vertexUv2s = l.has(2),
                Mt.vertexUv3s = l.has(3),
                l.clear(),
                Mt
            }
            function x(e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID),
                n.push(e.customFragmentShaderID)),
                void 0 !== e.defines)
                    for (const t in e.defines)
                        n.push(t),
                        n.push(e.defines[t]);
                return !1 === e.isRawShaderMaterial && (M(n, e),
                b(n, e),
                n.push(t.outputColorSpace)),
                n.push(e.customProgramCacheKey),
                n.join()
            }
            function M(t, e) {
                t.push(e.precision),
                t.push(e.outputColorSpace),
                t.push(e.envMapMode),
                t.push(e.envMapCubeUVHeight),
                t.push(e.mapUv),
                t.push(e.alphaMapUv),
                t.push(e.lightMapUv),
                t.push(e.aoMapUv),
                t.push(e.bumpMapUv),
                t.push(e.normalMapUv),
                t.push(e.displacementMapUv),
                t.push(e.emissiveMapUv),
                t.push(e.metalnessMapUv),
                t.push(e.roughnessMapUv),
                t.push(e.anisotropyMapUv),
                t.push(e.clearcoatMapUv),
                t.push(e.clearcoatNormalMapUv),
                t.push(e.clearcoatRoughnessMapUv),
                t.push(e.iridescenceMapUv),
                t.push(e.iridescenceThicknessMapUv),
                t.push(e.sheenColorMapUv),
                t.push(e.sheenRoughnessMapUv),
                t.push(e.specularMapUv),
                t.push(e.specularColorMapUv),
                t.push(e.specularIntensityMapUv),
                t.push(e.transmissionMapUv),
                t.push(e.thicknessMapUv),
                t.push(e.combine),
                t.push(e.fogExp2),
                t.push(e.sizeAttenuation),
                t.push(e.morphTargetsCount),
                t.push(e.morphAttributeCount),
                t.push(e.numDirLights),
                t.push(e.numPointLights),
                t.push(e.numSpotLights),
                t.push(e.numSpotLightMaps),
                t.push(e.numHemiLights),
                t.push(e.numRectAreaLights),
                t.push(e.numDirLightShadows),
                t.push(e.numPointLightShadows),
                t.push(e.numSpotLightShadows),
                t.push(e.numSpotLightShadowsWithMaps),
                t.push(e.numLightProbes),
                t.push(e.shadowMapType),
                t.push(e.toneMapping),
                t.push(e.numClippingPlanes),
                t.push(e.numClipIntersection),
                t.push(e.depthPacking)
            }
            function b(t, e) {
                s.disableAll(),
                e.supportsVertexTextures && s.enable(0),
                e.instancing && s.enable(1),
                e.instancingColor && s.enable(2),
                e.instancingMorph && s.enable(3),
                e.matcap && s.enable(4),
                e.envMap && s.enable(5),
                e.normalMapObjectSpace && s.enable(6),
                e.normalMapTangentSpace && s.enable(7),
                e.clearcoat && s.enable(8),
                e.iridescence && s.enable(9),
                e.alphaTest && s.enable(10),
                e.vertexColors && s.enable(11),
                e.vertexAlphas && s.enable(12),
                e.vertexUv1s && s.enable(13),
                e.vertexUv2s && s.enable(14),
                e.vertexUv3s && s.enable(15),
                e.vertexTangents && s.enable(16),
                e.anisotropy && s.enable(17),
                e.alphaHash && s.enable(18),
                e.batching && s.enable(19),
                e.dispersion && s.enable(20),
                t.push(s.mask),
                s.disableAll(),
                e.fog && s.enable(0),
                e.useFog && s.enable(1),
                e.flatShading && s.enable(2),
                e.logarithmicDepthBuffer && s.enable(3),
                e.skinning && s.enable(4),
                e.morphTargets && s.enable(5),
                e.morphNormals && s.enable(6),
                e.morphColors && s.enable(7),
                e.premultipliedAlpha && s.enable(8),
                e.shadowMapEnabled && s.enable(9),
                e.useLegacyLights && s.enable(10),
                e.doubleSided && s.enable(11),
                e.flipSided && s.enable(12),
                e.useDepthPacking && s.enable(13),
                e.dithering && s.enable(14),
                e.transmission && s.enable(15),
                e.sheen && s.enable(16),
                e.opaque && s.enable(17),
                e.pointsUvs && s.enable(18),
                e.decodeVideoTexture && s.enable(19),
                e.alphaToCoverage && s.enable(20),
                t.push(s.mask)
            }
            function S(t) {
                const e = v[t.type];
                let n;
                if (e) {
                    const t = xc[e];
                    n = fa.clone(t.uniforms)
                } else
                    n = t.uniforms;
                return n
            }
            function E(e, n) {
                let i;
                for (let t = 0, r = u.length; t < r; t++) {
                    const e = u[t];
                    if (e.cacheKey === n) {
                        i = e,
                        ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new ku(t,n,e,a),
                u.push(i)),
                i
            }
            function T(t) {
                if (0 === --t.usedTimes) {
                    const e = u.indexOf(t);
                    u[e] = u[u.length - 1],
                    u.pop(),
                    t.destroy()
                }
            }
            function w(t) {
                c.remove(t)
            }
            function A() {
                c.dispose()
            }
            return {
                getParameters: y,
                getProgramCacheKey: x,
                getUniforms: S,
                acquireProgram: E,
                releaseProgram: T,
                releaseShaderCache: w,
                programs: u,
                dispose: A
            }
        }
        function ju() {
            let t = new WeakMap;
            function e(e) {
                let n = t.get(e);
                return void 0 === n && (n = {},
                t.set(e, n)),
                n
            }
            function n(e) {
                t.delete(e)
            }
            function i(e, n, i) {
                t.get(e)[n] = i
            }
            function r() {
                t = new WeakMap
            }
            return {
                get: e,
                remove: n,
                update: i,
                dispose: r
            }
        }
        function Wu(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function Xu(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function qu() {
            const t = [];
            let e = 0;
            const n = []
              , i = []
              , r = [];
            function a() {
                e = 0,
                n.length = 0,
                i.length = 0,
                r.length = 0
            }
            function o(n, i, r, a, o, s) {
                let c = t[e];
                return void 0 === c ? (c = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: a,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: s
                },
                t[e] = c) : (c.id = n.id,
                c.object = n,
                c.geometry = i,
                c.material = r,
                c.groupOrder = a,
                c.renderOrder = n.renderOrder,
                c.z = o,
                c.group = s),
                e++,
                c
            }
            function s(t, e, a, s, c, l) {
                const u = o(t, e, a, s, c, l);
                a.transmission > 0 ? i.push(u) : !0 === a.transparent ? r.push(u) : n.push(u)
            }
            function c(t, e, a, s, c, l) {
                const u = o(t, e, a, s, c, l);
                a.transmission > 0 ? i.unshift(u) : !0 === a.transparent ? r.unshift(u) : n.unshift(u)
            }
            function l(t, e) {
                n.length > 1 && n.sort(t || Wu),
                i.length > 1 && i.sort(e || Xu),
                r.length > 1 && r.sort(e || Xu)
            }
            function u() {
                for (let n = e, i = t.length; n < i; n++) {
                    const e = t[n];
                    if (null === e.id)
                        break;
                    e.id = null,
                    e.object = null,
                    e.geometry = null,
                    e.material = null,
                    e.group = null
                }
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: a,
                push: s,
                unshift: c,
                finish: u,
                sort: l
            }
        }
        function $u() {
            let t = new WeakMap;
            function e(e, n) {
                const i = t.get(e);
                let r;
                return void 0 === i ? (r = new qu,
                t.set(e, [r])) : n >= i.length ? (r = new qu,
                i.push(r)) : r = i[n],
                r
            }
            function n() {
                t = new WeakMap
            }
            return {
                get: e,
                dispose: n
            }
        }
        function Yu() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new ai,
                            color: new Er
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new ai,
                            direction: new ai,
                            color: new Er,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new ai,
                            color: new Er,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new ai,
                            skyColor: new Er,
                            groundColor: new Er
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Er,
                            position: new ai,
                            halfWidth: new ai,
                            halfHeight: new ai
                        };
                        break
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        function Ku() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ln
                        };
                        break;
                    case "SpotLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ln
                        };
                        break;
                    case "PointLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ln,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        let Zu = 0;
        function Ju(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }
        function Qu(t) {
            const e = new Yu
              , n = Ku()
              , i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let l = 0; l < 9; l++)
                i.probe.push(new ai);
            const r = new ai
              , a = new Ni
              , o = new Ni;
            function s(r, a) {
                let o = 0
                  , s = 0
                  , c = 0;
                for (let t = 0; t < 9; t++)
                    i.probe[t].set(0, 0, 0);
                let l = 0
                  , u = 0
                  , h = 0
                  , d = 0
                  , p = 0
                  , f = 0
                  , m = 0
                  , g = 0
                  , v = 0
                  , _ = 0
                  , y = 0;
                r.sort(Ju);
                const x = !0 === a ? Math.PI : 1;
                for (let t = 0, b = r.length; t < b; t++) {
                    const a = r[t]
                      , M = a.color
                      , b = a.intensity
                      , S = a.distance
                      , E = a.shadow && a.shadow.map ? a.shadow.map.texture : null;
                    if (a.isAmbientLight)
                        o += M.r * b * x,
                        s += M.g * b * x,
                        c += M.b * b * x;
                    else if (a.isLightProbe) {
                        for (let t = 0; t < 9; t++)
                            i.probe[t].addScaledVector(a.sh.coefficients[t], b);
                        y++
                    } else if (a.isDirectionalLight) {
                        const t = e.get(a);
                        if (t.color.copy(a.color).multiplyScalar(a.intensity * x),
                        a.castShadow) {
                            const t = a.shadow
                              , e = n.get(a);
                            e.shadowBias = t.bias,
                            e.shadowNormalBias = t.normalBias,
                            e.shadowRadius = t.radius,
                            e.shadowMapSize = t.mapSize,
                            i.directionalShadow[l] = e,
                            i.directionalShadowMap[l] = E,
                            i.directionalShadowMatrix[l] = a.shadow.matrix,
                            f++
                        }
                        i.directional[l] = t,
                        l++
                    } else if (a.isSpotLight) {
                        const t = e.get(a);
                        t.position.setFromMatrixPosition(a.matrixWorld),
                        t.color.copy(M).multiplyScalar(b * x),
                        t.distance = S,
                        t.coneCos = Math.cos(a.angle),
                        t.penumbraCos = Math.cos(a.angle * (1 - a.penumbra)),
                        t.decay = a.decay,
                        i.spot[h] = t;
                        const r = a.shadow;
                        if (a.map && (i.spotLightMap[v] = a.map,
                        v++,
                        r.updateMatrices(a),
                        a.castShadow && _++),
                        i.spotLightMatrix[h] = r.matrix,
                        a.castShadow) {
                            const t = n.get(a);
                            t.shadowBias = r.bias,
                            t.shadowNormalBias = r.normalBias,
                            t.shadowRadius = r.radius,
                            t.shadowMapSize = r.mapSize,
                            i.spotShadow[h] = t,
                            i.spotShadowMap[h] = E,
                            g++
                        }
                        h++
                    } else if (a.isRectAreaLight) {
                        const t = e.get(a);
                        t.color.copy(M).multiplyScalar(b),
                        t.halfWidth.set(.5 * a.width, 0, 0),
                        t.halfHeight.set(0, .5 * a.height, 0),
                        i.rectArea[d] = t,
                        d++
                    } else if (a.isPointLight) {
                        const t = e.get(a);
                        if (t.color.copy(a.color).multiplyScalar(a.intensity * x),
                        t.distance = a.distance,
                        t.decay = a.decay,
                        a.castShadow) {
                            const t = a.shadow
                              , e = n.get(a);
                            e.shadowBias = t.bias,
                            e.shadowNormalBias = t.normalBias,
                            e.shadowRadius = t.radius,
                            e.shadowMapSize = t.mapSize,
                            e.shadowCameraNear = t.camera.near,
                            e.shadowCameraFar = t.camera.far,
                            i.pointShadow[u] = e,
                            i.pointShadowMap[u] = E,
                            i.pointShadowMatrix[u] = a.shadow.matrix,
                            m++
                        }
                        i.point[u] = t,
                        u++
                    } else if (a.isHemisphereLight) {
                        const t = e.get(a);
                        t.skyColor.copy(a.color).multiplyScalar(b * x),
                        t.groundColor.copy(a.groundColor).multiplyScalar(b * x),
                        i.hemi[p] = t,
                        p++
                    }
                }
                d > 0 && (!0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = yc.LTC_FLOAT_1,
                i.rectAreaLTC2 = yc.LTC_FLOAT_2) : (i.rectAreaLTC1 = yc.LTC_HALF_1,
                i.rectAreaLTC2 = yc.LTC_HALF_2)),
                i.ambient[0] = o,
                i.ambient[1] = s,
                i.ambient[2] = c;
                const M = i.hash;
                M.directionalLength === l && M.pointLength === u && M.spotLength === h && M.rectAreaLength === d && M.hemiLength === p && M.numDirectionalShadows === f && M.numPointShadows === m && M.numSpotShadows === g && M.numSpotMaps === v && M.numLightProbes === y || (i.directional.length = l,
                i.spot.length = h,
                i.rectArea.length = d,
                i.point.length = u,
                i.hemi.length = p,
                i.directionalShadow.length = f,
                i.directionalShadowMap.length = f,
                i.pointShadow.length = m,
                i.pointShadowMap.length = m,
                i.spotShadow.length = g,
                i.spotShadowMap.length = g,
                i.directionalShadowMatrix.length = f,
                i.pointShadowMatrix.length = m,
                i.spotLightMatrix.length = g + v - _,
                i.spotLightMap.length = v,
                i.numSpotLightShadowsWithMaps = _,
                i.numLightProbes = y,
                M.directionalLength = l,
                M.pointLength = u,
                M.spotLength = h,
                M.rectAreaLength = d,
                M.hemiLength = p,
                M.numDirectionalShadows = f,
                M.numPointShadows = m,
                M.numSpotShadows = g,
                M.numSpotMaps = v,
                M.numLightProbes = y,
                i.version = Zu++)
            }
            function c(t, e) {
                let n = 0
                  , s = 0
                  , c = 0
                  , l = 0
                  , u = 0;
                const h = e.matrixWorldInverse;
                for (let d = 0, p = t.length; d < p; d++) {
                    const e = t[d];
                    if (e.isDirectionalLight) {
                        const t = i.directional[n];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                        r.setFromMatrixPosition(e.target.matrixWorld),
                        t.direction.sub(r),
                        t.direction.transformDirection(h),
                        n++
                    } else if (e.isSpotLight) {
                        const t = i.spot[c];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                        t.position.applyMatrix4(h),
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                        r.setFromMatrixPosition(e.target.matrixWorld),
                        t.direction.sub(r),
                        t.direction.transformDirection(h),
                        c++
                    } else if (e.isRectAreaLight) {
                        const t = i.rectArea[l];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                        t.position.applyMatrix4(h),
                        o.identity(),
                        a.copy(e.matrixWorld),
                        a.premultiply(h),
                        o.extractRotation(a),
                        t.halfWidth.set(.5 * e.width, 0, 0),
                        t.halfHeight.set(0, .5 * e.height, 0),
                        t.halfWidth.applyMatrix4(o),
                        t.halfHeight.applyMatrix4(o),
                        l++
                    } else if (e.isPointLight) {
                        const t = i.point[s];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                        t.position.applyMatrix4(h),
                        s++
                    } else if (e.isHemisphereLight) {
                        const t = i.hemi[u];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                        t.direction.transformDirection(h),
                        u++
                    }
                }
            }
            return {
                setup: s,
                setupView: c,
                state: i
            }
        }
        function th(t) {
            const e = new Qu(t)
              , n = []
              , i = [];
            function r(t) {
                l.camera = t,
                n.length = 0,
                i.length = 0
            }
            function a(t) {
                n.push(t)
            }
            function o(t) {
                i.push(t)
            }
            function s(t) {
                e.setup(n, t)
            }
            function c(t) {
                e.setupView(n, t)
            }
            const l = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: e,
                transmissionRenderTarget: {}
            };
            return {
                init: r,
                state: l,
                setupLights: s,
                setupLightsView: c,
                pushLight: a,
                pushShadow: o
            }
        }
        function eh(t) {
            let e = new WeakMap;
            function n(n, i=0) {
                const r = e.get(n);
                let a;
                return void 0 === r ? (a = new th(t),
                e.set(n, [a])) : i >= r.length ? (a = new th(t),
                r.push(a)) : a = r[i],
                a
            }
            function i() {
                e = new WeakMap
            }
            return {
                get: n,
                dispose: i
            }
        }
        class nh extends Ar {
            constructor(t) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = Ce,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        class ih extends Ar {
            constructor(t) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        const rh = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"
          , ah = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
        function oh(t, e, n) {
            let i = new Da;
            const r = new Ln
              , a = new Ln
              , o = new Qn
              , s = new nh({
                depthPacking: Pe
            })
              , c = new ih
              , u = {}
              , g = n.maxTextureSize
              , v = {
                [d]: p,
                [p]: d,
                [f]: f
            }
              , _ = new va({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Ln
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: rh,
                fragmentShader: ah
            })
              , y = _.clone();
            y.defines.HORIZONTAL_PASS = 1;
            const x = new Hr;
            x.setAttribute("position", new Lr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const M = new oa(x,_)
              , b = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = l;
            let S = this.type;
            function E(n, i) {
                const a = e.update(M);
                _.defines.VSM_SAMPLES !== n.blurSamples && (_.defines.VSM_SAMPLES = n.blurSamples,
                y.defines.VSM_SAMPLES = n.blurSamples,
                _.needsUpdate = !0,
                y.needsUpdate = !0),
                null === n.mapPass && (n.mapPass = new ei(r.x,r.y)),
                _.uniforms.shadow_pass.value = n.map.texture,
                _.uniforms.resolution.value = n.mapSize,
                _.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.mapPass),
                t.clear(),
                t.renderBufferDirect(i, null, a, _, M, null),
                y.uniforms.shadow_pass.value = n.mapPass.texture,
                y.uniforms.resolution.value = n.mapSize,
                y.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.map),
                t.clear(),
                t.renderBufferDirect(i, null, a, y, M, null)
            }
            function T(e, n, i, r) {
                let a = null;
                const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== o)
                    a = o;
                else if (a = !0 === i.isPointLight ? c : s,
                t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const t = a.uuid
                      , e = n.uuid;
                    let i = u[t];
                    void 0 === i && (i = {},
                    u[t] = i);
                    let r = i[e];
                    void 0 === r && (r = a.clone(),
                    i[e] = r,
                    n.addEventListener("dispose", A)),
                    a = r
                }
                if (a.visible = n.visible,
                a.wireframe = n.wireframe,
                a.side = r === h ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : v[n.side],
                a.alphaMap = n.alphaMap,
                a.alphaTest = n.alphaTest,
                a.map = n.map,
                a.clipShadows = n.clipShadows,
                a.clippingPlanes = n.clippingPlanes,
                a.clipIntersection = n.clipIntersection,
                a.displacementMap = n.displacementMap,
                a.displacementScale = n.displacementScale,
                a.displacementBias = n.displacementBias,
                a.wireframeLinewidth = n.wireframeLinewidth,
                a.linewidth = n.linewidth,
                !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial) {
                    const e = t.properties.get(a);
                    e.light = i
                }
                return a
            }
            function w(n, r, a, o, s) {
                if (!1 === n.visible)
                    return;
                const c = n.layers.test(r.layers);
                if (c && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === h) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n)
                      , c = n.material;
                    if (Array.isArray(c)) {
                        const e = i.groups;
                        for (let l = 0, u = e.length; l < u; l++) {
                            const u = e[l]
                              , h = c[u.materialIndex];
                            if (h && h.visible) {
                                const e = T(n, h, o, s);
                                n.onBeforeShadow(t, n, r, a, i, e, u),
                                t.renderBufferDirect(a, null, i, e, n, u),
                                n.onAfterShadow(t, n, r, a, i, e, u)
                            }
                        }
                    } else if (c.visible) {
                        const e = T(n, c, o, s);
                        n.onBeforeShadow(t, n, r, a, i, e, null),
                        t.renderBufferDirect(a, null, i, e, n, null),
                        n.onAfterShadow(t, n, r, a, i, e, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++)
                    w(l[t], r, a, o, s)
            }
            function A(t) {
                const e = t.target;
                e.removeEventListener("dispose", A);
                for (const n in u) {
                    const e = u[n]
                      , i = t.target.uuid;
                    if (i in e) {
                        const t = e[i];
                        t.dispose(),
                        delete e[i]
                    }
                }
            }
            this.render = function(e, n, s) {
                if (!1 === b.enabled)
                    return;
                if (!1 === b.autoUpdate && !1 === b.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const c = t.getRenderTarget()
                  , l = t.getActiveCubeFace()
                  , u = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(m),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                const p = S !== h && this.type === h
                  , f = S === h && this.type !== h;
                for (let m = 0, v = e.length; m < v; m++) {
                    const c = e[m]
                      , l = c.shadow;
                    if (void 0 === l) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === l.autoUpdate && !1 === l.needsUpdate)
                        continue;
                    r.copy(l.mapSize);
                    const u = l.getFrameExtents();
                    if (r.multiply(u),
                    a.copy(l.mapSize),
                    (r.x > g || r.y > g) && (r.x > g && (a.x = Math.floor(g / u.x),
                    r.x = a.x * u.x,
                    l.mapSize.x = a.x),
                    r.y > g && (a.y = Math.floor(g / u.y),
                    r.y = a.y * u.y,
                    l.mapSize.y = a.y)),
                    null === l.map || !0 === p || !0 === f) {
                        const t = this.type !== h ? {
                            minFilter: mt,
                            magFilter: mt
                        } : {};
                        null !== l.map && l.map.dispose(),
                        l.map = new ei(r.x,r.y,t),
                        l.map.texture.name = c.name + ".shadowMap",
                        l.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(l.map),
                    t.clear();
                    const v = l.getViewportCount();
                    for (let t = 0; t < v; t++) {
                        const e = l.getViewport(t);
                        o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w),
                        d.viewport(o),
                        l.updateMatrices(c, t),
                        i = l.getFrustum(),
                        w(n, s, l.camera, c, this.type)
                    }
                    !0 !== l.isPointLightShadow && this.type === h && E(l, s),
                    l.needsUpdate = !1
                }
                S = this.type,
                b.needsUpdate = !1,
                t.setRenderTarget(c, l, u)
            }
        }
        function sh(t) {
            function e() {
                let e = !1;
                const n = new Qn;
                let i = null;
                const r = new Qn(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, a, o, s) {
                        !0 === s && (e *= o,
                        i *= o,
                        a *= o),
                        n.set(e, i, a, o),
                        !1 === r.equals(n) && (t.clearColor(e, i, a, o),
                        r.copy(n))
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
            function n() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null;
                return {
                    setTest: function(e) {
                        e ? At(t.DEPTH_TEST) : Rt(t.DEPTH_TEST)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i),
                        n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            switch (e) {
                            case V:
                                t.depthFunc(t.NEVER);
                                break;
                            case H:
                                t.depthFunc(t.ALWAYS);
                                break;
                            case G:
                                t.depthFunc(t.LESS);
                                break;
                            case j:
                                t.depthFunc(t.LEQUAL);
                                break;
                            case W:
                                t.depthFunc(t.EQUAL);
                                break;
                            case X:
                                t.depthFunc(t.GEQUAL);
                                break;
                            case q:
                                t.depthFunc(t.GREATER);
                                break;
                            case $:
                                t.depthFunc(t.NOTEQUAL);
                                break;
                            default:
                                t.depthFunc(t.LEQUAL)
                            }
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                        r = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null
                    }
                }
            }
            function i() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null
                  , a = null
                  , o = null
                  , s = null
                  , c = null
                  , l = null;
                return {
                    setTest: function(n) {
                        e || (n ? At(t.STENCIL_TEST) : Rt(t.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(e, n, o) {
                        i === e && r === n && a === o || (t.stencilFunc(e, n, o),
                        i = e,
                        r = n,
                        a = o)
                    },
                    setOp: function(e, n, i) {
                        o === e && s === n && c === i || (t.stencilOp(e, n, i),
                        o = e,
                        s = n,
                        c = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        l !== e && (t.clearStencil(e),
                        l = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        o = null,
                        s = null,
                        c = null,
                        l = null
                    }
                }
            }
            const r = new e
              , a = new n
              , l = new i
              , u = new WeakMap
              , h = new WeakMap;
            let d = {}
              , Y = {}
              , K = new WeakMap
              , Z = []
              , J = null
              , Q = !1
              , tt = null
              , et = null
              , nt = null
              , it = null
              , rt = null
              , at = null
              , ot = null
              , st = new Er(0,0,0)
              , ct = 0
              , lt = !1
              , ut = null
              , ht = null
              , dt = null
              , pt = null
              , ft = null;
            const mt = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let gt = !1
              , vt = 0;
            const _t = t.getParameter(t.VERSION);
            -1 !== _t.indexOf("WebGL") ? (vt = parseFloat(/^WebGL (\d)/.exec(_t)[1]),
            gt = vt >= 1) : -1 !== _t.indexOf("OpenGL ES") && (vt = parseFloat(/^OpenGL ES (\d)/.exec(_t)[1]),
            gt = vt >= 2);
            let yt = null
              , xt = {};
            const Mt = t.getParameter(t.SCISSOR_BOX)
              , bt = t.getParameter(t.VIEWPORT)
              , St = (new Qn).fromArray(Mt)
              , Et = (new Qn).fromArray(bt);
            function Tt(e, n, i, r) {
                const a = new Uint8Array(4)
                  , o = t.createTexture();
                t.bindTexture(e, o),
                t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let s = 0; s < i; s++)
                    e === t.TEXTURE_3D || e === t.TEXTURE_2D_ARRAY ? t.texImage3D(n, 0, t.RGBA, 1, 1, r, 0, t.RGBA, t.UNSIGNED_BYTE, a) : t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a);
                return o
            }
            const wt = {};
            function At(e) {
                !0 !== d[e] && (t.enable(e),
                d[e] = !0)
            }
            function Rt(e) {
                !1 !== d[e] && (t.disable(e),
                d[e] = !1)
            }
            function Ct(e, n) {
                return Y[e] !== n && (t.bindFramebuffer(e, n),
                Y[e] = n,
                e === t.DRAW_FRAMEBUFFER && (Y[t.FRAMEBUFFER] = n),
                e === t.FRAMEBUFFER && (Y[t.DRAW_FRAMEBUFFER] = n),
                !0)
            }
            function Pt(e, n) {
                let i = Z
                  , r = !1;
                if (e) {
                    i = K.get(n),
                    void 0 === i && (i = [],
                    K.set(n, i));
                    const a = e.textures;
                    if (i.length !== a.length || i[0] !== t.COLOR_ATTACHMENT0) {
                        for (let e = 0, n = a.length; e < n; e++)
                            i[e] = t.COLOR_ATTACHMENT0 + e;
                        i.length = a.length,
                        r = !0
                    }
                } else
                    i[0] !== t.BACK && (i[0] = t.BACK,
                    r = !0);
                r && t.drawBuffers(i)
            }
            function Lt(e) {
                return J !== e && (t.useProgram(e),
                J = e,
                !0)
            }
            wt[t.TEXTURE_2D] = Tt(t.TEXTURE_2D, t.TEXTURE_2D, 1),
            wt[t.TEXTURE_CUBE_MAP] = Tt(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            wt[t.TEXTURE_2D_ARRAY] = Tt(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1),
            wt[t.TEXTURE_3D] = Tt(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1),
            r.setClear(0, 0, 0, 1),
            a.setClear(1),
            l.setClear(0),
            At(t.DEPTH_TEST),
            a.setFunc(j),
            Ot(!1),
            Ft(s),
            At(t.CULL_FACE),
            Dt(m);
            const It = {
                [M]: t.FUNC_ADD,
                [b]: t.FUNC_SUBTRACT,
                [S]: t.FUNC_REVERSE_SUBTRACT
            };
            It[E] = t.MIN,
            It[T] = t.MAX;
            const Ut = {
                [w]: t.ZERO,
                [A]: t.ONE,
                [R]: t.SRC_COLOR,
                [P]: t.SRC_ALPHA,
                [O]: t.SRC_ALPHA_SATURATE,
                [D]: t.DST_COLOR,
                [I]: t.DST_ALPHA,
                [C]: t.ONE_MINUS_SRC_COLOR,
                [L]: t.ONE_MINUS_SRC_ALPHA,
                [N]: t.ONE_MINUS_DST_COLOR,
                [U]: t.ONE_MINUS_DST_ALPHA,
                [F]: t.CONSTANT_COLOR,
                [B]: t.ONE_MINUS_CONSTANT_COLOR,
                [k]: t.CONSTANT_ALPHA,
                [z]: t.ONE_MINUS_CONSTANT_ALPHA
            };
            function Dt(e, n, i, r, a, o, s, c, l, u) {
                if (e !== m) {
                    if (!1 === Q && (At(t.BLEND),
                    Q = !0),
                    e === x)
                        a = a || n,
                        o = o || i,
                        s = s || r,
                        n === et && a === rt || (t.blendEquationSeparate(It[n], It[a]),
                        et = n,
                        rt = a),
                        i === nt && r === it && o === at && s === ot || (t.blendFuncSeparate(Ut[i], Ut[r], Ut[o], Ut[s]),
                        nt = i,
                        it = r,
                        at = o,
                        ot = s),
                        !1 !== c.equals(st) && l === ct || (t.blendColor(c.r, c.g, c.b, l),
                        st.copy(c),
                        ct = l),
                        tt = e,
                        lt = !1;
                    else if (e !== tt || u !== lt) {
                        if (et === M && rt === M || (t.blendEquation(t.FUNC_ADD),
                        et = M,
                        rt = M),
                        u)
                            switch (e) {
                            case g:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case v:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case _:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case y:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e);
                                break
                            }
                        else
                            switch (e) {
                            case g:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case v:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case _:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case y:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e);
                                break
                            }
                        nt = null,
                        it = null,
                        at = null,
                        ot = null,
                        st.set(0, 0, 0),
                        ct = 0,
                        tt = e,
                        lt = u
                    }
                } else
                    !0 === Q && (Rt(t.BLEND),
                    Q = !1)
            }
            function Nt(e, n) {
                e.side === f ? Rt(t.CULL_FACE) : At(t.CULL_FACE);
                let i = e.side === p;
                n && (i = !i),
                Ot(i),
                e.blending === g && !1 === e.transparent ? Dt(m) : Dt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha),
                a.setFunc(e.depthFunc),
                a.setTest(e.depthTest),
                a.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
                const o = e.stencilWrite;
                l.setTest(o),
                o && (l.setMask(e.stencilWriteMask),
                l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                kt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage ? At(t.SAMPLE_ALPHA_TO_COVERAGE) : Rt(t.SAMPLE_ALPHA_TO_COVERAGE)
            }
            function Ot(e) {
                ut !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                ut = e)
            }
            function Ft(e) {
                e !== o ? (At(t.CULL_FACE),
                e !== ht && (e === s ? t.cullFace(t.BACK) : e === c ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Rt(t.CULL_FACE),
                ht = e
            }
            function Bt(e) {
                e !== dt && (gt && t.lineWidth(e),
                dt = e)
            }
            function kt(e, n, i) {
                e ? (At(t.POLYGON_OFFSET_FILL),
                pt === n && ft === i || (t.polygonOffset(n, i),
                pt = n,
                ft = i)) : Rt(t.POLYGON_OFFSET_FILL)
            }
            function zt(e) {
                e ? At(t.SCISSOR_TEST) : Rt(t.SCISSOR_TEST)
            }
            function Vt(e) {
                void 0 === e && (e = t.TEXTURE0 + mt - 1),
                yt !== e && (t.activeTexture(e),
                yt = e)
            }
            function Ht(e, n, i) {
                void 0 === i && (i = null === yt ? t.TEXTURE0 + mt - 1 : yt);
                let r = xt[i];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                },
                xt[i] = r),
                r.type === e && r.texture === n || (yt !== i && (t.activeTexture(i),
                yt = i),
                t.bindTexture(e, n || wt[e]),
                r.type = e,
                r.texture = n)
            }
            function Gt() {
                const e = xt[yt];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                e.type = void 0,
                e.texture = void 0)
            }
            function jt() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Wt() {
                try {
                    t.compressedTexImage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Xt() {
                try {
                    t.texSubImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function qt() {
                try {
                    t.texSubImage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function $t() {
                try {
                    t.compressedTexSubImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Yt() {
                try {
                    t.compressedTexSubImage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Kt() {
                try {
                    t.texStorage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Zt() {
                try {
                    t.texStorage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Jt() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Qt() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function te(e) {
                !1 === St.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                St.copy(e))
            }
            function ee(e) {
                !1 === Et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                Et.copy(e))
            }
            function ne(e, n) {
                let i = h.get(n);
                void 0 === i && (i = new WeakMap,
                h.set(n, i));
                let r = i.get(e);
                void 0 === r && (r = t.getUniformBlockIndex(n, e.name),
                i.set(e, r))
            }
            function ie(e, n) {
                const i = h.get(n)
                  , r = i.get(e);
                u.get(n) !== r && (t.uniformBlockBinding(n, r, e.__bindingPointIndex),
                u.set(n, r))
            }
            function re() {
                t.disable(t.BLEND),
                t.disable(t.CULL_FACE),
                t.disable(t.DEPTH_TEST),
                t.disable(t.POLYGON_OFFSET_FILL),
                t.disable(t.SCISSOR_TEST),
                t.disable(t.STENCIL_TEST),
                t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ONE, t.ZERO),
                t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                t.blendColor(0, 0, 0, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(t.LESS),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(t.ALWAYS, 0, 4294967295),
                t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                t.clearStencil(0),
                t.cullFace(t.BACK),
                t.frontFace(t.CCW),
                t.polygonOffset(0, 0),
                t.activeTexture(t.TEXTURE0),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                d = {},
                yt = null,
                xt = {},
                Y = {},
                K = new WeakMap,
                Z = [],
                J = null,
                Q = !1,
                tt = null,
                et = null,
                nt = null,
                it = null,
                rt = null,
                at = null,
                ot = null,
                st = new Er(0,0,0),
                ct = 0,
                lt = !1,
                ut = null,
                ht = null,
                dt = null,
                pt = null,
                ft = null,
                St.set(0, 0, t.canvas.width, t.canvas.height),
                Et.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                a.reset(),
                l.reset()
            }
            return {
                buffers: {
                    color: r,
                    depth: a,
                    stencil: l
                },
                enable: At,
                disable: Rt,
                bindFramebuffer: Ct,
                drawBuffers: Pt,
                useProgram: Lt,
                setBlending: Dt,
                setMaterial: Nt,
                setFlipSided: Ot,
                setCullFace: Ft,
                setLineWidth: Bt,
                setPolygonOffset: kt,
                setScissorTest: zt,
                activeTexture: Vt,
                bindTexture: Ht,
                unbindTexture: Gt,
                compressedTexImage2D: jt,
                compressedTexImage3D: Wt,
                texImage2D: Jt,
                texImage3D: Qt,
                updateUBOMapping: ne,
                uniformBlockBinding: ie,
                texStorage2D: Kt,
                texStorage3D: Zt,
                texSubImage2D: Xt,
                texSubImage3D: qt,
                compressedTexSubImage2D: $t,
                compressedTexSubImage3D: Yt,
                scissor: te,
                viewport: ee,
                reset: re
            }
        }
        function ch(t, e, n, i, r, a, o) {
            const s = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
              , c = "undefined" !== typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , l = new Ln
              , u = new WeakMap;
            let h;
            const d = new WeakMap;
            let p = !1;
            try {
                p = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (et) {}
            function f(t, e) {
                return p ? new OffscreenCanvas(t,e) : Nn("canvas")
            }
            function m(t, e, n) {
                let i = 1;
                const r = tt(t);
                if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)),
                i < 1) {
                    if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap || "undefined" !== typeof VideoFrame && t instanceof VideoFrame) {
                        const n = Math.floor(i * r.width)
                          , a = Math.floor(i * r.height);
                        void 0 === h && (h = f(n, a));
                        const o = e ? f(n, a) : h;
                        o.width = n,
                        o.height = a;
                        const s = o.getContext("2d");
                        return s.drawImage(t, 0, 0, n, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + n + "x" + a + ")."),
                        o
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."),
                    t
                }
                return t
            }
            function g(t) {
                return t.generateMipmaps && t.minFilter !== mt && t.minFilter !== _t
            }
            function v(e) {
                t.generateMipmap(e)
            }
            function _(n, i, r, a, o=!1) {
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let s = i;
                if (i === t.RED && (r === t.FLOAT && (s = t.R32F),
                r === t.HALF_FLOAT && (s = t.R16F),
                r === t.UNSIGNED_BYTE && (s = t.R8)),
                i === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (s = t.R8UI),
                r === t.UNSIGNED_SHORT && (s = t.R16UI),
                r === t.UNSIGNED_INT && (s = t.R32UI),
                r === t.BYTE && (s = t.R8I),
                r === t.SHORT && (s = t.R16I),
                r === t.INT && (s = t.R32I)),
                i === t.RG && (r === t.FLOAT && (s = t.RG32F),
                r === t.HALF_FLOAT && (s = t.RG16F),
                r === t.UNSIGNED_BYTE && (s = t.RG8)),
                i === t.RG_INTEGER && (r === t.UNSIGNED_BYTE && (s = t.RG8UI),
                r === t.UNSIGNED_SHORT && (s = t.RG16UI),
                r === t.UNSIGNED_INT && (s = t.RG32UI),
                r === t.BYTE && (s = t.RG8I),
                r === t.SHORT && (s = t.RG16I),
                r === t.INT && (s = t.RG32I)),
                i === t.RGB && r === t.UNSIGNED_INT_5_9_9_9_REV && (s = t.RGB9_E5),
                i === t.RGBA) {
                    const e = o ? Be : Gn.getTransfer(a);
                    r === t.FLOAT && (s = t.RGBA32F),
                    r === t.HALF_FLOAT && (s = t.RGBA16F),
                    r === t.UNSIGNED_BYTE && (s = e === ke ? t.SRGB8_ALPHA8 : t.RGBA8),
                    r === t.UNSIGNED_SHORT_4_4_4_4 && (s = t.RGBA4),
                    r === t.UNSIGNED_SHORT_5_5_5_1 && (s = t.RGB5_A1)
                }
                return s !== t.R16F && s !== t.R32F && s !== t.RG16F && s !== t.RG32F && s !== t.RGBA16F && s !== t.RGBA32F || e.get("EXT_color_buffer_float"),
                s
            }
            function y(t, e) {
                return !0 === g(t) || t.isFramebufferTexture && t.minFilter !== mt && t.minFilter !== _t ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }
            function x(t) {
                const e = t.target;
                e.removeEventListener("dispose", x),
                b(e),
                e.isVideoTexture && u.delete(e)
            }
            function M(t) {
                const e = t.target;
                e.removeEventListener("dispose", M),
                E(e)
            }
            function b(t) {
                const e = i.get(t);
                if (void 0 === e.__webglInit)
                    return;
                const n = t.source
                  , r = d.get(n);
                if (r) {
                    const i = r[e.__cacheKey];
                    i.usedTimes--,
                    0 === i.usedTimes && S(t),
                    0 === Object.keys(r).length && d.delete(n)
                }
                i.remove(t)
            }
            function S(e) {
                const n = i.get(e);
                t.deleteTexture(n.__webglTexture);
                const r = e.source
                  , a = d.get(r);
                delete a[n.__cacheKey],
                o.memory.textures--
            }
            function E(e) {
                const n = i.get(e);
                if (e.depthTexture && e.depthTexture.dispose(),
                e.isWebGLCubeRenderTarget)
                    for (let i = 0; i < 6; i++) {
                        if (Array.isArray(n.__webglFramebuffer[i]))
                            for (let e = 0; e < n.__webglFramebuffer[i].length; e++)
                                t.deleteFramebuffer(n.__webglFramebuffer[i][e]);
                        else
                            t.deleteFramebuffer(n.__webglFramebuffer[i]);
                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[i])
                    }
                else {
                    if (Array.isArray(n.__webglFramebuffer))
                        for (let e = 0; e < n.__webglFramebuffer.length; e++)
                            t.deleteFramebuffer(n.__webglFramebuffer[e]);
                    else
                        t.deleteFramebuffer(n.__webglFramebuffer);
                    if (n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer),
                    n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                    n.__webglColorRenderbuffer)
                        for (let e = 0; e < n.__webglColorRenderbuffer.length; e++)
                            n.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);
                    n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                }
                const r = e.textures;
                for (let a = 0, s = r.length; a < s; a++) {
                    const e = i.get(r[a]);
                    e.__webglTexture && (t.deleteTexture(e.__webglTexture),
                    o.memory.textures--),
                    i.remove(r[a])
                }
                i.remove(e)
            }
            let T = 0;
            function w() {
                T = 0
            }
            function A() {
                const t = T;
                return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures),
                T += 1,
                t
            }
            function R(t) {
                const e = [];
                return e.push(t.wrapS),
                e.push(t.wrapT),
                e.push(t.wrapR || 0),
                e.push(t.magFilter),
                e.push(t.minFilter),
                e.push(t.anisotropy),
                e.push(t.internalFormat),
                e.push(t.format),
                e.push(t.type),
                e.push(t.generateMipmaps),
                e.push(t.premultiplyAlpha),
                e.push(t.flipY),
                e.push(t.unpackAlignment),
                e.push(t.colorSpace),
                e.join()
            }
            function C(e, r) {
                const a = i.get(e);
                if (e.isVideoTexture && J(e),
                !1 === e.isRenderTargetTexture && e.version > 0 && a.__version !== e.version) {
                    const t = e.image;
                    if (null === t)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== t.complete)
                            return void B(a, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(t.TEXTURE_2D, a.__webglTexture, t.TEXTURE0 + r)
            }
            function P(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? B(a, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, a.__webglTexture, t.TEXTURE0 + r)
            }
            function L(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? B(a, e, r) : n.bindTexture(t.TEXTURE_3D, a.__webglTexture, t.TEXTURE0 + r)
            }
            function I(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? k(a, e, r) : n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture, t.TEXTURE0 + r)
            }
            const U = {
                [dt]: t.REPEAT,
                [pt]: t.CLAMP_TO_EDGE,
                [ft]: t.MIRRORED_REPEAT
            }
              , D = {
                [mt]: t.NEAREST,
                [gt]: t.NEAREST_MIPMAP_NEAREST,
                [vt]: t.NEAREST_MIPMAP_LINEAR,
                [_t]: t.LINEAR,
                [yt]: t.LINEAR_MIPMAP_NEAREST,
                [xt]: t.LINEAR_MIPMAP_LINEAR
            }
              , N = {
                [je]: t.NEVER,
                [Ze]: t.ALWAYS,
                [We]: t.LESS,
                [qe]: t.LEQUAL,
                [Xe]: t.EQUAL,
                [Ke]: t.GEQUAL,
                [$e]: t.GREATER,
                [Ye]: t.NOTEQUAL
            };
            function O(n, a) {
                if (a.type !== At || !1 !== e.has("OES_texture_float_linear") || a.magFilter !== _t && a.magFilter !== yt && a.magFilter !== vt && a.magFilter !== xt && a.minFilter !== _t && a.minFilter !== yt && a.minFilter !== vt && a.minFilter !== xt || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                t.texParameteri(n, t.TEXTURE_WRAP_S, U[a.wrapS]),
                t.texParameteri(n, t.TEXTURE_WRAP_T, U[a.wrapT]),
                n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, U[a.wrapR]),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, D[a.magFilter]),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, D[a.minFilter]),
                a.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
                t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, N[a.compareFunction])),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    if (a.magFilter === mt)
                        return;
                    if (a.minFilter !== vt && a.minFilter !== xt)
                        return;
                    if (a.type === At && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (a.anisotropy > 1 || i.get(a).__currentAnisotropy) {
                        const o = e.get("EXT_texture_filter_anisotropic");
                        t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                        i.get(a).__currentAnisotropy = a.anisotropy
                    }
                }
            }
            function F(e, n) {
                let i = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0,
                n.addEventListener("dispose", x));
                const r = n.source;
                let a = d.get(r);
                void 0 === a && (a = {},
                d.set(r, a));
                const s = R(n);
                if (s !== e.__cacheKey) {
                    void 0 === a[s] && (a[s] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    },
                    o.memory.textures++,
                    i = !0),
                    a[s].usedTimes++;
                    const r = a[e.__cacheKey];
                    void 0 !== r && (a[e.__cacheKey].usedTimes--,
                    0 === r.usedTimes && S(n)),
                    e.__cacheKey = s,
                    e.__webglTexture = a[s].texture
                }
                return i
            }
            function B(e, o, s) {
                let c = t.TEXTURE_2D;
                (o.isDataArrayTexture || o.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY),
                o.isData3DTexture && (c = t.TEXTURE_3D);
                const l = F(e, o)
                  , u = o.source;
                n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + s);
                const h = i.get(u);
                if (u.version !== h.__version || !0 === l) {
                    n.activeTexture(t.TEXTURE0 + s);
                    const e = Gn.getPrimaries(Gn.workingColorSpace)
                      , i = o.colorSpace === Ue ? null : Gn.getPrimaries(o.colorSpace)
                      , d = o.colorSpace === Ue || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY),
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha),
                    t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment),
                    t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                    let p = m(o.image, !1, r.maxTextureSize);
                    p = Q(o, p);
                    const f = a.convert(o.format, o.colorSpace)
                      , x = a.convert(o.type);
                    let M, b = _(o.internalFormat, f, x, o.colorSpace, o.isVideoTexture);
                    O(c, o);
                    const S = o.mipmaps
                      , E = !0 !== o.isVideoTexture
                      , T = void 0 === h.__version || !0 === l
                      , w = u.dataReady
                      , A = y(o, p);
                    if (o.isDepthTexture)
                        b = t.DEPTH_COMPONENT16,
                        o.type === At ? b = t.DEPTH_COMPONENT32F : o.type === wt ? b = t.DEPTH_COMPONENT24 : o.type === Lt && (b = t.DEPTH24_STENCIL8),
                        T && (E ? n.texStorage2D(t.TEXTURE_2D, 1, b, p.width, p.height) : n.texImage2D(t.TEXTURE_2D, 0, b, p.width, p.height, 0, f, x, null));
                    else if (o.isDataTexture)
                        if (S.length > 0) {
                            E && T && n.texStorage2D(t.TEXTURE_2D, A, b, S[0].width, S[0].height);
                            for (let e = 0, i = S.length; e < i; e++)
                                M = S[e],
                                E ? w && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, f, x, M.data) : n.texImage2D(t.TEXTURE_2D, e, b, M.width, M.height, 0, f, x, M.data);
                            o.generateMipmaps = !1
                        } else
                            E ? (T && n.texStorage2D(t.TEXTURE_2D, A, b, p.width, p.height),
                            w && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, x, p.data)) : n.texImage2D(t.TEXTURE_2D, 0, b, p.width, p.height, 0, f, x, p.data);
                    else if (o.isCompressedTexture)
                        if (o.isCompressedArrayTexture) {
                            E && T && n.texStorage3D(t.TEXTURE_2D_ARRAY, A, b, S[0].width, S[0].height, p.depth);
                            for (let e = 0, i = S.length; e < i; e++)
                                M = S[e],
                                o.format !== Nt ? null !== f ? E ? w && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, M.width, M.height, p.depth, f, M.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, b, M.width, M.height, p.depth, 0, M.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? w && n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, M.width, M.height, p.depth, f, x, M.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, b, M.width, M.height, p.depth, 0, f, x, M.data)
                        } else {
                            E && T && n.texStorage2D(t.TEXTURE_2D, A, b, S[0].width, S[0].height);
                            for (let e = 0, i = S.length; e < i; e++)
                                M = S[e],
                                o.format !== Nt ? null !== f ? E ? w && n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, f, M.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, b, M.width, M.height, 0, M.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? w && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, M.width, M.height, f, x, M.data) : n.texImage2D(t.TEXTURE_2D, e, b, M.width, M.height, 0, f, x, M.data)
                        }
                    else if (o.isDataArrayTexture)
                        E ? (T && n.texStorage3D(t.TEXTURE_2D_ARRAY, A, b, p.width, p.height, p.depth),
                        w && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, x, p.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, b, p.width, p.height, p.depth, 0, f, x, p.data);
                    else if (o.isData3DTexture)
                        E ? (T && n.texStorage3D(t.TEXTURE_3D, A, b, p.width, p.height, p.depth),
                        w && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, x, p.data)) : n.texImage3D(t.TEXTURE_3D, 0, b, p.width, p.height, p.depth, 0, f, x, p.data);
                    else if (o.isFramebufferTexture) {
                        if (T)
                            if (E)
                                n.texStorage2D(t.TEXTURE_2D, A, b, p.width, p.height);
                            else {
                                let e = p.width
                                  , i = p.height;
                                for (let r = 0; r < A; r++)
                                    n.texImage2D(t.TEXTURE_2D, r, b, e, i, 0, f, x, null),
                                    e >>= 1,
                                    i >>= 1
                            }
                    } else if (S.length > 0) {
                        if (E && T) {
                            const e = tt(S[0]);
                            n.texStorage2D(t.TEXTURE_2D, A, b, e.width, e.height)
                        }
                        for (let e = 0, i = S.length; e < i; e++)
                            M = S[e],
                            E ? w && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, x, M) : n.texImage2D(t.TEXTURE_2D, e, b, f, x, M);
                        o.generateMipmaps = !1
                    } else if (E) {
                        if (T) {
                            const e = tt(p);
                            n.texStorage2D(t.TEXTURE_2D, A, b, e.width, e.height)
                        }
                        w && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, x, p)
                    } else
                        n.texImage2D(t.TEXTURE_2D, 0, b, f, x, p);
                    g(o) && v(c),
                    h.__version = u.version,
                    o.onUpdate && o.onUpdate(o)
                }
                e.__version = o.version
            }
            function k(e, o, s) {
                if (6 !== o.image.length)
                    return;
                const c = F(e, o)
                  , l = o.source;
                n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + s);
                const u = i.get(l);
                if (l.version !== u.__version || !0 === c) {
                    n.activeTexture(t.TEXTURE0 + s);
                    const e = Gn.getPrimaries(Gn.workingColorSpace)
                      , i = o.colorSpace === Ue ? null : Gn.getPrimaries(o.colorSpace)
                      , h = o.colorSpace === Ue || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY),
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha),
                    t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment),
                    t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                    const d = o.isCompressedTexture || o.image[0].isCompressedTexture
                      , p = o.image[0] && o.image[0].isDataTexture
                      , f = [];
                    for (let t = 0; t < 6; t++)
                        f[t] = d || p ? p ? o.image[t].image : o.image[t] : m(o.image[t], !0, r.maxCubemapSize),
                        f[t] = Q(o, f[t]);
                    const x = f[0]
                      , M = a.convert(o.format, o.colorSpace)
                      , b = a.convert(o.type)
                      , S = _(o.internalFormat, M, b, o.colorSpace)
                      , E = !0 !== o.isVideoTexture
                      , T = void 0 === u.__version || !0 === c
                      , w = l.dataReady;
                    let A, R = y(o, x);
                    if (O(t.TEXTURE_CUBE_MAP, o),
                    d) {
                        E && T && n.texStorage2D(t.TEXTURE_CUBE_MAP, R, S, x.width, x.height);
                        for (let e = 0; e < 6; e++) {
                            A = f[e].mipmaps;
                            for (let i = 0; i < A.length; i++) {
                                const r = A[i];
                                o.format !== Nt ? null !== M ? E ? w && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, r.width, r.height, M, r.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, S, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : E ? w && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, r.width, r.height, M, b, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, S, r.width, r.height, 0, M, b, r.data)
                            }
                        }
                    } else {
                        if (A = o.mipmaps,
                        E && T) {
                            A.length > 0 && R++;
                            const e = tt(f[0]);
                            n.texStorage2D(t.TEXTURE_CUBE_MAP, R, S, e.width, e.height)
                        }
                        for (let e = 0; e < 6; e++)
                            if (p) {
                                E ? w && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, f[e].width, f[e].height, M, b, f[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, f[e].width, f[e].height, 0, M, b, f[e].data);
                                for (let i = 0; i < A.length; i++) {
                                    const r = A[i]
                                      , a = r.image[e].image;
                                    E ? w && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, a.width, a.height, M, b, a.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, S, a.width, a.height, 0, M, b, a.data)
                                }
                            } else {
                                E ? w && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, M, b, f[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, M, b, f[e]);
                                for (let i = 0; i < A.length; i++) {
                                    const r = A[i];
                                    E ? w && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, M, b, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, S, M, b, r.image[e])
                                }
                            }
                    }
                    g(o) && v(t.TEXTURE_CUBE_MAP),
                    u.__version = l.version,
                    o.onUpdate && o.onUpdate(o)
                }
                e.__version = o.version
            }
            function z(e, r, o, c, l, u) {
                const h = a.convert(o.format, o.colorSpace)
                  , d = a.convert(o.type)
                  , p = _(o.internalFormat, h, d, o.colorSpace)
                  , f = i.get(r);
                if (!f.__hasExternalTextures) {
                    const e = Math.max(1, r.width >> u)
                      , i = Math.max(1, r.height >> u);
                    l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, u, p, e, i, r.depth, 0, h, d, null) : n.texImage2D(l, u, p, e, i, 0, h, d, null)
                }
                n.bindFramebuffer(t.FRAMEBUFFER, e),
                Z(r) ? s.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, c, l, i.get(o).__webglTexture, 0, K(r)) : (l === t.TEXTURE_2D || l >= t.TEXTURE_CUBE_MAP_POSITIVE_X && l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, c, l, i.get(o).__webglTexture, u),
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function V(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = t.DEPTH_COMPONENT24;
                    if (i || Z(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === At ? r = t.DEPTH_COMPONENT32F : e.type === wt && (r = t.DEPTH_COMPONENT24));
                        const i = K(n);
                        Z(n) ? s.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                    } else
                        t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = K(n);
                    i && !1 === Z(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : Z(n) ? s.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = n.textures;
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r]
                          , c = a.convert(o.format, o.colorSpace)
                          , l = a.convert(o.type)
                          , u = _(o.internalFormat, c, l, o.colorSpace)
                          , h = K(n);
                        i && !1 === Z(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, u, n.width, n.height) : Z(n) ? s.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, u, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, u, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }
            function H(e, r) {
                const a = r && r.isWebGLCubeRenderTarget;
                if (a)
                    throw new Error("Depth Texture with cube render targets is not supported");
                if (n.bindFramebuffer(t.FRAMEBUFFER, e),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                r.depthTexture.image.height = r.height,
                r.depthTexture.needsUpdate = !0),
                C(r.depthTexture, 0);
                const o = i.get(r.depthTexture).__webglTexture
                  , c = K(r);
                if (r.depthTexture.format === Bt)
                    Z(r) ? s.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, o, 0, c) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, o, 0);
                else {
                    if (r.depthTexture.format !== kt)
                        throw new Error("Unknown depthTexture format");
                    Z(r) ? s.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, o, 0, c) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, o, 0)
                }
            }
            function G(e) {
                const r = i.get(e)
                  , a = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (a)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    H(r.__webglFramebuffer, e)
                } else if (a) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                        V(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
                    r.__webglDepthbuffer = t.createRenderbuffer(),
                    V(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function j(e, n, r) {
                const a = i.get(e);
                void 0 !== n && z(a.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
                void 0 !== r && G(e)
            }
            function W(e) {
                const r = e.texture
                  , s = i.get(e)
                  , c = i.get(r);
                e.addEventListener("dispose", M);
                const l = e.textures
                  , u = !0 === e.isWebGLCubeRenderTarget
                  , h = l.length > 1;
                if (h || (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()),
                c.__version = r.version,
                o.memory.textures++),
                u) {
                    s.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            s.__webglFramebuffer[e] = [];
                            for (let n = 0; n < r.mipmaps.length; n++)
                                s.__webglFramebuffer[e][n] = t.createFramebuffer()
                        } else
                            s.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        s.__webglFramebuffer = [];
                        for (let e = 0; e < r.mipmaps.length; e++)
                            s.__webglFramebuffer[e] = t.createFramebuffer()
                    } else
                        s.__webglFramebuffer = t.createFramebuffer();
                    if (h)
                        for (let e = 0, n = l.length; e < n; e++) {
                            const n = i.get(l[e]);
                            void 0 === n.__webglTexture && (n.__webglTexture = t.createTexture(),
                            o.memory.textures++)
                        }
                    if (e.samples > 0 && !1 === Z(e)) {
                        s.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        s.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(t.FRAMEBUFFER, s.__webglMultisampledFramebuffer);
                        for (let n = 0; n < l.length; n++) {
                            const i = l[n];
                            s.__webglColorRenderbuffer[n] = t.createRenderbuffer(),
                            t.bindRenderbuffer(t.RENDERBUFFER, s.__webglColorRenderbuffer[n]);
                            const r = a.convert(i.format, i.colorSpace)
                              , o = a.convert(i.type)
                              , c = _(i.internalFormat, r, o, i.colorSpace, !0 === e.isXRRenderTarget)
                              , u = K(e);
                            t.renderbufferStorageMultisample(t.RENDERBUFFER, u, c, e.width, e.height),
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, s.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null),
                        e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        V(s.__webglDepthRenderbuffer, e, !0)),
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                }
                if (u) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, c.__webglTexture),
                    O(t.TEXTURE_CUBE_MAP, r);
                    for (let n = 0; n < 6; n++)
                        if (r.mipmaps && r.mipmaps.length > 0)
                            for (let i = 0; i < r.mipmaps.length; i++)
                                z(s.__webglFramebuffer[n][i], e, r, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            z(s.__webglFramebuffer[n], e, r, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    g(r) && v(t.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (h) {
                    for (let r = 0, a = l.length; r < a; r++) {
                        const a = l[r]
                          , o = i.get(a);
                        n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
                        O(t.TEXTURE_2D, a),
                        z(s.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + r, t.TEXTURE_2D, 0),
                        g(a) && v(t.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = t.TEXTURE_2D;
                    if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
                    n.bindTexture(i, c.__webglTexture),
                    O(i, r),
                    r.mipmaps && r.mipmaps.length > 0)
                        for (let n = 0; n < r.mipmaps.length; n++)
                            z(s.__webglFramebuffer[n], e, r, t.COLOR_ATTACHMENT0, i, n);
                    else
                        z(s.__webglFramebuffer, e, r, t.COLOR_ATTACHMENT0, i, 0);
                    g(r) && v(i),
                    n.unbindTexture()
                }
                e.depthBuffer && G(e)
            }
            function X(e) {
                const r = e.textures;
                for (let a = 0, o = r.length; a < o; a++) {
                    const o = r[a];
                    if (g(o)) {
                        const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D
                          , a = i.get(o).__webglTexture;
                        n.bindTexture(r, a),
                        v(r),
                        n.unbindTexture()
                    }
                }
            }
            const q = []
              , $ = [];
            function Y(e) {
                if (e.samples > 0)
                    if (!1 === Z(e)) {
                        const r = e.textures
                          , a = e.width
                          , o = e.height;
                        let s = t.COLOR_BUFFER_BIT;
                        const l = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                          , u = i.get(e)
                          , h = r.length > 1;
                        if (h)
                            for (let e = 0; e < r.length; e++)
                                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null),
                                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                                t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(t.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            if (e.resolveDepthBuffer && (e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT),
                            e.stencilBuffer && e.resolveStencilBuffer && (s |= t.STENCIL_BUFFER_BIT)),
                            h) {
                                t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, u.__webglColorRenderbuffer[n]);
                                const e = i.get(r[n]).__webglTexture;
                                t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                            }
                            t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, t.NEAREST),
                            !0 === c && (q.length = 0,
                            $.length = 0,
                            q.push(t.COLOR_ATTACHMENT0 + n),
                            e.depthBuffer && !1 === e.resolveDepthBuffer && (q.push(l),
                            $.push(l),
                            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, $)),
                            t.invalidateFramebuffer(t.READ_FRAMEBUFFER, q))
                        }
                        if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                        h)
                            for (let e = 0; e < r.length; e++) {
                                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, u.__webglColorRenderbuffer[e]);
                                const a = i.get(r[e]).__webglTexture;
                                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                                t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, a, 0)
                            }
                        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                    } else if (e.depthBuffer && !1 === e.resolveDepthBuffer && c) {
                        const n = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                        t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [n])
                    }
            }
            function K(t) {
                return Math.min(r.maxSamples, t.samples)
            }
            function Z(t) {
                const n = i.get(t);
                return t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function J(t) {
                const e = o.render.frame;
                u.get(t) !== e && (u.set(t, e),
                t.update())
            }
            function Q(t, e) {
                const n = t.colorSpace
                  , i = t.format
                  , r = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || n !== Ne && n !== Ue && (Gn.getTransfer(n) === ke ? i === Nt && r === Mt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)),
                e
            }
            function tt(t) {
                return "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement ? (l.width = t.naturalWidth || t.width,
                l.height = t.naturalHeight || t.height) : "undefined" !== typeof VideoFrame && t instanceof VideoFrame ? (l.width = t.displayWidth,
                l.height = t.displayHeight) : (l.width = t.width,
                l.height = t.height),
                l
            }
            this.allocateTextureUnit = A,
            this.resetTextureUnits = w,
            this.setTexture2D = C,
            this.setTexture2DArray = P,
            this.setTexture3D = L,
            this.setTextureCube = I,
            this.rebindTextures = j,
            this.setupRenderTarget = W,
            this.updateRenderTargetMipmap = X,
            this.updateMultisampleRenderTarget = Y,
            this.setupDepthRenderbuffer = G,
            this.setupFrameBufferTexture = z,
            this.useMultisampledRTT = Z
        }
        function lh(t, e) {
            function n(n, i=Ue) {
                let r;
                const a = Gn.getTransfer(i);
                if (n === Mt)
                    return t.UNSIGNED_BYTE;
                if (n === Ct)
                    return t.UNSIGNED_SHORT_4_4_4_4;
                if (n === Pt)
                    return t.UNSIGNED_SHORT_5_5_5_1;
                if (n === It)
                    return t.UNSIGNED_INT_5_9_9_9_REV;
                if (n === bt)
                    return t.BYTE;
                if (n === St)
                    return t.SHORT;
                if (n === Et)
                    return t.UNSIGNED_SHORT;
                if (n === Tt)
                    return t.INT;
                if (n === wt)
                    return t.UNSIGNED_INT;
                if (n === At)
                    return t.FLOAT;
                if (n === Rt)
                    return t.HALF_FLOAT;
                if (n === Ut)
                    return t.ALPHA;
                if (n === Dt)
                    return t.RGB;
                if (n === Nt)
                    return t.RGBA;
                if (n === Ot)
                    return t.LUMINANCE;
                if (n === Ft)
                    return t.LUMINANCE_ALPHA;
                if (n === Bt)
                    return t.DEPTH_COMPONENT;
                if (n === kt)
                    return t.DEPTH_STENCIL;
                if (n === zt)
                    return t.RED;
                if (n === Vt)
                    return t.RED_INTEGER;
                if (n === Ht)
                    return t.RG;
                if (n === Gt)
                    return t.RG_INTEGER;
                if (n === jt)
                    return t.RGBA_INTEGER;
                if (n === Wt || n === Xt || n === qt || n === $t)
                    if (a === ke) {
                        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                        null === r)
                            return null;
                        if (n === Wt)
                            return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === Xt)
                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === qt)
                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === $t)
                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else {
                        if (r = e.get("WEBGL_compressed_texture_s3tc"),
                        null === r)
                            return null;
                        if (n === Wt)
                            return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (n === Xt)
                            return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (n === qt)
                            return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (n === $t)
                            return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                if (n === Yt || n === Kt || n === Zt || n === Jt) {
                    if (r = e.get("WEBGL_compressed_texture_pvrtc"),
                    null === r)
                        return null;
                    if (n === Yt)
                        return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === Kt)
                        return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === Zt)
                        return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === Jt)
                        return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (n === Qt || n === te || n === ee) {
                    if (r = e.get("WEBGL_compressed_texture_etc"),
                    null === r)
                        return null;
                    if (n === Qt || n === te)
                        return a === ke ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                    if (n === ee)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                }
                if (n === ne || n === ie || n === re || n === ae || n === oe || n === se || n === ce || n === le || n === ue || n === he || n === de || n === pe || n === fe || n === me) {
                    if (r = e.get("WEBGL_compressed_texture_astc"),
                    null === r)
                        return null;
                    if (n === ne)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (n === ie)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (n === re)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (n === ae)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (n === oe)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (n === se)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (n === ce)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (n === le)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (n === ue)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (n === he)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (n === de)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (n === pe)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (n === fe)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (n === me)
                        return a === ke ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                }
                if (n === ge || n === ve || n === _e) {
                    if (r = e.get("EXT_texture_compression_bptc"),
                    null === r)
                        return null;
                    if (n === ge)
                        return a === ke ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                    if (n === ve)
                        return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                    if (n === _e)
                        return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                }
                if (n === ye || n === xe || n === Me || n === be) {
                    if (r = e.get("EXT_texture_compression_rgtc"),
                    null === r)
                        return null;
                    if (n === ge)
                        return r.COMPRESSED_RED_RGTC1_EXT;
                    if (n === xe)
                        return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (n === Me)
                        return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (n === be)
                        return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                }
                return n === Lt ? t.UNSIGNED_INT_24_8 : void 0 !== t[n] ? t[n] : null
            }
            return {
                convert: n
            }
        }
        class uh extends ba {
            constructor(t=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = t
            }
        }
        class hh extends cr {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const dh = {
            type: "move"
        };
        class ph {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new hh,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new hh,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new ai,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new ai),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new hh,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new ai,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new ai),
                this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            }
            connect(t) {
                if (t && t.hand) {
                    const e = this._hand;
                    if (e)
                        for (const n of t.hand.values())
                            this._getHandJoint(e, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: t
                }),
                this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(t, e, n) {
                let i = null
                  , r = null
                  , a = null;
                const o = this._targetRay
                  , s = this._grip
                  , c = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (c && t.hand) {
                        a = !0;
                        for (const a of t.hand.values()) {
                            const t = e.getJointPose(a, n)
                              , i = this._getHandJoint(c, a);
                            null !== t && (i.matrix.fromArray(t.transform.matrix),
                            i.matrix.decompose(i.position, i.rotation, i.scale),
                            i.matrixWorldNeedsUpdate = !0,
                            i.jointRadius = t.radius),
                            i.visible = null !== t
                        }
                        const i = c.joints["index-finger-tip"]
                          , r = c.joints["thumb-tip"]
                          , o = i.position.distanceTo(r.position)
                          , s = .02
                          , l = .005;
                        c.inputState.pinching && o > s + l ? (c.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !c.inputState.pinching && o <= s - l && (c.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== s && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                        null !== r && (s.matrix.fromArray(r.transform.matrix),
                        s.matrix.decompose(s.position, s.rotation, s.scale),
                        s.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (s.hasLinearVelocity = !0,
                        s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1,
                        r.angularVelocity ? (s.hasAngularVelocity = !0,
                        s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1));
                    null !== o && (i = e.getPose(t.targetRaySpace, n),
                    null === i && null !== r && (i = r),
                    null !== i && (o.matrix.fromArray(i.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    o.matrixWorldNeedsUpdate = !0,
                    i.linearVelocity ? (o.hasLinearVelocity = !0,
                    o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                    i.angularVelocity ? (o.hasAngularVelocity = !0,
                    o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                    this.dispatchEvent(dh)))
                }
                return null !== o && (o.visible = null !== i),
                null !== s && (s.visible = null !== r),
                null !== c && (c.visible = null !== a),
                this
            }
            _getHandJoint(t, e) {
                if (void 0 === t.joints[e.jointName]) {
                    const n = new hh;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    t.joints[e.jointName] = n,
                    t.add(n)
                }
                return t.joints[e.jointName]
            }
        }
        const fh = "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}"
          , mh = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}";
        class gh {
            constructor() {
                this.texture = null,
                this.mesh = null,
                this.depthNear = 0,
                this.depthFar = 0
            }
            init(t, e, n) {
                if (null === this.texture) {
                    const i = new Jn
                      , r = t.properties.get(i);
                    r.__webglTexture = e.texture,
                    e.depthNear == n.depthNear && e.depthFar == n.depthFar || (this.depthNear = e.depthNear,
                    this.depthFar = e.depthFar),
                    this.texture = i
                }
            }
            render(t, e) {
                if (null !== this.texture) {
                    if (null === this.mesh) {
                        const t = e.cameras[0].viewport
                          , n = new va({
                            vertexShader: fh,
                            fragmentShader: mh,
                            uniforms: {
                                depthColor: {
                                    value: this.texture
                                },
                                depthWidth: {
                                    value: t.z
                                },
                                depthHeight: {
                                    value: t.w
                                }
                            }
                        });
                        this.mesh = new oa(new Fa(20,20),n)
                    }
                    t.render(this.mesh, e)
                }
            }
            reset() {
                this.texture = null,
                this.mesh = null
            }
        }
        class vh extends nn {
            constructor(t, e) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , a = null
                  , o = "local-floor"
                  , s = 1
                  , c = null
                  , l = null
                  , u = null
                  , h = null
                  , d = null
                  , p = null;
                const f = new gh
                  , m = e.getContextAttributes();
                let g = null
                  , v = null;
                const _ = []
                  , y = []
                  , x = new Ln;
                let M = null;
                const b = new ba;
                b.layers.enable(1),
                b.viewport = new Qn;
                const S = new ba;
                S.layers.enable(2),
                S.viewport = new Qn;
                const E = [b, S]
                  , T = new uh;
                T.layers.enable(1),
                T.layers.enable(2);
                let w = null
                  , A = null;
                function R(t) {
                    const e = y.indexOf(t.inputSource);
                    if (-1 === e)
                        return;
                    const n = _[e];
                    void 0 !== n && (n.update(t.inputSource, t.frame, c || a),
                    n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    }))
                }
                function C() {
                    i.removeEventListener("select", R),
                    i.removeEventListener("selectstart", R),
                    i.removeEventListener("selectend", R),
                    i.removeEventListener("squeeze", R),
                    i.removeEventListener("squeezestart", R),
                    i.removeEventListener("squeezeend", R),
                    i.removeEventListener("end", C),
                    i.removeEventListener("inputsourceschange", P);
                    for (let t = 0; t < _.length; t++) {
                        const e = y[t];
                        null !== e && (y[t] = null,
                        _[t].disconnect(e))
                    }
                    w = null,
                    A = null,
                    f.reset(),
                    t.setRenderTarget(g),
                    d = null,
                    h = null,
                    u = null,
                    i = null,
                    v = null,
                    B.stop(),
                    n.isPresenting = !1,
                    t.setPixelRatio(M),
                    t.setSize(x.width, x.height, !1),
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function P(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e]
                          , i = y.indexOf(n);
                        i >= 0 && (y[i] = null,
                        _[i].disconnect(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let i = y.indexOf(n);
                        if (-1 === i) {
                            for (let t = 0; t < _.length; t++) {
                                if (t >= y.length) {
                                    y.push(n),
                                    i = t;
                                    break
                                }
                                if (null === y[t]) {
                                    y[t] = n,
                                    i = t;
                                    break
                                }
                            }
                            if (-1 === i)
                                break
                        }
                        const r = _[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new ph,
                    _[t] = e),
                    e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new ph,
                    _[t] = e),
                    e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new ph,
                    _[t] = e),
                    e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    r = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    o = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return c || a
                }
                ,
                this.setReferenceSpace = function(t) {
                    c = t
                }
                ,
                this.getBaseLayer = function() {
                    return null !== h ? h : d
                }
                ,
                this.getBinding = function() {
                    return u
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(l) {
                    if (i = l,
                    null !== i) {
                        if (g = t.getRenderTarget(),
                        i.addEventListener("select", R),
                        i.addEventListener("selectstart", R),
                        i.addEventListener("selectend", R),
                        i.addEventListener("squeeze", R),
                        i.addEventListener("squeezestart", R),
                        i.addEventListener("squeezeend", R),
                        i.addEventListener("end", C),
                        i.addEventListener("inputsourceschange", P),
                        !0 !== m.xrCompatible && await e.makeXRCompatible(),
                        M = t.getPixelRatio(),
                        t.getSize(x),
                        void 0 === i.renderState.layers) {
                            const n = {
                                antialias: m.antialias,
                                alpha: !0,
                                depth: m.depth,
                                stencil: m.stencil,
                                framebufferScaleFactor: r
                            };
                            d = new XRWebGLLayer(i,e,n),
                            i.updateRenderState({
                                baseLayer: d
                            }),
                            t.setPixelRatio(1),
                            t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                            v = new ei(d.framebufferWidth,d.framebufferHeight,{
                                format: Nt,
                                type: Mt,
                                colorSpace: t.outputColorSpace,
                                stencilBuffer: m.stencil
                            })
                        } else {
                            let n = null
                              , a = null
                              , o = null;
                            m.depth && (o = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24,
                            n = m.stencil ? kt : Bt,
                            a = m.stencil ? Lt : wt);
                            const s = {
                                colorFormat: e.RGBA8,
                                depthFormat: o,
                                scaleFactor: r
                            };
                            u = new XRWebGLBinding(i,e),
                            h = u.createProjectionLayer(s),
                            i.updateRenderState({
                                layers: [h]
                            }),
                            t.setPixelRatio(1),
                            t.setSize(h.textureWidth, h.textureHeight, !1),
                            v = new ei(h.textureWidth,h.textureHeight,{
                                format: Nt,
                                type: Mt,
                                depthTexture: new rl(h.textureWidth,h.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: m.stencil,
                                colorSpace: t.outputColorSpace,
                                samples: m.antialias ? 4 : 0,
                                resolveDepthBuffer: !1 === h.ignoreDepthValues
                            })
                        }
                        v.isXRRenderTarget = !0,
                        this.setFoveation(s),
                        c = null,
                        a = await i.requestReferenceSpace(o),
                        B.setContext(i),
                        B.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== i)
                        return i.environmentBlendMode
                }
                ;
                const L = new ai
                  , I = new ai;
                function U(t, e, n) {
                    L.setFromMatrixPosition(e.matrixWorld),
                    I.setFromMatrixPosition(n.matrixWorld);
                    const i = L.distanceTo(I)
                      , r = e.projectionMatrix.elements
                      , a = n.projectionMatrix.elements
                      , o = r[14] / (r[10] - 1)
                      , s = r[14] / (r[10] + 1)
                      , c = (r[9] + 1) / r[5]
                      , l = (r[9] - 1) / r[5]
                      , u = (r[8] - 1) / r[0]
                      , h = (a[8] + 1) / a[0]
                      , d = o * u
                      , p = o * h
                      , f = i / (-u + h)
                      , m = f * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f
                      , v = s + f
                      , _ = d - m
                      , y = p + (i - m)
                      , x = c * s / v * g
                      , M = l * s / v * g;
                    t.projectionMatrix.makePerspective(_, y, x, M, g, v),
                    t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                }
                function D(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                function N(t, e, n) {
                    null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld),
                    t.matrix.invert(),
                    t.matrix.multiply(e.matrixWorld)),
                    t.matrix.decompose(t.position, t.quaternion, t.scale),
                    t.updateMatrixWorld(!0),
                    t.projectionMatrix.copy(e.projectionMatrix),
                    t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    t.isPerspectiveCamera && (t.fov = 2 * sn * Math.atan(1 / t.projectionMatrix.elements[5]),
                    t.zoom = 1)
                }
                this.updateCamera = function(t) {
                    if (null === i)
                        return;
                    null !== f.texture && (t.near = f.depthNear,
                    t.far = f.depthFar),
                    T.near = S.near = b.near = t.near,
                    T.far = S.far = b.far = t.far,
                    w === T.near && A === T.far || (i.updateRenderState({
                        depthNear: T.near,
                        depthFar: T.far
                    }),
                    w = T.near,
                    A = T.far,
                    b.near = w,
                    b.far = A,
                    S.near = w,
                    S.far = A,
                    b.updateProjectionMatrix(),
                    S.updateProjectionMatrix(),
                    t.updateProjectionMatrix());
                    const e = t.parent
                      , n = T.cameras;
                    D(T, e);
                    for (let i = 0; i < n.length; i++)
                        D(n[i], e);
                    2 === n.length ? U(T, b, S) : T.projectionMatrix.copy(b.projectionMatrix),
                    N(t, T, e)
                }
                ,
                this.getCamera = function() {
                    return T
                }
                ,
                this.getFoveation = function() {
                    if (null !== h || null !== d)
                        return s
                }
                ,
                this.setFoveation = function(t) {
                    s = t,
                    null !== h && (h.fixedFoveation = t),
                    null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                }
                ,
                this.hasDepthSensing = function() {
                    return null !== f.texture
                }
                ;
                let O = null;
                function F(e, r) {
                    if (l = r.getViewerPose(c || a),
                    p = r,
                    null !== l) {
                        const e = l.views;
                        null !== d && (t.setRenderTargetFramebuffer(v, d.framebuffer),
                        t.setRenderTarget(v));
                        let n = !1;
                        e.length !== T.cameras.length && (T.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let a = null;
                            if (null !== d)
                                a = d.getViewport(r);
                            else {
                                const e = u.getViewSubImage(h, r);
                                a = e.viewport,
                                0 === i && (t.setRenderTargetTextures(v, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture),
                                t.setRenderTarget(v))
                            }
                            let o = E[i];
                            void 0 === o && (o = new ba,
                            o.layers.enable(i),
                            o.viewport = new Qn,
                            E[i] = o),
                            o.matrix.fromArray(r.transform.matrix),
                            o.matrix.decompose(o.position, o.quaternion, o.scale),
                            o.projectionMatrix.fromArray(r.projectionMatrix),
                            o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                            o.viewport.set(a.x, a.y, a.width, a.height),
                            0 === i && (T.matrix.copy(o.matrix),
                            T.matrix.decompose(T.position, T.quaternion, T.scale)),
                            !0 === n && T.cameras.push(o)
                        }
                        const r = i.enabledFeatures;
                        if (r && r.includes("depth-sensing")) {
                            const n = u.getDepthInformation(e[0]);
                            n && n.isValid && n.texture && f.init(t, n, i.renderState)
                        }
                    }
                    for (let t = 0; t < _.length; t++) {
                        const e = y[t]
                          , n = _[t];
                        null !== e && void 0 !== n && n.update(e, r, c || a)
                    }
                    f.render(t, T),
                    O && O(e, r),
                    r.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }),
                    p = null
                }
                const B = new Na;
                B.setAnimationLoop(F),
                this.setAnimationLoop = function(t) {
                    O = t
                }
                ,
                this.dispose = function() {}
            }
        }
        const _h = new Wi
          , yh = new Ni;
        function xh(t, e) {
            function n(t, e) {
                !0 === t.matrixAutoUpdate && t.updateMatrix(),
                e.value.copy(t.matrix)
            }
            function i(e, n) {
                n.color.getRGB(e.fogColor.value, pa(t)),
                n.isFog ? (e.fogNear.value = n.near,
                e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
            }
            function r(t, e, n, i, r) {
                e.isMeshBasicMaterial || e.isMeshLambertMaterial ? a(t, e) : e.isMeshToonMaterial ? (a(t, e),
                h(t, e)) : e.isMeshPhongMaterial ? (a(t, e),
                u(t, e)) : e.isMeshStandardMaterial ? (a(t, e),
                d(t, e),
                e.isMeshPhysicalMaterial && f(t, e, r)) : e.isMeshMatcapMaterial ? (a(t, e),
                m(t, e)) : e.isMeshDepthMaterial ? a(t, e) : e.isMeshDistanceMaterial ? (a(t, e),
                g(t, e)) : e.isMeshNormalMaterial ? a(t, e) : e.isLineBasicMaterial ? (o(t, e),
                e.isLineDashedMaterial && s(t, e)) : e.isPointsMaterial ? c(t, e, n, i) : e.isSpriteMaterial ? l(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color),
                t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
            }
            function a(i, r) {
                i.opacity.value = r.opacity,
                r.color && i.diffuse.value.copy(r.color),
                r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
                r.map && (i.map.value = r.map,
                n(r.map, i.mapTransform)),
                r.alphaMap && (i.alphaMap.value = r.alphaMap,
                n(r.alphaMap, i.alphaMapTransform)),
                r.bumpMap && (i.bumpMap.value = r.bumpMap,
                n(r.bumpMap, i.bumpMapTransform),
                i.bumpScale.value = r.bumpScale,
                r.side === p && (i.bumpScale.value *= -1)),
                r.normalMap && (i.normalMap.value = r.normalMap,
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                r.side === p && i.normalScale.value.negate()),
                r.displacementMap && (i.displacementMap.value = r.displacementMap,
                n(r.displacementMap, i.displacementMapTransform),
                i.displacementScale.value = r.displacementScale,
                i.displacementBias.value = r.displacementBias),
                r.emissiveMap && (i.emissiveMap.value = r.emissiveMap,
                n(r.emissiveMap, i.emissiveMapTransform)),
                r.specularMap && (i.specularMap.value = r.specularMap,
                n(r.specularMap, i.specularMapTransform)),
                r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const a = e.get(r)
                  , o = a.envMap
                  , s = a.envMapRotation;
                if (o && (i.envMap.value = o,
                _h.copy(s),
                _h.x *= -1,
                _h.y *= -1,
                _h.z *= -1,
                o.isCubeTexture && !1 === o.isRenderTargetTexture && (_h.y *= -1,
                _h.z *= -1),
                i.envMapRotation.value.setFromMatrix4(yh.makeRotationFromEuler(_h)),
                i.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1,
                i.reflectivity.value = r.reflectivity,
                i.ior.value = r.ior,
                i.refractionRatio.value = r.refractionRatio),
                r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const e = !0 === t._useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * e,
                    n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap,
                i.aoMapIntensity.value = r.aoMapIntensity,
                n(r.aoMap, i.aoMapTransform))
            }
            function o(t, e) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity,
                e.map && (t.map.value = e.map,
                n(e.map, t.mapTransform))
            }
            function s(t, e) {
                t.dashSize.value = e.dashSize,
                t.totalSize.value = e.dashSize + e.gapSize,
                t.scale.value = e.scale
            }
            function c(t, e, i, r) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity,
                t.size.value = e.size * i,
                t.scale.value = .5 * r,
                e.map && (t.map.value = e.map,
                n(e.map, t.uvTransform)),
                e.alphaMap && (t.alphaMap.value = e.alphaMap,
                n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
            }
            function l(t, e) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity,
                t.rotation.value = e.rotation,
                e.map && (t.map.value = e.map,
                n(e.map, t.mapTransform)),
                e.alphaMap && (t.alphaMap.value = e.alphaMap,
                n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
            }
            function u(t, e) {
                t.specular.value.copy(e.specular),
                t.shininess.value = Math.max(e.shininess, 1e-4)
            }
            function h(t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }
            function d(t, e) {
                t.metalness.value = e.metalness,
                e.metalnessMap && (t.metalnessMap.value = e.metalnessMap,
                n(e.metalnessMap, t.metalnessMapTransform)),
                t.roughness.value = e.roughness,
                e.roughnessMap && (t.roughnessMap.value = e.roughnessMap,
                n(e.roughnessMap, t.roughnessMapTransform)),
                e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }
            function f(t, e, i) {
                t.ior.value = e.ior,
                e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                t.sheenRoughness.value = e.sheenRoughness,
                e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap,
                n(e.sheenColorMap, t.sheenColorMapTransform)),
                e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap,
                n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                t.clearcoatRoughness.value = e.clearcoatRoughness,
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap,
                n(e.clearcoatMap, t.clearcoatMapTransform)),
                e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap,
                n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)),
                e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                e.side === p && t.clearcoatNormalScale.value.negate())),
                e.dispersion > 0 && (t.dispersion.value = e.dispersion),
                e.iridescence > 0 && (t.iridescence.value = e.iridescence,
                t.iridescenceIOR.value = e.iridescenceIOR,
                t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0],
                t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1],
                e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap,
                n(e.iridescenceMap, t.iridescenceMapTransform)),
                e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap,
                n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))),
                e.transmission > 0 && (t.transmission.value = e.transmission,
                t.transmissionSamplerMap.value = i.texture,
                t.transmissionSamplerSize.value.set(i.width, i.height),
                e.transmissionMap && (t.transmissionMap.value = e.transmissionMap,
                n(e.transmissionMap, t.transmissionMapTransform)),
                t.thickness.value = e.thickness,
                e.thicknessMap && (t.thicknessMap.value = e.thicknessMap,
                n(e.thicknessMap, t.thicknessMapTransform)),
                t.attenuationDistance.value = e.attenuationDistance,
                t.attenuationColor.value.copy(e.attenuationColor)),
                e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)),
                e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap,
                n(e.anisotropyMap, t.anisotropyMapTransform))),
                t.specularIntensity.value = e.specularIntensity,
                t.specularColor.value.copy(e.specularColor),
                e.specularColorMap && (t.specularColorMap.value = e.specularColorMap,
                n(e.specularColorMap, t.specularColorMapTransform)),
                e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap,
                n(e.specularIntensityMap, t.specularIntensityMapTransform))
            }
            function m(t, e) {
                e.matcap && (t.matcap.value = e.matcap)
            }
            function g(t, n) {
                const i = e.get(n).light;
                t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                t.nearDistance.value = i.shadow.camera.near,
                t.farDistance.value = i.shadow.camera.far
            }
            return {
                refreshFogUniforms: i,
                refreshMaterialUniforms: r
            }
        }
        function Mh(t, e, n, i) {
            let r = {}
              , a = {}
              , o = [];
            const s = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
            function c(t, e) {
                const n = e.program;
                i.uniformBlockBinding(t, n)
            }
            function l(t, n) {
                let o = r[t.id];
                void 0 === o && (f(t),
                o = u(t),
                r[t.id] = o,
                t.addEventListener("dispose", g));
                const s = n.program;
                i.updateUBOMapping(t, s);
                const c = e.render.frame;
                a[t.id] !== c && (d(t),
                a[t.id] = c)
            }
            function u(e) {
                const n = h();
                e.__bindingPointIndex = n;
                const i = t.createBuffer()
                  , r = e.__size
                  , a = e.usage;
                return t.bindBuffer(t.UNIFORM_BUFFER, i),
                t.bufferData(t.UNIFORM_BUFFER, r, a),
                t.bindBuffer(t.UNIFORM_BUFFER, null),
                t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                i
            }
            function h() {
                for (let t = 0; t < s; t++)
                    if (-1 === o.indexOf(t))
                        return o.push(t),
                        t;
                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                0
            }
            function d(e) {
                const n = r[e.id]
                  , i = e.uniforms
                  , a = e.__cache;
                t.bindBuffer(t.UNIFORM_BUFFER, n);
                for (let r = 0, o = i.length; r < o; r++) {
                    const e = Array.isArray(i[r]) ? i[r] : [i[r]];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        if (!0 === p(i, r, n, a)) {
                            const e = i.__offset
                              , n = Array.isArray(i.value) ? i.value : [i.value];
                            let r = 0;
                            for (let a = 0; a < n.length; a++) {
                                const o = n[a]
                                  , s = m(o);
                                "number" === typeof o || "boolean" === typeof o ? (i.__data[0] = o,
                                t.bufferSubData(t.UNIFORM_BUFFER, e + r, i.__data)) : o.isMatrix3 ? (i.__data[0] = o.elements[0],
                                i.__data[1] = o.elements[1],
                                i.__data[2] = o.elements[2],
                                i.__data[3] = 0,
                                i.__data[4] = o.elements[3],
                                i.__data[5] = o.elements[4],
                                i.__data[6] = o.elements[5],
                                i.__data[7] = 0,
                                i.__data[8] = o.elements[6],
                                i.__data[9] = o.elements[7],
                                i.__data[10] = o.elements[8],
                                i.__data[11] = 0) : (o.toArray(i.__data, r),
                                r += s.storage / Float32Array.BYTES_PER_ELEMENT)
                            }
                            t.bufferSubData(t.UNIFORM_BUFFER, e, i.__data)
                        }
                    }
                }
                t.bindBuffer(t.UNIFORM_BUFFER, null)
            }
            function p(t, e, n, i) {
                const r = t.value
                  , a = e + "_" + n;
                if (void 0 === i[a])
                    return i[a] = "number" === typeof r || "boolean" === typeof r ? r : r.clone(),
                    !0;
                {
                    const t = i[a];
                    if ("number" === typeof r || "boolean" === typeof r) {
                        if (t !== r)
                            return i[a] = r,
                            !0
                    } else if (!1 === t.equals(r))
                        return t.copy(r),
                        !0
                }
                return !1
            }
            function f(t) {
                const e = t.uniforms;
                let n = 0;
                const i = 16;
                for (let a = 0, o = e.length; a < o; a++) {
                    const t = Array.isArray(e[a]) ? e[a] : [e[a]];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = t[e]
                          , a = Array.isArray(r.value) ? r.value : [r.value];
                        for (let t = 0, e = a.length; t < e; t++) {
                            const e = a[t]
                              , o = m(e)
                              , s = n % i;
                            0 !== s && i - s < o.boundary && (n += i - s),
                            r.__data = new Float32Array(o.storage / Float32Array.BYTES_PER_ELEMENT),
                            r.__offset = n,
                            n += o.storage
                        }
                    }
                }
                const r = n % i;
                return r > 0 && (n += i - r),
                t.__size = n,
                t.__cache = {},
                this
            }
            function m(t) {
                const e = {
                    boundary: 0,
                    storage: 0
                };
                return "number" === typeof t || "boolean" === typeof t ? (e.boundary = 4,
                e.storage = 4) : t.isVector2 ? (e.boundary = 8,
                e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16,
                e.storage = 12) : t.isVector4 ? (e.boundary = 16,
                e.storage = 16) : t.isMatrix3 ? (e.boundary = 48,
                e.storage = 48) : t.isMatrix4 ? (e.boundary = 64,
                e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t),
                e
            }
            function g(e) {
                const n = e.target;
                n.removeEventListener("dispose", g);
                const i = o.indexOf(n.__bindingPointIndex);
                o.splice(i, 1),
                t.deleteBuffer(r[n.id]),
                delete r[n.id],
                delete a[n.id]
            }
            function v() {
                for (const e in r)
                    t.deleteBuffer(r[e]);
                o = [],
                r = {},
                a = {}
            }
            return {
                bind: c,
                update: l,
                dispose: v
            }
        }
        class bh {
            constructor(t={}) {
                const {canvas: e=On(), context: n=null, depth: r=!0, stencil: a=!1, alpha: o=!1, antialias: s=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: l=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1} = t;
                let m;
                if (this.isWebGLRenderer = !0,
                null !== n) {
                    if ("undefined" !== typeof WebGLRenderingContext && n instanceof WebGLRenderingContext)
                        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                    m = n.getContextAttributes().alpha
                } else
                    m = o;
                const g = new Uint32Array(4)
                  , v = new Int32Array(4);
                let _ = null
                  , y = null;
                const x = []
                  , M = [];
                this.domElement = e,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = De,
                this._useLegacyLights = !1,
                this.toneMapping = J,
                this.toneMappingExposure = 1;
                const b = this;
                let S = !1
                  , E = 0
                  , T = 0
                  , w = null
                  , A = -1
                  , R = null;
                const C = new Qn
                  , P = new Qn;
                let L = null;
                const I = new Er(0);
                let U = 0
                  , D = e.width
                  , N = e.height
                  , O = 1
                  , F = null
                  , B = null;
                const k = new Qn(0,0,D,N)
                  , z = new Qn(0,0,D,N);
                let V = !1;
                const H = new Da;
                let G = !1
                  , j = !1;
                const W = new Ni
                  , X = new ai
                  , q = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function $() {
                    return null === w ? O : 1
                }
                let Y, K, Z, Q, tt, et, nt, it, rt, at, ot, st, ct, lt, ut, ht, dt, pt, ft, mt, gt, vt, _t, yt, bt = n;
                function St(t, n) {
                    return e.getContext(t, n)
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: r,
                        stencil: a,
                        antialias: s,
                        premultipliedAlpha: c,
                        preserveDrawingBuffer: l,
                        powerPreference: u,
                        failIfMajorPerformanceCaveat: h
                    };
                    if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${i}`),
                    e.addEventListener("webglcontextlost", It, !1),
                    e.addEventListener("webglcontextrestored", Ut, !1),
                    e.addEventListener("webglcontextcreationerror", Dt, !1),
                    null === bt) {
                        const e = "webgl2";
                        if (bt = St(e, t),
                        null === bt)
                            throw St(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                } catch (re) {
                    throw console.error("THREE.WebGLRenderer: " + re.message),
                    re
                }
                function Tt() {
                    Y = new Jc(bt),
                    Y.init(),
                    vt = new lh(bt,Y),
                    K = new Ac(bt,Y,t,vt),
                    Z = new sh(bt),
                    Q = new el(bt),
                    tt = new ju,
                    et = new ch(bt,Y,Z,tt,K,vt,Q),
                    nt = new Cc(b),
                    it = new Zc(b),
                    rt = new Oa(bt),
                    _t = new Tc(bt,rt),
                    at = new Qc(bt,rt,Q,_t),
                    ot = new il(bt,at,rt,Q),
                    ft = new nl(bt,K,et),
                    ht = new Rc(tt),
                    st = new Gu(b,nt,it,Y,K,_t,ht),
                    ct = new xh(b,tt),
                    lt = new $u,
                    ut = new eh(Y),
                    pt = new Ec(b,nt,it,Z,ot,m,c),
                    dt = new oh(b,ot,K),
                    yt = new Mh(bt,Q,K,Z),
                    mt = new wc(bt,Y,Q),
                    gt = new tl(bt,Y,Q),
                    Q.programs = st.programs,
                    b.capabilities = K,
                    b.extensions = Y,
                    b.properties = tt,
                    b.renderLists = lt,
                    b.shadowMap = dt,
                    b.state = Z,
                    b.info = Q
                }
                Tt();
                const At = new vh(b,bt);
                function It(t) {
                    t.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    S = !0
                }
                function Ut() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    S = !1;
                    const t = Q.autoReset
                      , e = dt.enabled
                      , n = dt.autoUpdate
                      , i = dt.needsUpdate
                      , r = dt.type;
                    Tt(),
                    Q.autoReset = t,
                    dt.enabled = e,
                    dt.autoUpdate = n,
                    dt.needsUpdate = i,
                    dt.type = r
                }
                function Dt(t) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                }
                function Nt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", Nt),
                    Ot(e)
                }
                function Ot(t) {
                    Ft(t),
                    tt.remove(t)
                }
                function Ft(t) {
                    const e = tt.get(t).programs;
                    void 0 !== e && (e.forEach((function(t) {
                        st.releaseProgram(t)
                    }
                    )),
                    t.isShaderMaterial && st.releaseShaderCache(t))
                }
                function Bt(t, e, n) {
                    !0 === t.transparent && t.side === f && !1 === t.forceSinglePass ? (t.side = p,
                    t.needsUpdate = !0,
                    Jt(t, e, n),
                    t.side = d,
                    t.needsUpdate = !0,
                    Jt(t, e, n),
                    t.side = f) : Jt(t, e, n)
                }
                this.xr = At,
                this.getContext = function() {
                    return bt
                }
                ,
                this.getContextAttributes = function() {
                    return bt.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const t = Y.get("WEBGL_lose_context");
                    t && t.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const t = Y.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return O
                }
                ,
                this.setPixelRatio = function(t) {
                    void 0 !== t && (O = t,
                    this.setSize(D, N, !1))
                }
                ,
                this.getSize = function(t) {
                    return t.set(D, N)
                }
                ,
                this.setSize = function(t, n, i=!0) {
                    At.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (D = t,
                    N = n,
                    e.width = Math.floor(t * O),
                    e.height = Math.floor(n * O),
                    !0 === i && (e.style.width = t + "px",
                    e.style.height = n + "px"),
                    this.setViewport(0, 0, t, n))
                }
                ,
                this.getDrawingBufferSize = function(t) {
                    return t.set(D * O, N * O).floor()
                }
                ,
                this.setDrawingBufferSize = function(t, n, i) {
                    D = t,
                    N = n,
                    O = i,
                    e.width = Math.floor(t * i),
                    e.height = Math.floor(n * i),
                    this.setViewport(0, 0, t, n)
                }
                ,
                this.getCurrentViewport = function(t) {
                    return t.copy(C)
                }
                ,
                this.getViewport = function(t) {
                    return t.copy(k)
                }
                ,
                this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, i),
                    Z.viewport(C.copy(k).multiplyScalar(O).round())
                }
                ,
                this.getScissor = function(t) {
                    return t.copy(z)
                }
                ,
                this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, i),
                    Z.scissor(P.copy(z).multiplyScalar(O).round())
                }
                ,
                this.getScissorTest = function() {
                    return V
                }
                ,
                this.setScissorTest = function(t) {
                    Z.setScissorTest(V = t)
                }
                ,
                this.setOpaqueSort = function(t) {
                    F = t
                }
                ,
                this.setTransparentSort = function(t) {
                    B = t
                }
                ,
                this.getClearColor = function(t) {
                    return t.copy(pt.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    pt.setClearColor.apply(pt, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return pt.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    pt.setClearAlpha.apply(pt, arguments)
                }
                ,
                this.clear = function(t=!0, e=!0, n=!0) {
                    let i = 0;
                    if (t) {
                        let t = !1;
                        if (null !== w) {
                            const e = w.texture.format;
                            t = e === jt || e === Gt || e === Vt
                        }
                        if (t) {
                            const t = w.texture.type
                              , e = t === Mt || t === wt || t === Et || t === Lt || t === Ct || t === Pt
                              , n = pt.getClearColor()
                              , i = pt.getClearAlpha()
                              , r = n.r
                              , a = n.g
                              , o = n.b;
                            e ? (g[0] = r,
                            g[1] = a,
                            g[2] = o,
                            g[3] = i,
                            bt.clearBufferuiv(bt.COLOR, 0, g)) : (v[0] = r,
                            v[1] = a,
                            v[2] = o,
                            v[3] = i,
                            bt.clearBufferiv(bt.COLOR, 0, v))
                        } else
                            i |= bt.COLOR_BUFFER_BIT
                    }
                    e && (i |= bt.DEPTH_BUFFER_BIT),
                    n && (i |= bt.STENCIL_BUFFER_BIT,
                    this.state.buffers.stencil.setMask(4294967295)),
                    bt.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    e.removeEventListener("webglcontextlost", It, !1),
                    e.removeEventListener("webglcontextrestored", Ut, !1),
                    e.removeEventListener("webglcontextcreationerror", Dt, !1),
                    lt.dispose(),
                    ut.dispose(),
                    tt.dispose(),
                    nt.dispose(),
                    it.dispose(),
                    ot.dispose(),
                    _t.dispose(),
                    yt.dispose(),
                    st.dispose(),
                    At.dispose(),
                    At.removeEventListener("sessionstart", Ht),
                    At.removeEventListener("sessionend", Wt),
                    Xt.stop()
                }
                ,
                this.renderBufferDirect = function(t, e, n, i, r, a) {
                    null === e && (e = q);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0
                      , s = ee(t, e, n, i, r);
                    Z.setMaterial(i, o);
                    let c = n.index
                      , l = 1;
                    if (!0 === i.wireframe) {
                        if (c = at.getWireframeAttribute(n),
                        void 0 === c)
                            return;
                        l = 2
                    }
                    const u = n.drawRange
                      , h = n.attributes.position;
                    let d = u.start * l
                      , p = (u.start + u.count) * l;
                    null !== a && (d = Math.max(d, a.start * l),
                    p = Math.min(p, (a.start + a.count) * l)),
                    null !== c ? (d = Math.max(d, 0),
                    p = Math.min(p, c.count)) : void 0 !== h && null !== h && (d = Math.max(d, 0),
                    p = Math.min(p, h.count));
                    const f = p - d;
                    if (f < 0 || f === 1 / 0)
                        return;
                    let m;
                    _t.setup(r, i, s, n, c);
                    let g = mt;
                    if (null !== c && (m = rt.get(c),
                    g = gt,
                    g.setIndex(m)),
                    r.isMesh)
                        !0 === i.wireframe ? (Z.setLineWidth(i.wireframeLinewidth * $()),
                        g.setMode(bt.LINES)) : g.setMode(bt.TRIANGLES);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1),
                        Z.setLineWidth(t * $()),
                        r.isLineSegments ? g.setMode(bt.LINES) : r.isLineLoop ? g.setMode(bt.LINE_LOOP) : g.setMode(bt.LINE_STRIP)
                    } else
                        r.isPoints ? g.setMode(bt.POINTS) : r.isSprite && g.setMode(bt.TRIANGLES);
                    if (r.isBatchedMesh)
                        null !== r._multiDrawInstances ? g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances) : g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                    else if (r.isInstancedMesh)
                        g.renderInstances(d, f, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , e = Math.min(n.instanceCount, t);
                        g.renderInstances(d, f, e)
                    } else
                        g.render(d, f)
                }
                ,
                this.compile = function(t, e, n=null) {
                    null === n && (n = t),
                    y = ut.get(n),
                    y.init(e),
                    M.push(y),
                    n.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (y.pushLight(t),
                        t.castShadow && y.pushShadow(t))
                    }
                    )),
                    t !== n && t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (y.pushLight(t),
                        t.castShadow && y.pushShadow(t))
                    }
                    )),
                    y.setupLights(b._useLegacyLights);
                    const i = new Set;
                    return t.traverse((function(t) {
                        const e = t.material;
                        if (e)
                            if (Array.isArray(e))
                                for (let r = 0; r < e.length; r++) {
                                    const a = e[r];
                                    Bt(a, n, t),
                                    i.add(a)
                                }
                            else
                                Bt(e, n, t),
                                i.add(e)
                    }
                    )),
                    M.pop(),
                    y = null,
                    i
                }
                ,
                this.compileAsync = function(t, e, n=null) {
                    const i = this.compile(t, e, n);
                    return new Promise((e=>{
                        function n() {
                            i.forEach((function(t) {
                                const e = tt.get(t)
                                  , n = e.currentProgram;
                                n.isReady() && i.delete(t)
                            }
                            )),
                            0 !== i.size ? setTimeout(n, 10) : e(t)
                        }
                        null !== Y.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }
                    ))
                }
                ;
                let kt = null;
                function zt(t) {
                    kt && kt(t)
                }
                function Ht() {
                    Xt.stop()
                }
                function Wt() {
                    Xt.start()
                }
                const Xt = new Na;
                function qt(t, e, n, i) {
                    if (!1 === t.visible)
                        return;
                    const r = t.layers.test(e.layers);
                    if (r)
                        if (t.isGroup)
                            n = t.renderOrder;
                        else if (t.isLOD)
                            !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight)
                            y.pushLight(t),
                            t.castShadow && y.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || H.intersectsSprite(t)) {
                                i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
                                const e = ot.update(t)
                                  , r = t.material;
                                r.visible && _.push(t, e, r, n, X.z, null)
                            }
                        } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || H.intersectsObject(t))) {
                            const e = ot.update(t)
                              , r = t.material;
                            if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(),
                            X.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(),
                            X.copy(e.boundingSphere.center)),
                            X.applyMatrix4(t.matrixWorld).applyMatrix4(W)),
                            Array.isArray(r)) {
                                const i = e.groups;
                                for (let a = 0, o = i.length; a < o; a++) {
                                    const o = i[a]
                                      , s = r[o.materialIndex];
                                    s && s.visible && _.push(t, e, s, n, X.z, o)
                                }
                            } else
                                r.visible && _.push(t, e, r, n, X.z, null)
                        }
                    const a = t.children;
                    for (let o = 0, s = a.length; o < s; o++)
                        qt(a[o], e, n, i)
                }
                function $t(t, e, n, i) {
                    const r = t.opaque
                      , a = t.transmissive
                      , o = t.transparent;
                    y.setupLightsView(n),
                    !0 === G && ht.setGlobalState(b.clippingPlanes, n),
                    i && Z.viewport(C.copy(i)),
                    r.length > 0 && Kt(r, e, n),
                    a.length > 0 && Kt(a, e, n),
                    o.length > 0 && Kt(o, e, n),
                    Z.buffers.depth.setTest(!0),
                    Z.buffers.depth.setMask(!0),
                    Z.buffers.color.setMask(!0),
                    Z.setPolygonOffset(!1)
                }
                function Yt(t, e, n, i) {
                    const r = !0 === n.isScene ? n.overrideMaterial : null;
                    if (null !== r)
                        return;
                    void 0 === y.state.transmissionRenderTarget[i.id] && (y.state.transmissionRenderTarget[i.id] = new ei(1,1,{
                        generateMipmaps: !0,
                        type: Y.has("EXT_color_buffer_half_float") || Y.has("EXT_color_buffer_float") ? Rt : Mt,
                        minFilter: xt,
                        samples: 4,
                        stencilBuffer: a,
                        resolveDepthBuffer: !1,
                        resolveStencilBuffer: !1
                    }));
                    const o = y.state.transmissionRenderTarget[i.id]
                      , s = i.viewport || C;
                    o.setSize(s.z, s.w);
                    const c = b.getRenderTarget();
                    b.setRenderTarget(o),
                    b.getClearColor(I),
                    U = b.getClearAlpha(),
                    U < 1 && b.setClearColor(16777215, .5),
                    b.clear();
                    const l = b.toneMapping;
                    b.toneMapping = J;
                    const u = i.viewport;
                    if (void 0 !== i.viewport && (i.viewport = void 0),
                    y.setupLightsView(i),
                    !0 === G && ht.setGlobalState(b.clippingPlanes, i),
                    Kt(t, n, i),
                    et.updateMultisampleRenderTarget(o),
                    et.updateRenderTargetMipmap(o),
                    !1 === Y.has("WEBGL_multisampled_render_to_texture")) {
                        let t = !1;
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r]
                              , o = a.object
                              , s = a.geometry
                              , c = a.material
                              , l = a.group;
                            if (c.side === f && o.layers.test(i.layers)) {
                                const e = c.side;
                                c.side = p,
                                c.needsUpdate = !0,
                                Zt(o, n, i, s, c, l),
                                c.side = e,
                                c.needsUpdate = !0,
                                t = !0
                            }
                        }
                        !0 === t && (et.updateMultisampleRenderTarget(o),
                        et.updateRenderTargetMipmap(o))
                    }
                    b.setRenderTarget(c),
                    b.setClearColor(I, U),
                    void 0 !== u && (i.viewport = u),
                    b.toneMapping = l
                }
                function Kt(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r]
                          , o = a.object
                          , s = a.geometry
                          , c = null === i ? a.material : i
                          , l = a.group;
                        o.layers.test(n.layers) && Zt(o, e, n, s, c, l)
                    }
                }
                function Zt(t, e, n, i, r, a) {
                    t.onBeforeRender(b, e, n, i, r, a),
                    t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                    t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                    r.onBeforeRender(b, e, n, i, t, a),
                    !0 === r.transparent && r.side === f && !1 === r.forceSinglePass ? (r.side = p,
                    r.needsUpdate = !0,
                    b.renderBufferDirect(n, e, i, r, t, a),
                    r.side = d,
                    r.needsUpdate = !0,
                    b.renderBufferDirect(n, e, i, r, t, a),
                    r.side = f) : b.renderBufferDirect(n, e, i, r, t, a),
                    t.onAfterRender(b, e, n, i, r, a)
                }
                function Jt(t, e, n) {
                    !0 !== e.isScene && (e = q);
                    const i = tt.get(t)
                      , r = y.state.lights
                      , a = y.state.shadowsArray
                      , o = r.state.version
                      , s = st.getParameters(t, r.state, a, e, n)
                      , c = st.getProgramCacheKey(s);
                    let l = i.programs;
                    i.environment = t.isMeshStandardMaterial ? e.environment : null,
                    i.fog = e.fog,
                    i.envMap = (t.isMeshStandardMaterial ? it : nt).get(t.envMap || i.environment),
                    i.envMapRotation = null !== i.environment && null === t.envMap ? e.environmentRotation : t.envMapRotation,
                    void 0 === l && (t.addEventListener("dispose", Nt),
                    l = new Map,
                    i.programs = l);
                    let u = l.get(c);
                    if (void 0 !== u) {
                        if (i.currentProgram === u && i.lightsStateVersion === o)
                            return te(t, s),
                            u
                    } else
                        s.uniforms = st.getUniforms(t),
                        t.onBuild(n, s, b),
                        t.onBeforeCompile(s, b),
                        u = st.acquireProgram(s, c),
                        l.set(c, u),
                        i.uniforms = s.uniforms;
                    const h = i.uniforms;
                    return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = ht.uniform),
                    te(t, s),
                    i.needsLights = ie(t),
                    i.lightsStateVersion = o,
                    i.needsLights && (h.ambientLightColor.value = r.state.ambient,
                    h.lightProbe.value = r.state.probe,
                    h.directionalLights.value = r.state.directional,
                    h.directionalLightShadows.value = r.state.directionalShadow,
                    h.spotLights.value = r.state.spot,
                    h.spotLightShadows.value = r.state.spotShadow,
                    h.rectAreaLights.value = r.state.rectArea,
                    h.ltc_1.value = r.state.rectAreaLTC1,
                    h.ltc_2.value = r.state.rectAreaLTC2,
                    h.pointLights.value = r.state.point,
                    h.pointLightShadows.value = r.state.pointShadow,
                    h.hemisphereLights.value = r.state.hemi,
                    h.directionalShadowMap.value = r.state.directionalShadowMap,
                    h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    h.spotShadowMap.value = r.state.spotShadowMap,
                    h.spotLightMatrix.value = r.state.spotLightMatrix,
                    h.spotLightMap.value = r.state.spotLightMap,
                    h.pointShadowMap.value = r.state.pointShadowMap,
                    h.pointShadowMatrix.value = r.state.pointShadowMatrix),
                    i.currentProgram = u,
                    i.uniformsList = null,
                    u
                }
                function Qt(t) {
                    if (null === t.uniformsList) {
                        const e = t.currentProgram.getUniforms();
                        t.uniformsList = hu.seqWithValue(e.seq, t.uniforms)
                    }
                    return t.uniformsList
                }
                function te(t, e) {
                    const n = tt.get(t);
                    n.outputColorSpace = e.outputColorSpace,
                    n.batching = e.batching,
                    n.instancing = e.instancing,
                    n.instancingColor = e.instancingColor,
                    n.instancingMorph = e.instancingMorph,
                    n.skinning = e.skinning,
                    n.morphTargets = e.morphTargets,
                    n.morphNormals = e.morphNormals,
                    n.morphColors = e.morphColors,
                    n.morphTargetsCount = e.morphTargetsCount,
                    n.numClippingPlanes = e.numClippingPlanes,
                    n.numIntersection = e.numClipIntersection,
                    n.vertexAlphas = e.vertexAlphas,
                    n.vertexTangents = e.vertexTangents,
                    n.toneMapping = e.toneMapping
                }
                function ee(t, e, n, i, r) {
                    !0 !== e.isScene && (e = q),
                    et.resetTextureUnits();
                    const a = e.fog
                      , o = i.isMeshStandardMaterial ? e.environment : null
                      , s = null === w ? b.outputColorSpace : !0 === w.isXRRenderTarget ? w.texture.colorSpace : Ne
                      , c = (i.isMeshStandardMaterial ? it : nt).get(i.envMap || o)
                      , l = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                      , u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                      , h = !!n.morphAttributes.position
                      , d = !!n.morphAttributes.normal
                      , p = !!n.morphAttributes.color;
                    let f = J;
                    i.toneMapped && (null !== w && !0 !== w.isXRRenderTarget || (f = b.toneMapping));
                    const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                      , g = void 0 !== m ? m.length : 0
                      , v = tt.get(i)
                      , _ = y.state.lights;
                    if (!0 === G && (!0 === j || t !== R)) {
                        const e = t === R && i.id === A;
                        ht.setState(i, t, e)
                    }
                    let x = !1;
                    i.version === v.__version ? v.needsLights && v.lightsStateVersion !== _.state.version || v.outputColorSpace !== s || r.isBatchedMesh && !1 === v.batching ? x = !0 : r.isBatchedMesh || !0 !== v.batching ? r.isInstancedMesh && !1 === v.instancing ? x = !0 : r.isInstancedMesh || !0 !== v.instancing ? r.isSkinnedMesh && !1 === v.skinning ? x = !0 : r.isSkinnedMesh || !0 !== v.skinning ? r.isInstancedMesh && !0 === v.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === v.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === v.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === v.instancingMorph && null !== r.morphTexture || v.envMap !== c || !0 === i.fog && v.fog !== a ? x = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === ht.numPlanes && v.numIntersection === ht.numIntersection ? (v.vertexAlphas !== l || v.vertexTangents !== u || v.morphTargets !== h || v.morphNormals !== d || v.morphColors !== p || v.toneMapping !== f || v.morphTargetsCount !== g) && (x = !0) : x = !0 : x = !0 : x = !0 : x = !0 : (x = !0,
                    v.__version = i.version);
                    let M = v.currentProgram;
                    !0 === x && (M = Jt(i, e, r));
                    let S = !1
                      , E = !1
                      , T = !1;
                    const C = M.getUniforms()
                      , P = v.uniforms;
                    if (Z.useProgram(M.program) && (S = !0,
                    E = !0,
                    T = !0),
                    i.id !== A && (A = i.id,
                    E = !0),
                    S || R !== t) {
                        C.setValue(bt, "projectionMatrix", t.projectionMatrix),
                        C.setValue(bt, "viewMatrix", t.matrixWorldInverse);
                        const e = C.map.cameraPosition;
                        void 0 !== e && e.setValue(bt, X.setFromMatrixPosition(t.matrixWorld)),
                        K.logarithmicDepthBuffer && C.setValue(bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                        (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(bt, "isOrthographic", !0 === t.isOrthographicCamera),
                        R !== t && (R = t,
                        E = !0,
                        T = !0)
                    }
                    if (r.isSkinnedMesh) {
                        C.setOptional(bt, r, "bindMatrix"),
                        C.setOptional(bt, r, "bindMatrixInverse");
                        const t = r.skeleton;
                        t && (null === t.boneTexture && t.computeBoneTexture(),
                        C.setValue(bt, "boneTexture", t.boneTexture, et))
                    }
                    r.isBatchedMesh && (C.setOptional(bt, r, "batchingTexture"),
                    C.setValue(bt, "batchingTexture", r._matricesTexture, et));
                    const L = n.morphAttributes;
                    if (void 0 === L.position && void 0 === L.normal && void 0 === L.color || ft.update(r, n, M),
                    (E || v.receiveShadow !== r.receiveShadow) && (v.receiveShadow = r.receiveShadow,
                    C.setValue(bt, "receiveShadow", r.receiveShadow)),
                    i.isMeshGouraudMaterial && null !== i.envMap && (P.envMap.value = c,
                    P.flipEnvMap.value = c.isCubeTexture && !1 === c.isRenderTargetTexture ? -1 : 1),
                    i.isMeshStandardMaterial && null === i.envMap && null !== e.environment && (P.envMapIntensity.value = e.environmentIntensity),
                    E && (C.setValue(bt, "toneMappingExposure", b.toneMappingExposure),
                    v.needsLights && ne(P, T),
                    a && !0 === i.fog && ct.refreshFogUniforms(P, a),
                    ct.refreshMaterialUniforms(P, i, O, N, y.state.transmissionRenderTarget[t.id]),
                    hu.upload(bt, Qt(v), P, et)),
                    i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (hu.upload(bt, Qt(v), P, et),
                    i.uniformsNeedUpdate = !1),
                    i.isSpriteMaterial && C.setValue(bt, "center", r.center),
                    C.setValue(bt, "modelViewMatrix", r.modelViewMatrix),
                    C.setValue(bt, "normalMatrix", r.normalMatrix),
                    C.setValue(bt, "modelMatrix", r.matrixWorld),
                    i.isShaderMaterial || i.isRawShaderMaterial) {
                        const t = i.uniformsGroups;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            yt.update(n, M),
                            yt.bind(n, M)
                        }
                    }
                    return M
                }
                function ne(t, e) {
                    t.ambientLightColor.needsUpdate = e,
                    t.lightProbe.needsUpdate = e,
                    t.directionalLights.needsUpdate = e,
                    t.directionalLightShadows.needsUpdate = e,
                    t.pointLights.needsUpdate = e,
                    t.pointLightShadows.needsUpdate = e,
                    t.spotLights.needsUpdate = e,
                    t.spotLightShadows.needsUpdate = e,
                    t.rectAreaLights.needsUpdate = e,
                    t.hemisphereLights.needsUpdate = e
                }
                function ie(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }
                Xt.setAnimationLoop(zt),
                "undefined" !== typeof self && Xt.setContext(self),
                this.setAnimationLoop = function(t) {
                    kt = t,
                    At.setAnimationLoop(t),
                    null === t ? Xt.stop() : Xt.start()
                }
                ,
                At.addEventListener("sessionstart", Ht),
                At.addEventListener("sessionend", Wt),
                this.render = function(t, e) {
                    if (void 0 !== e && !0 !== e.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === S)
                        return;
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    !0 === At.enabled && !0 === At.isPresenting && (!0 === At.cameraAutoUpdate && At.updateCamera(e),
                    e = At.getCamera()),
                    !0 === t.isScene && t.onBeforeRender(b, t, e, w),
                    y = ut.get(t, M.length),
                    y.init(e),
                    M.push(y),
                    W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                    H.setFromProjectionMatrix(W),
                    j = this.localClippingEnabled,
                    G = ht.init(this.clippingPlanes, j),
                    _ = lt.get(t, x.length),
                    _.init(),
                    x.push(_),
                    qt(t, e, 0, b.sortObjects),
                    _.finish(),
                    !0 === b.sortObjects && _.sort(F, B);
                    const n = !1 === At.enabled || !1 === At.isPresenting || !1 === At.hasDepthSensing();
                    n && pt.addToRenderList(_, t),
                    this.info.render.frame++,
                    !0 === G && ht.beginShadows();
                    const i = y.state.shadowsArray;
                    dt.render(i, t, e),
                    !0 === G && ht.endShadows(),
                    !0 === this.info.autoReset && this.info.reset();
                    const r = _.opaque
                      , a = _.transmissive;
                    if (y.setupLights(b._useLegacyLights),
                    e.isArrayCamera) {
                        const i = e.cameras;
                        if (a.length > 0)
                            for (let e = 0, n = i.length; e < n; e++) {
                                const n = i[e];
                                Yt(r, a, t, n)
                            }
                        n && pt.render(t);
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            $t(_, t, n, n.viewport)
                        }
                    } else
                        a.length > 0 && Yt(r, a, t, e),
                        n && pt.render(t),
                        $t(_, t, e);
                    null !== w && (et.updateMultisampleRenderTarget(w),
                    et.updateRenderTargetMipmap(w)),
                    !0 === t.isScene && t.onAfterRender(b, t, e),
                    _t.resetDefaultState(),
                    A = -1,
                    R = null,
                    M.pop(),
                    M.length > 0 ? (y = M[M.length - 1],
                    !0 === G && ht.setGlobalState(b.clippingPlanes, y.state.camera)) : y = null,
                    x.pop(),
                    _ = x.length > 0 ? x[x.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return E
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return T
                }
                ,
                this.getRenderTarget = function() {
                    return w
                }
                ,
                this.setRenderTargetTextures = function(t, e, n) {
                    tt.get(t.texture).__webglTexture = e,
                    tt.get(t.depthTexture).__webglTexture = n;
                    const i = tt.get(t);
                    i.__hasExternalTextures = !0,
                    i.__autoAllocateDepthBuffer = void 0 === n,
                    i.__autoAllocateDepthBuffer || !0 === Y.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    i.__useRenderToTexture = !1)
                }
                ,
                this.setRenderTargetFramebuffer = function(t, e) {
                    const n = tt.get(t);
                    n.__webglFramebuffer = e,
                    n.__useDefaultFramebuffer = void 0 === e
                }
                ,
                this.setRenderTarget = function(t, e=0, n=0) {
                    w = t,
                    E = e,
                    T = n;
                    let i = !0
                      , r = null
                      , a = !1
                      , o = !1;
                    if (t) {
                        const s = tt.get(t);
                        void 0 !== s.__useDefaultFramebuffer ? (Z.bindFramebuffer(bt.FRAMEBUFFER, null),
                        i = !1) : void 0 === s.__webglFramebuffer ? et.setupRenderTarget(t) : s.__hasExternalTextures && et.rebindTextures(t, tt.get(t.texture).__webglTexture, tt.get(t.depthTexture).__webglTexture);
                        const c = t.texture;
                        (c.isData3DTexture || c.isDataArrayTexture || c.isCompressedArrayTexture) && (o = !0);
                        const l = tt.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = Array.isArray(l[e]) ? l[e][n] : l[e],
                        a = !0) : r = t.samples > 0 && !1 === et.useMultisampledRTT(t) ? tt.get(t).__webglMultisampledFramebuffer : Array.isArray(l) ? l[n] : l,
                        C.copy(t.viewport),
                        P.copy(t.scissor),
                        L = t.scissorTest
                    } else
                        C.copy(k).multiplyScalar(O).floor(),
                        P.copy(z).multiplyScalar(O).floor(),
                        L = V;
                    const s = Z.bindFramebuffer(bt.FRAMEBUFFER, r);
                    if (s && i && Z.drawBuffers(t, r),
                    Z.viewport(C),
                    Z.scissor(P),
                    Z.setScissorTest(L),
                    a) {
                        const i = tt.get(t.texture);
                        bt.framebufferTexture2D(bt.FRAMEBUFFER, bt.COLOR_ATTACHMENT0, bt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                    } else if (o) {
                        const i = tt.get(t.texture)
                          , r = e || 0;
                        bt.framebufferTextureLayer(bt.FRAMEBUFFER, bt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    A = -1
                }
                ,
                this.readRenderTargetPixels = function(t, e, n, i, r, a, o) {
                    if (!t || !t.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = tt.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]),
                    s) {
                        Z.bindFramebuffer(bt.FRAMEBUFFER, s);
                        try {
                            const o = t.texture
                              , s = o.format
                              , c = o.type;
                            if (!K.textureFormatReadable(s))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!K.textureTypeReadable(c))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && bt.readPixels(e, n, i, r, vt.convert(s), vt.convert(c), a)
                        } finally {
                            const t = null !== w ? tt.get(w).__webglFramebuffer : null;
                            Z.bindFramebuffer(bt.FRAMEBUFFER, t)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(t, e, n=0) {
                    const i = Math.pow(2, -n)
                      , r = Math.floor(e.image.width * i)
                      , a = Math.floor(e.image.height * i);
                    et.setTexture2D(e, 0),
                    bt.copyTexSubImage2D(bt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, a),
                    Z.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(t, e, n, i=0) {
                    const r = e.image.width
                      , a = e.image.height
                      , o = vt.convert(n.format)
                      , s = vt.convert(n.type);
                    et.setTexture2D(n, 0),
                    bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL, n.flipY),
                    bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                    bt.pixelStorei(bt.UNPACK_ALIGNMENT, n.unpackAlignment),
                    e.isDataTexture ? bt.texSubImage2D(bt.TEXTURE_2D, i, t.x, t.y, r, a, o, s, e.image.data) : e.isCompressedTexture ? bt.compressedTexSubImage2D(bt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : bt.texSubImage2D(bt.TEXTURE_2D, i, t.x, t.y, o, s, e.image),
                    0 === i && n.generateMipmaps && bt.generateMipmap(bt.TEXTURE_2D),
                    Z.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(t, e, n, i, r=0) {
                    const a = t.max.x - t.min.x
                      , o = t.max.y - t.min.y
                      , s = t.max.z - t.min.z
                      , c = vt.convert(i.format)
                      , l = vt.convert(i.type);
                    let u;
                    if (i.isData3DTexture)
                        et.setTexture3D(i, 0),
                        u = bt.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        et.setTexture2DArray(i, 0),
                        u = bt.TEXTURE_2D_ARRAY
                    }
                    bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL, i.flipY),
                    bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                    bt.pixelStorei(bt.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const h = bt.getParameter(bt.UNPACK_ROW_LENGTH)
                      , d = bt.getParameter(bt.UNPACK_IMAGE_HEIGHT)
                      , p = bt.getParameter(bt.UNPACK_SKIP_PIXELS)
                      , f = bt.getParameter(bt.UNPACK_SKIP_ROWS)
                      , m = bt.getParameter(bt.UNPACK_SKIP_IMAGES)
                      , g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                    bt.pixelStorei(bt.UNPACK_ROW_LENGTH, g.width),
                    bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT, g.height),
                    bt.pixelStorei(bt.UNPACK_SKIP_PIXELS, t.min.x),
                    bt.pixelStorei(bt.UNPACK_SKIP_ROWS, t.min.y),
                    bt.pixelStorei(bt.UNPACK_SKIP_IMAGES, t.min.z),
                    n.isDataTexture || n.isData3DTexture ? bt.texSubImage3D(u, r, e.x, e.y, e.z, a, o, s, c, l, g.data) : i.isCompressedArrayTexture ? bt.compressedTexSubImage3D(u, r, e.x, e.y, e.z, a, o, s, c, g.data) : bt.texSubImage3D(u, r, e.x, e.y, e.z, a, o, s, c, l, g),
                    bt.pixelStorei(bt.UNPACK_ROW_LENGTH, h),
                    bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT, d),
                    bt.pixelStorei(bt.UNPACK_SKIP_PIXELS, p),
                    bt.pixelStorei(bt.UNPACK_SKIP_ROWS, f),
                    bt.pixelStorei(bt.UNPACK_SKIP_IMAGES, m),
                    0 === r && i.generateMipmaps && bt.generateMipmap(u),
                    Z.unbindTexture()
                }
                ,
                this.initTexture = function(t) {
                    t.isCubeTexture ? et.setTextureCube(t, 0) : t.isData3DTexture ? et.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? et.setTexture2DArray(t, 0) : et.setTexture2D(t, 0),
                    Z.unbindTexture()
                }
                ,
                this.resetState = function() {
                    E = 0,
                    T = 0,
                    w = null,
                    Z.reset(),
                    _t.reset()
                }
                ,
                "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return tn
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(t) {
                this._outputColorSpace = t;
                const e = this.getContext();
                e.drawingBufferColorSpace = t === Oe ? "display-p3" : "srgb",
                e.unpackColorSpace = Gn.workingColorSpace === Fe ? "display-p3" : "srgb"
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(t) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = t
            }
        }
        class Sh extends cr {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.backgroundRotation = new Wi,
                this.environmentIntensity = 1,
                this.environmentRotation = new Wi,
                this.overrideMaterial = null,
                "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                this.backgroundBlurriness = t.backgroundBlurriness,
                this.backgroundIntensity = t.backgroundIntensity,
                this.backgroundRotation.copy(t.backgroundRotation),
                this.environmentIntensity = t.environmentIntensity,
                this.environmentRotation.copy(t.environmentRotation),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity),
                e.object.backgroundRotation = this.backgroundRotation.toArray(),
                1 !== this.environmentIntensity && (e.object.environmentIntensity = this.environmentIntensity),
                e.object.environmentRotation = this.environmentRotation.toArray(),
                e
            }
        }
        class Eh extends Ar {
            constructor(t) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new Er(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this.fog = t.fog,
                this
            }
        }
        const Th = new ai
          , wh = new ai
          , Ah = new Ni
          , Rh = new Di
          , Ch = new wi
          , Ph = new ai
          , Lh = new ai;
        class Ih extends cr {
            constructor(t=new Hr, e=new Eh) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [0];
                    for (let t = 1, i = e.count; t < i; t++)
                        Th.fromBufferAttribute(e, t - 1),
                        wh.fromBufferAttribute(e, t),
                        n[t] = n[t - 1],
                        n[t] += Th.distanceTo(wh);
                    t.setAttribute("lineDistance", new Dr(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Line.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Ch.copy(n.boundingSphere),
                Ch.applyMatrix4(i),
                Ch.radius += r,
                !1 === t.ray.intersectsSphere(Ch))
                    return;
                Ah.copy(i).invert(),
                Rh.copy(t.ray).applyMatrix4(Ah);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = o * o
                  , c = this.isLineSegments ? 2 : 1
                  , l = n.index
                  , u = n.attributes
                  , h = u.position;
                if (null !== l) {
                    const n = Math.max(0, a.start)
                      , i = Math.min(l.count, a.start + a.count);
                    for (let r = n, a = i - 1; r < a; r += c) {
                        const n = l.getX(r)
                          , i = l.getX(r + 1)
                          , a = Uh(this, t, Rh, s, n, i);
                        a && e.push(a)
                    }
                    if (this.isLineLoop) {
                        const r = l.getX(i - 1)
                          , a = l.getX(n)
                          , o = Uh(this, t, Rh, s, r, a);
                        o && e.push(o)
                    }
                } else {
                    const n = Math.max(0, a.start)
                      , i = Math.min(h.count, a.start + a.count);
                    for (let r = n, a = i - 1; r < a; r += c) {
                        const n = Uh(this, t, Rh, s, r, r + 1);
                        n && e.push(n)
                    }
                    if (this.isLineLoop) {
                        const r = Uh(this, t, Rh, s, i - 1, n);
                        r && e.push(r)
                    }
                }
            }
            updateMorphTargets() {
                const t = this.geometry
                  , e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            }
        }
        function Uh(t, e, n, i, r, a) {
            const o = t.geometry.attributes.position;
            Th.fromBufferAttribute(o, r),
            wh.fromBufferAttribute(o, a);
            const s = n.distanceSqToSegment(Th, wh, Ph, Lh);
            if (s > i)
                return;
            Ph.applyMatrix4(t.matrixWorld);
            const c = e.ray.origin.distanceTo(Ph);
            return c < e.near || c > e.far ? void 0 : {
                distance: c,
                point: Lh.clone().applyMatrix4(t.matrixWorld),
                index: r,
                face: null,
                faceIndex: null,
                object: t
            }
        }
        const Dh = new ai
          , Nh = new ai;
        class Oh extends Ih {
            constructor(t, e) {
                super(t, e),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [];
                    for (let t = 0, i = e.count; t < i; t += 2)
                        Dh.fromBufferAttribute(e, t),
                        Nh.fromBufferAttribute(e, t + 1),
                        n[t] = 0 === t ? 0 : n[t - 1],
                        n[t + 1] = n[t] + Dh.distanceTo(Nh);
                    t.setAttribute("lineDistance", new Dr(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class Fh extends Ar {
            constructor(t) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new Er(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this.fog = t.fog,
                this
            }
        }
        const Bh = new Ni
          , kh = new Di
          , zh = new wi
          , Vh = new ai;
        class Hh extends cr {
            constructor(t=new Hr, e=new Fh) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Points.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                zh.copy(n.boundingSphere),
                zh.applyMatrix4(i),
                zh.radius += r,
                !1 === t.ray.intersectsSphere(zh))
                    return;
                Bh.copy(i).invert(),
                kh.copy(t.ray).applyMatrix4(Bh);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = o * o
                  , c = n.index
                  , l = n.attributes
                  , u = l.position;
                if (null !== c) {
                    const n = Math.max(0, a.start)
                      , r = Math.min(c.count, a.start + a.count);
                    for (let a = n, o = r; a < o; a++) {
                        const n = c.getX(a);
                        Vh.fromBufferAttribute(u, n),
                        Gh(Vh, n, s, i, t, e, this)
                    }
                } else {
                    const n = Math.max(0, a.start)
                      , r = Math.min(u.count, a.start + a.count);
                    for (let a = n, o = r; a < o; a++)
                        Vh.fromBufferAttribute(u, a),
                        Gh(Vh, a, s, i, t, e, this)
                }
            }
            updateMorphTargets() {
                const t = this.geometry
                  , e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            }
        }
        function Gh(t, e, n, i, r, a, o) {
            const s = kh.distanceSqToPoint(t);
            if (s < n) {
                const n = new ai;
                kh.closestPointToPoint(t, n),
                n.applyMatrix4(i);
                const c = r.ray.origin.distanceTo(n);
                if (c < r.near || c > r.far)
                    return;
                a.push({
                    distance: c,
                    distanceToRay: Math.sqrt(s),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }
        class jh extends Ar {
            constructor(t) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new Er(16777215),
                this.specular = new Er(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Er(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Le,
                this.normalScale = new Ln(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new Wi,
                this.combine = Y,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.specular.copy(t.specular),
                this.shininess = t.shininess,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapRotation.copy(t.envMapRotation),
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.flatShading = t.flatShading,
                this.fog = t.fog,
                this
            }
        }
        function Wh(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" === typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }
        function Xh(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        }
        class qh {
            constructor(t, e, n, i) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                  , i = e[n]
                  , r = e[n - 1];
                t: {
                    e: {
                        let a;
                        n: {
                            i: if (!(t < i)) {
                                for (let a = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < r)
                                            break i;
                                        return n = e.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === a)
                                        break;
                                    if (r = i,
                                    i = e[++n],
                                    t < i)
                                        break e
                                }
                                a = e.length;
                                break n
                            }
                            if (t >= r)
                                break t;
                            {
                                const o = e[1];
                                t < o && (n = 2,
                                r = o);
                                for (let a = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === a)
                                        break;
                                    if (i = r,
                                    r = e[--n - 1],
                                    t >= r)
                                        break e
                                }
                                a = n,
                                n = 0
                            }
                        }
                        while (n < a) {
                            const i = n + a >>> 1;
                            t < e[i] ? a = i : n = i + 1
                        }
                        if (i = e[n],
                        r = e[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = e.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i;
                for (let a = 0; a !== i; ++a)
                    e[a] = n[r + a];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class $h extends qh {
            constructor(t, e, n, i) {
                super(t, e, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: we,
                    endingEnd: we
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2
                  , a = t + 1
                  , o = i[r]
                  , s = i[a];
                if (void 0 === o)
                    switch (this.getSettings_().endingStart) {
                    case Ae:
                        r = t,
                        o = 2 * e - n;
                        break;
                    case Re:
                        r = i.length - 2,
                        o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t,
                        o = n
                    }
                if (void 0 === s)
                    switch (this.getSettings_().endingEnd) {
                    case Ae:
                        a = t,
                        s = 2 * n - e;
                        break;
                    case Re:
                        a = 1,
                        s = n + i[1] - i[0];
                        break;
                    default:
                        a = t - 1,
                        s = e
                    }
                const c = .5 * (n - e)
                  , l = this.valueSize;
                this._weightPrev = c / (e - o),
                this._weightNext = c / (s - n),
                this._offsetPrev = r * l,
                this._offsetNext = a * l
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , o = this.valueSize
                  , s = t * o
                  , c = s - o
                  , l = this._offsetPrev
                  , u = this._offsetNext
                  , h = this._weightPrev
                  , d = this._weightNext
                  , p = (n - e) / (i - e)
                  , f = p * p
                  , m = f * p
                  , g = -h * m + 2 * h * f - h * p
                  , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                  , _ = (-1 - d) * m + (1.5 + d) * f + .5 * p
                  , y = d * m - d * f;
                for (let x = 0; x !== o; ++x)
                    r[x] = g * a[l + x] + v * a[c + x] + _ * a[s + x] + y * a[u + x];
                return r
            }
        }
        class Yh extends qh {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , o = this.valueSize
                  , s = t * o
                  , c = s - o
                  , l = (n - e) / (i - e)
                  , u = 1 - l;
                for (let h = 0; h !== o; ++h)
                    r[h] = a[c + h] * u + a[s + h] * l;
                return r
            }
        }
        class Kh extends qh {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class Zh {
            constructor(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = Wh(e, this.TimeBufferType),
                this.values = Wh(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: Wh(t.times, Array),
                        values: Wh(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new Kh(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new Yh(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new $h(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case Se:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Ee:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case Te:
                    e = this.InterpolantFactoryMethodSmooth;
                    break
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Se;
                case this.InterpolantFactoryMethodLinear:
                    return Ee;
                case this.InterpolantFactoryMethodSmooth:
                    return Te
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , a = i - 1;
                while (r !== i && n[r] < t)
                    ++r;
                while (-1 !== a && n[a] > e)
                    --a;
                if (++a,
                0 !== r || a !== i) {
                    r >= a && (a = Math.max(a, 1),
                    r = a - 1);
                    const t = this.getValueSize();
                    this.times = n.slice(r, a),
                    this.values = this.values.slice(r * t, a * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let a = null;
                for (let o = 0; o !== r; o++) {
                    const e = n[o];
                    if ("number" === typeof e && isNaN(e)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, e),
                        t = !1;
                        break
                    }
                    if (null !== a && a > e) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, e, a),
                        t = !1;
                        break
                    }
                    a = e
                }
                if (void 0 !== i && Xh(i))
                    for (let o = 0, s = i.length; o !== s; ++o) {
                        const e = i[o];
                        if (isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, e),
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = this.times.slice()
                  , e = this.values.slice()
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === Te
                  , r = t.length - 1;
                let a = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const s = t[o]
                      , c = t[o + 1];
                    if (s !== c && (1 !== o || s !== t[0]))
                        if (i)
                            r = !0;
                        else {
                            const t = o * n
                              , i = t - n
                              , a = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[a + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (o !== a) {
                            t[a] = t[o];
                            const i = o * n
                              , r = a * n;
                            for (let t = 0; t !== n; ++t)
                                e[r + t] = e[i + t]
                        }
                        ++a
                    }
                }
                if (r > 0) {
                    t[a] = t[r];
                    for (let t = r * n, i = a * n, o = 0; o !== n; ++o)
                        e[i + o] = e[t + o];
                    ++a
                }
                return a !== t.length ? (this.times = t.slice(0, a),
                this.values = e.slice(0, a * n)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = this.times.slice()
                  , e = this.values.slice()
                  , n = this.constructor
                  , i = new n(this.name,t,e);
                return i.createInterpolant = this.createInterpolant,
                i
            }
        }
        Zh.prototype.TimeBufferType = Float32Array,
        Zh.prototype.ValueBufferType = Float32Array,
        Zh.prototype.DefaultInterpolation = Ee;
        class Jh extends Zh {
        }
        Jh.prototype.ValueTypeName = "bool",
        Jh.prototype.ValueBufferType = Array,
        Jh.prototype.DefaultInterpolation = Se,
        Jh.prototype.InterpolantFactoryMethodLinear = void 0,
        Jh.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Qh extends Zh {
        }
        Qh.prototype.ValueTypeName = "color";
        class td extends Zh {
        }
        td.prototype.ValueTypeName = "number";
        class ed extends qh {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , o = this.valueSize
                  , s = (n - e) / (i - e);
                let c = t * o;
                for (let l = c + o; c !== l; c += 4)
                    ri.slerpFlat(r, 0, a, c - o, a, c, s);
                return r
            }
        }
        class nd extends Zh {
            InterpolantFactoryMethodLinear(t) {
                return new ed(this.times,this.values,this.getValueSize(),t)
            }
        }
        nd.prototype.ValueTypeName = "quaternion",
        nd.prototype.DefaultInterpolation = Ee,
        nd.prototype.InterpolantFactoryMethodSmooth = void 0;
        class id extends Zh {
        }
        id.prototype.ValueTypeName = "string",
        id.prototype.ValueBufferType = Array,
        id.prototype.DefaultInterpolation = Se,
        id.prototype.InterpolantFactoryMethodLinear = void 0,
        id.prototype.InterpolantFactoryMethodSmooth = void 0;
        class rd extends Zh {
        }
        rd.prototype.ValueTypeName = "vector";
        const ad = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        class od {
            constructor(t, e, n) {
                const i = this;
                let r, a = !1, o = 0, s = 0;
                const c = [];
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    s++,
                    !1 === a && void 0 !== i.onStart && i.onStart(t, o, s),
                    a = !0
                }
                ,
                this.itemEnd = function(t) {
                    o++,
                    void 0 !== i.onProgress && i.onProgress(t, o, s),
                    o === s && (a = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return r ? r(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return r = t,
                    this
                }
                ,
                this.addHandler = function(t, e) {
                    return c.push(t, e),
                    this
                }
                ,
                this.removeHandler = function(t) {
                    const e = c.indexOf(t);
                    return -1 !== e && c.splice(e, 2),
                    this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = c.length; e < n; e += 2) {
                        const n = c[e]
                          , i = c[e + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(t))
                            return i
                    }
                    return null
                }
            }
        }
        const sd = new od;
        class cd {
            constructor(t) {
                this.manager = void 0 !== t ? t : sd,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(t, i, e, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t,
                this
            }
            setWithCredentials(t) {
                return this.withCredentials = t,
                this
            }
            setPath(t) {
                return this.path = t,
                this
            }
            setResourcePath(t) {
                return this.resourcePath = t,
                this
            }
            setRequestHeader(t) {
                return this.requestHeader = t,
                this
            }
        }
        cd.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const ld = {};
        class ud extends Error {
            constructor(t, e) {
                super(t),
                this.response = e
            }
        }
        class hd extends cd {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = ad.get(t);
                if (void 0 !== r)
                    return this.manager.itemStart(t),
                    setTimeout((()=>{
                        e && e(r),
                        this.manager.itemEnd(t)
                    }
                    ), 0),
                    r;
                if (void 0 !== ld[t])
                    return void ld[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                ld[t] = [],
                ld[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const a = new Request(t,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , o = this.mimeType
                  , s = this.responseType;
                fetch(a).then((e=>{
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" === typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader)
                            return e;
                        const n = ld[t]
                          , i = e.body.getReader()
                          , r = e.headers.get("X-File-Size") || e.headers.get("Content-Length")
                          , a = r ? parseInt(r) : 0
                          , o = 0 !== a;
                        let s = 0;
                        const c = new ReadableStream({
                            start(t) {
                                function e() {
                                    i.read().then((({done: i, value: r})=>{
                                        if (i)
                                            t.close();
                                        else {
                                            s += r.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: o,
                                                loaded: s,
                                                total: a
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(r),
                                            e()
                                        }
                                    }
                                    ))
                                }
                                e()
                            }
                        });
                        return new Response(c)
                    }
                    throw new ud(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)
                }
                )).then((t=>{
                    switch (s) {
                    case "arraybuffer":
                        return t.arrayBuffer();
                    case "blob":
                        return t.blob();
                    case "document":
                        return t.text().then((t=>{
                            const e = new DOMParser;
                            return e.parseFromString(t, o)
                        }
                        ));
                    case "json":
                        return t.json();
                    default:
                        if (void 0 === o)
                            return t.text();
                        {
                            const e = /charset="?([^;"\s]*)"?/i
                              , n = e.exec(o)
                              , i = n && n[1] ? n[1].toLowerCase() : void 0
                              , r = new TextDecoder(i);
                            return t.arrayBuffer().then((t=>r.decode(t)))
                        }
                    }
                }
                )).then((e=>{
                    ad.add(t, e);
                    const n = ld[t];
                    delete ld[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                }
                )).catch((e=>{
                    const n = ld[t];
                    if (void 0 === n)
                        throw this.manager.itemError(t),
                        e;
                    delete ld[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t)
                }
                )).finally((()=>{
                    this.manager.itemEnd(t)
                }
                )),
                this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t,
                this
            }
            setMimeType(t) {
                return this.mimeType = t,
                this
            }
        }
        class dd extends cr {
            constructor(t, e=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Er(t),
                this.intensity = e
            }
            dispose() {}
            copy(t, e) {
                return super.copy(t, e),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        const pd = new Ni
          , fd = new ai
          , md = new ai;
        class gd {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new Ln(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Ni,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Da,
                this._frameExtents = new Ln(1,1),
                this._viewportCount = 1,
                this._viewports = [new Qn(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = this.matrix;
                fd.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(fd),
                md.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(md),
                e.updateMatrixWorld(),
                pd.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(pd),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(pd)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        class vd extends gd {
            constructor() {
                super(new Pc(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class _d extends dd {
            constructor(t, e) {
                super(t, e),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(cr.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new cr,
                this.shadow = new vd
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        class yd extends dd {
            constructor(t, e) {
                super(t, e),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        const xd = "\\[\\]\\.:\\/"
          , Md = new RegExp("[" + xd + "]","g")
          , bd = "[^" + xd + "]"
          , Sd = "[^" + xd.replace("\\.", "") + "]"
          , Ed = /((?:WC+[\/:])*)/.source.replace("WC", bd)
          , Td = /(WCOD+)?/.source.replace("WCOD", Sd)
          , wd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", bd)
          , Ad = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", bd)
          , Rd = new RegExp("^" + Ed + Td + wd + Ad + "$")
          , Cd = ["material", "materials", "bones", "map"];
        class Pd {
            constructor(t, e, n) {
                const i = n || Ld.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }
        class Ld {
            constructor(t, e, n) {
                this.path = e,
                this.parsedPath = n || Ld.parseTrackName(e),
                this.node = Ld.findNode(t, this.parsedPath.nodeName),
                this.rootNode = t,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new Ld.Composite(t,e,n) : new Ld(t,e,n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Md, "")
            }
            static parseTrackName(t) {
                const e = Rd.exec(t);
                if (null === e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1);
                    -1 !== Cd.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n)
                        return n
                }
                if (t.children) {
                    const n = function(t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e)
                                return r;
                            const a = n(r.children);
                            if (a)
                                return a
                        }
                        return null
                    }
                      , i = n(t.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(),
                this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(),
                this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath
                  , n = e.objectName
                  , i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = Ld.findNode(this.rootNode, e.nodeName),
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in t) {
                            t = t.map;
                            break
                        }
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        t = t.material.map;
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const a = t[i];
                if (void 0 === a) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let o = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let s = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    s = this.BindingType.ArrayElement,
                    this.resolvedProperty = a,
                    this.propertyIndex = r
                } else
                    void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray,
                    this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray,
                    this.resolvedProperty = a) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[s],
                this.setValue = this.SetterByBindingTypeAndVersioning[s][o]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        Ld.Composite = Pd,
        Ld.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Ld.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        Ld.prototype.GetterByBindingType = [Ld.prototype._getValue_direct, Ld.prototype._getValue_array, Ld.prototype._getValue_arrayElement, Ld.prototype._getValue_toArray],
        Ld.prototype.SetterByBindingTypeAndVersioning = [[Ld.prototype._setValue_direct, Ld.prototype._setValue_direct_setNeedsUpdate, Ld.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_array, Ld.prototype._setValue_array_setNeedsUpdate, Ld.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_arrayElement, Ld.prototype._setValue_arrayElement_setNeedsUpdate, Ld.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_fromArray, Ld.prototype._setValue_fromArray_setNeedsUpdate, Ld.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        new Float32Array(1);
        class Id {
            constructor(t=1, e=0, n=0) {
                return this.radius = t,
                this.phi = e,
                this.theta = n,
                this
            }
            set(t, e, n) {
                return this.radius = t,
                this.phi = e,
                this.theta = n,
                this
            }
            copy(t) {
                return this.radius = t.radius,
                this.phi = t.phi,
                this.theta = t.theta,
                this
            }
            makeSafe() {
                const t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
                this
            }
            setFromVector3(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }
            setFromCartesianCoords(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n),
                0 === this.radius ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(t, n),
                this.phi = Math.acos(ln(e / this.radius, -1, 1))),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: i
            }
        })),
        "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
    },
    5729: function(t, e, n) {
        n.d(e, {
            N: function() {
                return u
            }
        });
        n(4114);
        var i = n(9318);
        const r = {
            type: "change"
        }
          , a = {
            type: "start"
        }
          , o = {
            type: "end"
        }
          , s = new i.RlV
          , c = new i.Zcv
          , l = Math.cos(70 * i.cj9.DEG2RAD);
        class u extends i.Qev {
            constructor(t, e) {
                super(),
                this.object = t,
                this.domElement = e,
                this.domElement.style.touchAction = "none",
                this.enabled = !0,
                this.target = new i.Pq0,
                this.cursor = new i.Pq0,
                this.minDistance = 0,
                this.maxDistance = 1 / 0,
                this.minZoom = 0,
                this.maxZoom = 1 / 0,
                this.minTargetRadius = 0,
                this.maxTargetRadius = 1 / 0,
                this.minPolarAngle = 0,
                this.maxPolarAngle = Math.PI,
                this.minAzimuthAngle = -1 / 0,
                this.maxAzimuthAngle = 1 / 0,
                this.enableDamping = !1,
                this.dampingFactor = .05,
                this.enableZoom = !0,
                this.zoomSpeed = 1,
                this.enableRotate = !0,
                this.rotateSpeed = 1,
                this.enablePan = !0,
                this.panSpeed = 1,
                this.screenSpacePanning = !0,
                this.keyPanSpeed = 7,
                this.zoomToCursor = !1,
                this.autoRotate = !1,
                this.autoRotateSpeed = 2,
                this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                },
                this.mouseButtons = {
                    LEFT: i.kBv.ROTATE,
                    MIDDLE: i.kBv.DOLLY,
                    RIGHT: i.kBv.PAN
                },
                this.touches = {
                    ONE: i.wtR.ROTATE,
                    TWO: i.wtR.DOLLY_PAN
                },
                this.target0 = this.target.clone(),
                this.position0 = this.object.position.clone(),
                this.zoom0 = this.object.zoom,
                this._domElementKeyEvents = null,
                this.getPolarAngle = function() {
                    return p.phi
                }
                ,
                this.getAzimuthalAngle = function() {
                    return p.theta
                }
                ,
                this.getDistance = function() {
                    return this.object.position.distanceTo(this.target)
                }
                ,
                this.listenToKeyEvents = function(t) {
                    t.addEventListener("keydown", gt),
                    this._domElementKeyEvents = t
                }
                ,
                this.stopListenToKeyEvents = function() {
                    this._domElementKeyEvents.removeEventListener("keydown", gt),
                    this._domElementKeyEvents = null
                }
                ,
                this.saveState = function() {
                    n.target0.copy(n.target),
                    n.position0.copy(n.object.position),
                    n.zoom0 = n.object.zoom
                }
                ,
                this.reset = function() {
                    n.target.copy(n.target0),
                    n.object.position.copy(n.position0),
                    n.object.zoom = n.zoom0,
                    n.object.updateProjectionMatrix(),
                    n.dispatchEvent(r),
                    n.update(),
                    h = u.NONE
                }
                ,
                this.update = function() {
                    const e = new i.Pq0
                      , a = (new i.PTz).setFromUnitVectors(t.up, new i.Pq0(0,1,0))
                      , o = a.clone().invert()
                      , v = new i.Pq0
                      , _ = new i.PTz
                      , y = new i.Pq0
                      , x = 2 * Math.PI;
                    return function(M=null) {
                        const b = n.object.position;
                        e.copy(b).sub(n.target),
                        e.applyQuaternion(a),
                        p.setFromVector3(e),
                        n.autoRotate && h === u.NONE && D(I(M)),
                        n.enableDamping ? (p.theta += f.theta * n.dampingFactor,
                        p.phi += f.phi * n.dampingFactor) : (p.theta += f.theta,
                        p.phi += f.phi);
                        let S = n.minAzimuthAngle
                          , E = n.maxAzimuthAngle;
                        isFinite(S) && isFinite(E) && (S < -Math.PI ? S += x : S > Math.PI && (S -= x),
                        E < -Math.PI ? E += x : E > Math.PI && (E -= x),
                        p.theta = S <= E ? Math.max(S, Math.min(E, p.theta)) : p.theta > (S + E) / 2 ? Math.max(S, p.theta) : Math.min(E, p.theta)),
                        p.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, p.phi)),
                        p.makeSafe(),
                        !0 === n.enableDamping ? n.target.addScaledVector(g, n.dampingFactor) : n.target.add(g),
                        n.target.sub(n.cursor),
                        n.target.clampLength(n.minTargetRadius, n.maxTargetRadius),
                        n.target.add(n.cursor);
                        let T = !1;
                        if (n.zoomToCursor && R || n.object.isOrthographicCamera)
                            p.radius = H(p.radius);
                        else {
                            const t = p.radius;
                            p.radius = H(p.radius * m),
                            T = t != p.radius
                        }
                        if (e.setFromSpherical(p),
                        e.applyQuaternion(o),
                        b.copy(n.target).add(e),
                        n.object.lookAt(n.target),
                        !0 === n.enableDamping ? (f.theta *= 1 - n.dampingFactor,
                        f.phi *= 1 - n.dampingFactor,
                        g.multiplyScalar(1 - n.dampingFactor)) : (f.set(0, 0, 0),
                        g.set(0, 0, 0)),
                        n.zoomToCursor && R) {
                            let r = null;
                            if (n.object.isPerspectiveCamera) {
                                const t = e.length();
                                r = H(t * m);
                                const i = t - r;
                                n.object.position.addScaledVector(w, i),
                                n.object.updateMatrixWorld(),
                                T = !!i
                            } else if (n.object.isOrthographicCamera) {
                                const t = new i.Pq0(A.x,A.y,0);
                                t.unproject(n.object);
                                const a = n.object.zoom;
                                n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)),
                                n.object.updateProjectionMatrix(),
                                T = a !== n.object.zoom;
                                const o = new i.Pq0(A.x,A.y,0);
                                o.unproject(n.object),
                                n.object.position.sub(o).add(t),
                                n.object.updateMatrixWorld(),
                                r = e.length()
                            } else
                                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                                n.zoomToCursor = !1;
                            null !== r && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position) : (s.origin.copy(n.object.position),
                            s.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                            Math.abs(n.object.up.dot(s.direction)) < l ? t.lookAt(n.target) : (c.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                            s.intersectPlane(c, n.target))))
                        } else if (n.object.isOrthographicCamera) {
                            const t = n.object.zoom;
                            n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)),
                            t !== n.object.zoom && (n.object.updateProjectionMatrix(),
                            T = !0)
                        }
                        return m = 1,
                        R = !1,
                        !!(T || v.distanceToSquared(n.object.position) > d || 8 * (1 - _.dot(n.object.quaternion)) > d || y.distanceToSquared(n.target) > d) && (n.dispatchEvent(r),
                        v.copy(n.object.position),
                        _.copy(n.object.quaternion),
                        y.copy(n.target),
                        !0)
                    }
                }(),
                this.dispose = function() {
                    n.domElement.removeEventListener("contextmenu", yt),
                    n.domElement.removeEventListener("pointerdown", st),
                    n.domElement.removeEventListener("pointercancel", lt),
                    n.domElement.removeEventListener("wheel", dt),
                    n.domElement.removeEventListener("pointermove", ct),
                    n.domElement.removeEventListener("pointerup", lt);
                    const t = n.domElement.getRootNode();
                    t.removeEventListener("keydown", ft, {
                        capture: !0
                    }),
                    null !== n._domElementKeyEvents && (n._domElementKeyEvents.removeEventListener("keydown", gt),
                    n._domElementKeyEvents = null)
                }
                ;
                const n = this
                  , u = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_PAN: 4,
                    TOUCH_DOLLY_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                };
                let h = u.NONE;
                const d = 1e-6
                  , p = new i.YHV
                  , f = new i.YHV;
                let m = 1;
                const g = new i.Pq0
                  , v = new i.I9Y
                  , _ = new i.I9Y
                  , y = new i.I9Y
                  , x = new i.I9Y
                  , M = new i.I9Y
                  , b = new i.I9Y
                  , S = new i.I9Y
                  , E = new i.I9Y
                  , T = new i.I9Y
                  , w = new i.Pq0
                  , A = new i.I9Y;
                let R = !1;
                const C = []
                  , P = {};
                let L = !1;
                function I(t) {
                    return null !== t ? 2 * Math.PI / 60 * n.autoRotateSpeed * t : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
                }
                function U(t) {
                    const e = Math.abs(.01 * t);
                    return Math.pow(.95, n.zoomSpeed * e)
                }
                function D(t) {
                    f.theta -= t
                }
                function N(t) {
                    f.phi -= t
                }
                const O = function() {
                    const t = new i.Pq0;
                    return function(e, n) {
                        t.setFromMatrixColumn(n, 0),
                        t.multiplyScalar(-e),
                        g.add(t)
                    }
                }()
                  , F = function() {
                    const t = new i.Pq0;
                    return function(e, i) {
                        !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0),
                        t.crossVectors(n.object.up, t)),
                        t.multiplyScalar(e),
                        g.add(t)
                    }
                }()
                  , B = function() {
                    const t = new i.Pq0;
                    return function(e, i) {
                        const r = n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            const a = n.object.position;
                            t.copy(a).sub(n.target);
                            let o = t.length();
                            o *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                            O(2 * e * o / r.clientHeight, n.object.matrix),
                            F(2 * i * o / r.clientHeight, n.object.matrix)
                        } else
                            n.object.isOrthographicCamera ? (O(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                            F(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                            n.enablePan = !1)
                    }
                }();
                function k(t) {
                    n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? m /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
                }
                function z(t) {
                    n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? m *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
                }
                function V(t, e) {
                    if (!n.zoomToCursor)
                        return;
                    R = !0;
                    const i = n.domElement.getBoundingClientRect()
                      , r = t - i.left
                      , a = e - i.top
                      , o = i.width
                      , s = i.height;
                    A.x = r / o * 2 - 1,
                    A.y = -a / s * 2 + 1,
                    w.set(A.x, A.y, 1).unproject(n.object).sub(n.object.position).normalize()
                }
                function H(t) {
                    return Math.max(n.minDistance, Math.min(n.maxDistance, t))
                }
                function G(t) {
                    v.set(t.clientX, t.clientY)
                }
                function j(t) {
                    V(t.clientX, t.clientX),
                    S.set(t.clientX, t.clientY)
                }
                function W(t) {
                    x.set(t.clientX, t.clientY)
                }
                function X(t) {
                    _.set(t.clientX, t.clientY),
                    y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
                    const e = n.domElement;
                    D(2 * Math.PI * y.x / e.clientHeight),
                    N(2 * Math.PI * y.y / e.clientHeight),
                    v.copy(_),
                    n.update()
                }
                function q(t) {
                    E.set(t.clientX, t.clientY),
                    T.subVectors(E, S),
                    T.y > 0 ? k(U(T.y)) : T.y < 0 && z(U(T.y)),
                    S.copy(E),
                    n.update()
                }
                function $(t) {
                    M.set(t.clientX, t.clientY),
                    b.subVectors(M, x).multiplyScalar(n.panSpeed),
                    B(b.x, b.y),
                    x.copy(M),
                    n.update()
                }
                function Y(t) {
                    V(t.clientX, t.clientY),
                    t.deltaY < 0 ? z(U(t.deltaY)) : t.deltaY > 0 && k(U(t.deltaY)),
                    n.update()
                }
                function K(t) {
                    let e = !1;
                    switch (t.code) {
                    case n.keys.UP:
                        t.ctrlKey || t.metaKey || t.shiftKey ? N(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : B(0, n.keyPanSpeed),
                        e = !0;
                        break;
                    case n.keys.BOTTOM:
                        t.ctrlKey || t.metaKey || t.shiftKey ? N(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : B(0, -n.keyPanSpeed),
                        e = !0;
                        break;
                    case n.keys.LEFT:
                        t.ctrlKey || t.metaKey || t.shiftKey ? D(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : B(n.keyPanSpeed, 0),
                        e = !0;
                        break;
                    case n.keys.RIGHT:
                        t.ctrlKey || t.metaKey || t.shiftKey ? D(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : B(-n.keyPanSpeed, 0),
                        e = !0;
                        break
                    }
                    e && (t.preventDefault(),
                    n.update())
                }
                function Z(t) {
                    if (1 === C.length)
                        v.set(t.pageX, t.pageY);
                    else {
                        const e = Et(t)
                          , n = .5 * (t.pageX + e.x)
                          , i = .5 * (t.pageY + e.y);
                        v.set(n, i)
                    }
                }
                function J(t) {
                    if (1 === C.length)
                        x.set(t.pageX, t.pageY);
                    else {
                        const e = Et(t)
                          , n = .5 * (t.pageX + e.x)
                          , i = .5 * (t.pageY + e.y);
                        x.set(n, i)
                    }
                }
                function Q(t) {
                    const e = Et(t)
                      , n = t.pageX - e.x
                      , i = t.pageY - e.y
                      , r = Math.sqrt(n * n + i * i);
                    S.set(0, r)
                }
                function tt(t) {
                    n.enableZoom && Q(t),
                    n.enablePan && J(t)
                }
                function et(t) {
                    n.enableZoom && Q(t),
                    n.enableRotate && Z(t)
                }
                function nt(t) {
                    if (1 == C.length)
                        _.set(t.pageX, t.pageY);
                    else {
                        const e = Et(t)
                          , n = .5 * (t.pageX + e.x)
                          , i = .5 * (t.pageY + e.y);
                        _.set(n, i)
                    }
                    y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
                    const e = n.domElement;
                    D(2 * Math.PI * y.x / e.clientHeight),
                    N(2 * Math.PI * y.y / e.clientHeight),
                    v.copy(_)
                }
                function it(t) {
                    if (1 === C.length)
                        M.set(t.pageX, t.pageY);
                    else {
                        const e = Et(t)
                          , n = .5 * (t.pageX + e.x)
                          , i = .5 * (t.pageY + e.y);
                        M.set(n, i)
                    }
                    b.subVectors(M, x).multiplyScalar(n.panSpeed),
                    B(b.x, b.y),
                    x.copy(M)
                }
                function rt(t) {
                    const e = Et(t)
                      , i = t.pageX - e.x
                      , r = t.pageY - e.y
                      , a = Math.sqrt(i * i + r * r);
                    E.set(0, a),
                    T.set(0, Math.pow(E.y / S.y, n.zoomSpeed)),
                    k(T.y),
                    S.copy(E);
                    const o = .5 * (t.pageX + e.x)
                      , s = .5 * (t.pageY + e.y);
                    V(o, s)
                }
                function at(t) {
                    n.enableZoom && rt(t),
                    n.enablePan && it(t)
                }
                function ot(t) {
                    n.enableZoom && rt(t),
                    n.enableRotate && nt(t)
                }
                function st(t) {
                    !1 !== n.enabled && (0 === C.length && (n.domElement.setPointerCapture(t.pointerId),
                    n.domElement.addEventListener("pointermove", ct),
                    n.domElement.addEventListener("pointerup", lt)),
                    bt(t) || (xt(t),
                    "touch" === t.pointerType ? vt(t) : ut(t)))
                }
                function ct(t) {
                    !1 !== n.enabled && ("touch" === t.pointerType ? _t(t) : ht(t))
                }
                function lt(t) {
                    switch (Mt(t),
                    C.length) {
                    case 0:
                        n.domElement.releasePointerCapture(t.pointerId),
                        n.domElement.removeEventListener("pointermove", ct),
                        n.domElement.removeEventListener("pointerup", lt),
                        n.dispatchEvent(o),
                        h = u.NONE;
                        break;
                    case 1:
                        const e = C[0]
                          , i = P[e];
                        vt({
                            pointerId: e,
                            pageX: i.x,
                            pageY: i.y
                        });
                        break
                    }
                }
                function ut(t) {
                    let e;
                    switch (t.button) {
                    case 0:
                        e = n.mouseButtons.LEFT;
                        break;
                    case 1:
                        e = n.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        e = n.mouseButtons.RIGHT;
                        break;
                    default:
                        e = -1
                    }
                    switch (e) {
                    case i.kBv.DOLLY:
                        if (!1 === n.enableZoom)
                            return;
                        j(t),
                        h = u.DOLLY;
                        break;
                    case i.kBv.ROTATE:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan)
                                return;
                            W(t),
                            h = u.PAN
                        } else {
                            if (!1 === n.enableRotate)
                                return;
                            G(t),
                            h = u.ROTATE
                        }
                        break;
                    case i.kBv.PAN:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate)
                                return;
                            G(t),
                            h = u.ROTATE
                        } else {
                            if (!1 === n.enablePan)
                                return;
                            W(t),
                            h = u.PAN
                        }
                        break;
                    default:
                        h = u.NONE
                    }
                    h !== u.NONE && n.dispatchEvent(a)
                }
                function ht(t) {
                    switch (h) {
                    case u.ROTATE:
                        if (!1 === n.enableRotate)
                            return;
                        X(t);
                        break;
                    case u.DOLLY:
                        if (!1 === n.enableZoom)
                            return;
                        q(t);
                        break;
                    case u.PAN:
                        if (!1 === n.enablePan)
                            return;
                        $(t);
                        break
                    }
                }
                function dt(t) {
                    !1 !== n.enabled && !1 !== n.enableZoom && h === u.NONE && (t.preventDefault(),
                    n.dispatchEvent(a),
                    Y(pt(t)),
                    n.dispatchEvent(o))
                }
                function pt(t) {
                    const e = t.deltaMode
                      , n = {
                        clientX: t.clientX,
                        clientY: t.clientY,
                        deltaY: t.deltaY
                    };
                    switch (e) {
                    case 1:
                        n.deltaY *= 16;
                        break;
                    case 2:
                        n.deltaY *= 100;
                        break
                    }
                    return t.ctrlKey && !L && (n.deltaY *= 10),
                    n
                }
                function ft(t) {
                    if ("Control" === t.key) {
                        L = !0;
                        const t = n.domElement.getRootNode();
                        t.addEventListener("keyup", mt, {
                            passive: !0,
                            capture: !0
                        })
                    }
                }
                function mt(t) {
                    if ("Control" === t.key) {
                        L = !1;
                        const t = n.domElement.getRootNode();
                        t.removeEventListener("keyup", mt, {
                            passive: !0,
                            capture: !0
                        })
                    }
                }
                function gt(t) {
                    !1 !== n.enabled && !1 !== n.enablePan && K(t)
                }
                function vt(t) {
                    switch (St(t),
                    C.length) {
                    case 1:
                        switch (n.touches.ONE) {
                        case i.wtR.ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            Z(t),
                            h = u.TOUCH_ROTATE;
                            break;
                        case i.wtR.PAN:
                            if (!1 === n.enablePan)
                                return;
                            J(t),
                            h = u.TOUCH_PAN;
                            break;
                        default:
                            h = u.NONE
                        }
                        break;
                    case 2:
                        switch (n.touches.TWO) {
                        case i.wtR.DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                            tt(t),
                            h = u.TOUCH_DOLLY_PAN;
                            break;
                        case i.wtR.DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                            et(t),
                            h = u.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            h = u.NONE
                        }
                        break;
                    default:
                        h = u.NONE
                    }
                    h !== u.NONE && n.dispatchEvent(a)
                }
                function _t(t) {
                    switch (St(t),
                    h) {
                    case u.TOUCH_ROTATE:
                        if (!1 === n.enableRotate)
                            return;
                        nt(t),
                        n.update();
                        break;
                    case u.TOUCH_PAN:
                        if (!1 === n.enablePan)
                            return;
                        it(t),
                        n.update();
                        break;
                    case u.TOUCH_DOLLY_PAN:
                        if (!1 === n.enableZoom && !1 === n.enablePan)
                            return;
                        at(t),
                        n.update();
                        break;
                    case u.TOUCH_DOLLY_ROTATE:
                        if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                        ot(t),
                        n.update();
                        break;
                    default:
                        h = u.NONE
                    }
                }
                function yt(t) {
                    !1 !== n.enabled && t.preventDefault()
                }
                function xt(t) {
                    C.push(t.pointerId)
                }
                function Mt(t) {
                    delete P[t.pointerId];
                    for (let e = 0; e < C.length; e++)
                        if (C[e] == t.pointerId)
                            return void C.splice(e, 1)
                }
                function bt(t) {
                    for (let e = 0; e < C.length; e++)
                        if (C[e] == t.pointerId)
                            return !0;
                    return !1
                }
                function St(t) {
                    let e = P[t.pointerId];
                    void 0 === e && (e = new i.I9Y,
                    P[t.pointerId] = e),
                    e.set(t.pageX, t.pageY)
                }
                function Et(t) {
                    const e = t.pointerId === C[0] ? C[1] : C[0];
                    return P[e]
                }
                n.domElement.addEventListener("contextmenu", yt),
                n.domElement.addEventListener("pointerdown", st),
                n.domElement.addEventListener("pointercancel", lt),
                n.domElement.addEventListener("wheel", dt, {
                    passive: !1
                });
                const Tt = n.domElement.getRootNode();
                Tt.addEventListener("keydown", ft, {
                    passive: !0,
                    capture: !0
                }),
                this.update()
            }
        }
    },
    8429: function(t, e, n) {
        n.d(e, {
            L: function() {
                return g
            }
        });
        n(4114);
        var i = n(9318);
        const r = /^[og]\s*(.+)?/
          , a = /^mtllib /
          , o = /^usemtl /
          , s = /^usemap /
          , c = /\s+/
          , l = new i.Pq0
          , u = new i.Pq0
          , h = new i.Pq0
          , d = new i.Pq0
          , p = new i.Pq0
          , f = new i.Q1f;
        function m() {
            const t = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materials: {},
                materialLibraries: [],
                startObject: function(t, e) {
                    if (this.object && !1 === this.object.fromDeclaration)
                        return this.object.name = t,
                        void (this.object.fromDeclaration = !1 !== e);
                    const n = this.object && "function" === typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" === typeof this.object._finalize && this.object._finalize(!0),
                    this.object = {
                        name: t || "",
                        fromDeclaration: !1 !== e,
                        geometry: {
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            hasUVIndices: !1
                        },
                        materials: [],
                        smooth: !0,
                        startMaterial: function(t, e) {
                            const n = this._finalize(!1);
                            n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                            const i = {
                                index: this.materials.length,
                                name: t || "",
                                mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
                                smooth: void 0 !== n ? n.smooth : this.smooth,
                                groupStart: void 0 !== n ? n.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1,
                                clone: function(t) {
                                    const e = {
                                        index: "number" === typeof t ? t : this.index,
                                        name: this.name,
                                        mtllib: this.mtllib,
                                        smooth: this.smooth,
                                        groupStart: 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1
                                    };
                                    return e.clone = this.clone.bind(e),
                                    e
                                }
                            };
                            return this.materials.push(i),
                            i
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0)
                                return this.materials[this.materials.length - 1]
                        },
                        _finalize: function(t) {
                            const e = this.currentMaterial();
                            if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3,
                            e.groupCount = e.groupEnd - e.groupStart,
                            e.inherited = !1),
                            t && this.materials.length > 1)
                                for (let n = this.materials.length - 1; n >= 0; n--)
                                    this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                            return t && 0 === this.materials.length && this.materials.push({
                                name: "",
                                smooth: this.smooth
                            }),
                            e
                        }
                    },
                    n && n.name && "function" === typeof n.clone) {
                        const t = n.clone(0);
                        t.inherited = !0,
                        this.object.materials.push(t)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" === typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(t, e) {
                    const n = parseInt(t, 10);
                    return 3 * (n >= 0 ? n - 1 : n + e / 3)
                },
                parseNormalIndex: function(t, e) {
                    const n = parseInt(t, 10);
                    return 3 * (n >= 0 ? n - 1 : n + e / 3)
                },
                parseUVIndex: function(t, e) {
                    const n = parseInt(t, 10);
                    return 2 * (n >= 0 ? n - 1 : n + e / 2)
                },
                addVertex: function(t, e, n) {
                    const i = this.vertices
                      , r = this.object.geometry.vertices;
                    r.push(i[t + 0], i[t + 1], i[t + 2]),
                    r.push(i[e + 0], i[e + 1], i[e + 2]),
                    r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addVertexPoint: function(t) {
                    const e = this.vertices
                      , n = this.object.geometry.vertices;
                    n.push(e[t + 0], e[t + 1], e[t + 2])
                },
                addVertexLine: function(t) {
                    const e = this.vertices
                      , n = this.object.geometry.vertices;
                    n.push(e[t + 0], e[t + 1], e[t + 2])
                },
                addNormal: function(t, e, n) {
                    const i = this.normals
                      , r = this.object.geometry.normals;
                    r.push(i[t + 0], i[t + 1], i[t + 2]),
                    r.push(i[e + 0], i[e + 1], i[e + 2]),
                    r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addFaceNormal: function(t, e, n) {
                    const i = this.vertices
                      , r = this.object.geometry.normals;
                    l.fromArray(i, t),
                    u.fromArray(i, e),
                    h.fromArray(i, n),
                    p.subVectors(h, u),
                    d.subVectors(l, u),
                    p.cross(d),
                    p.normalize(),
                    r.push(p.x, p.y, p.z),
                    r.push(p.x, p.y, p.z),
                    r.push(p.x, p.y, p.z)
                },
                addColor: function(t, e, n) {
                    const i = this.colors
                      , r = this.object.geometry.colors;
                    void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]),
                    void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]),
                    void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addUV: function(t, e, n) {
                    const i = this.uvs
                      , r = this.object.geometry.uvs;
                    r.push(i[t + 0], i[t + 1]),
                    r.push(i[e + 0], i[e + 1]),
                    r.push(i[n + 0], i[n + 1])
                },
                addDefaultUV: function() {
                    const t = this.object.geometry.uvs;
                    t.push(0, 0),
                    t.push(0, 0),
                    t.push(0, 0)
                },
                addUVLine: function(t) {
                    const e = this.uvs
                      , n = this.object.geometry.uvs;
                    n.push(e[t + 0], e[t + 1])
                },
                addFace: function(t, e, n, i, r, a, o, s, c) {
                    const l = this.vertices.length;
                    let u = this.parseVertexIndex(t, l)
                      , h = this.parseVertexIndex(e, l)
                      , d = this.parseVertexIndex(n, l);
                    if (this.addVertex(u, h, d),
                    this.addColor(u, h, d),
                    void 0 !== o && "" !== o) {
                        const t = this.normals.length;
                        u = this.parseNormalIndex(o, t),
                        h = this.parseNormalIndex(s, t),
                        d = this.parseNormalIndex(c, t),
                        this.addNormal(u, h, d)
                    } else
                        this.addFaceNormal(u, h, d);
                    if (void 0 !== i && "" !== i) {
                        const t = this.uvs.length;
                        u = this.parseUVIndex(i, t),
                        h = this.parseUVIndex(r, t),
                        d = this.parseUVIndex(a, t),
                        this.addUV(u, h, d),
                        this.object.geometry.hasUVIndices = !0
                    } else
                        this.addDefaultUV()
                },
                addPointGeometry: function(t) {
                    this.object.geometry.type = "Points";
                    const e = this.vertices.length;
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = this.parseVertexIndex(t[n], e);
                        this.addVertexPoint(i),
                        this.addColor(i)
                    }
                },
                addLineGeometry: function(t, e) {
                    this.object.geometry.type = "Line";
                    const n = this.vertices.length
                      , i = this.uvs.length;
                    for (let r = 0, a = t.length; r < a; r++)
                        this.addVertexLine(this.parseVertexIndex(t[r], n));
                    for (let r = 0, a = e.length; r < a; r++)
                        this.addUVLine(this.parseUVIndex(e[r], i))
                }
            };
            return t.startObject("", !1),
            t
        }
        class g extends i.aHM {
            constructor(t) {
                super(t),
                this.materials = null
            }
            load(t, e, n, r) {
                const a = this
                  , o = new i.Y9S(this.manager);
                o.setPath(this.path),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(t, (function(n) {
                    try {
                        e(a.parse(n))
                    } catch (i) {
                        r ? r(i) : console.error(i),
                        a.manager.itemError(t)
                    }
                }
                ), n, r)
            }
            setMaterials(t) {
                return this.materials = t,
                this
            }
            parse(t) {
                const e = new m;
                -1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")),
                -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, ""));
                const n = t.split("\n");
                let l = [];
                for (let i = 0, d = n.length; i < d; i++) {
                    const t = n[i].trimStart();
                    if (0 === t.length)
                        continue;
                    const u = t.charAt(0);
                    if ("#" !== u)
                        if ("v" === u) {
                            const n = t.split(c);
                            switch (n[0]) {
                            case "v":
                                e.vertices.push(parseFloat(n[1]), parseFloat(n[2]), parseFloat(n[3])),
                                n.length >= 7 ? (f.setRGB(parseFloat(n[4]), parseFloat(n[5]), parseFloat(n[6])).convertSRGBToLinear(),
                                e.colors.push(f.r, f.g, f.b)) : e.colors.push(void 0, void 0, void 0);
                                break;
                            case "vn":
                                e.normals.push(parseFloat(n[1]), parseFloat(n[2]), parseFloat(n[3]));
                                break;
                            case "vt":
                                e.uvs.push(parseFloat(n[1]), parseFloat(n[2]));
                                break
                            }
                        } else if ("f" === u) {
                            const n = t.slice(1).trim()
                              , i = n.split(c)
                              , r = [];
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t];
                                if (e.length > 0) {
                                    const t = e.split("/");
                                    r.push(t)
                                }
                            }
                            const a = r[0];
                            for (let t = 1, o = r.length - 1; t < o; t++) {
                                const n = r[t]
                                  , i = r[t + 1];
                                e.addFace(a[0], n[0], i[0], a[1], n[1], i[1], a[2], n[2], i[2])
                            }
                        } else if ("l" === u) {
                            const n = t.substring(1).trim().split(" ");
                            let i = [];
                            const r = [];
                            if (-1 === t.indexOf("/"))
                                i = n;
                            else
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].split("/");
                                    "" !== e[0] && i.push(e[0]),
                                    "" !== e[1] && r.push(e[1])
                                }
                            e.addLineGeometry(i, r)
                        } else if ("p" === u) {
                            const n = t.slice(1).trim()
                              , i = n.split(" ");
                            e.addPointGeometry(i)
                        } else if (null !== (l = r.exec(t))) {
                            const t = (" " + l[0].slice(1).trim()).slice(1);
                            e.startObject(t)
                        } else if (o.test(t))
                            e.object.startMaterial(t.substring(7).trim(), e.materialLibraries);
                        else if (a.test(t))
                            e.materialLibraries.push(t.substring(7).trim());
                        else if (s.test(t))
                            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                        else if ("s" === u) {
                            if (l = t.split(" "),
                            l.length > 1) {
                                const t = l[1].trim().toLowerCase();
                                e.object.smooth = "0" !== t && "off" !== t
                            } else
                                e.object.smooth = !0;
                            const n = e.object.currentMaterial();
                            n && (n.smooth = e.object.smooth)
                        } else {
                            if ("\0" === t)
                                continue;
                            console.warn('THREE.OBJLoader: Unexpected line: "' + t + '"')
                        }
                }
                e.finalize();
                const u = new i.YJl;
                u.materialLibraries = [].concat(e.materialLibraries);
                const h = !(1 === e.objects.length && 0 === e.objects[0].geometry.vertices.length);
                if (!0 === h)
                    for (let r = 0, a = e.objects.length; r < a; r++) {
                        const t = e.objects[r]
                          , n = t.geometry
                          , a = t.materials
                          , o = "Line" === n.type
                          , s = "Points" === n.type;
                        let c = !1;
                        if (0 === n.vertices.length)
                            continue;
                        const l = new i.LoY;
                        l.setAttribute("position", new i.qtW(n.vertices,3)),
                        n.normals.length > 0 && l.setAttribute("normal", new i.qtW(n.normals,3)),
                        n.colors.length > 0 && (c = !0,
                        l.setAttribute("color", new i.qtW(n.colors,3))),
                        !0 === n.hasUVIndices && l.setAttribute("uv", new i.qtW(n.uvs,2));
                        const h = [];
                        for (let r = 0, u = a.length; r < u; r++) {
                            const t = a[r]
                              , n = t.name + "_" + t.smooth + "_" + c;
                            let l = e.materials[n];
                            if (null !== this.materials)
                                if (l = this.materials.create(t.name),
                                !o || !l || l instanceof i.mrM) {
                                    if (s && l && !(l instanceof i.BH$)) {
                                        const t = new i.BH$({
                                            size: 10,
                                            sizeAttenuation: !1
                                        });
                                        i.imn.prototype.copy.call(t, l),
                                        t.color.copy(l.color),
                                        t.map = l.map,
                                        l = t
                                    }
                                } else {
                                    const t = new i.mrM;
                                    i.imn.prototype.copy.call(t, l),
                                    t.color.copy(l.color),
                                    l = t
                                }
                            void 0 === l && (l = o ? new i.mrM : s ? new i.BH$({
                                size: 1,
                                sizeAttenuation: !1
                            }) : new i.tXL,
                            l.name = t.name,
                            l.flatShading = !t.smooth,
                            l.vertexColors = c,
                            e.materials[n] = l),
                            h.push(l)
                        }
                        let d;
                        if (h.length > 1) {
                            for (let t = 0, e = a.length; t < e; t++) {
                                const e = a[t];
                                l.addGroup(e.groupStart, e.groupCount, t)
                            }
                            d = o ? new i.DXC(l,h) : s ? new i.ONl(l,h) : new i.eaF(l,h)
                        } else
                            d = o ? new i.DXC(l,h[0]) : s ? new i.ONl(l,h[0]) : new i.eaF(l,h[0]);
                        d.name = t.name,
                        u.add(d)
                    }
                else if (e.vertices.length > 0) {
                    const t = new i.BH$({
                        size: 1,
                        sizeAttenuation: !1
                    })
                      , n = new i.LoY;
                    n.setAttribute("position", new i.qtW(e.vertices,3)),
                    e.colors.length > 0 && void 0 !== e.colors[0] && (n.setAttribute("color", new i.qtW(e.colors,3)),
                    t.vertexColors = !0);
                    const r = new i.ONl(n,t);
                    u.add(r)
                }
                return u
            }
        }
    }
}]);
//# sourceMappingURL=chunk-vendors.352515ca.js.map
